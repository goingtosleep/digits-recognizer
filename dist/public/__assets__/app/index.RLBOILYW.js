
var fF=Object.create,Lf=Object.defineProperty,hF=Object.getPrototypeOf,mF=Object.prototype.hasOwnProperty,dF=Object.getOwnPropertyNames,gF=Object.getOwnPropertyDescriptor;var V0=r=>Lf(r,"__esModule",{value:!0});var $n=(r,t)=>()=>(t||(t={exports:{}},r(t.exports,t)),t.exports),Yn=(r,t)=>{V0(r);for(var e in t)Lf(r,e,{get:t[e],enumerable:!0})},xF=(r,t,e)=>{if(V0(r),t&&typeof t=="object"||typeof t=="function")for(let n of dF(t))!mF.call(r,n)&&n!=="default"&&Lf(r,n,{get:()=>t[n],enumerable:!(e=gF(t,n))||e.enumerable});return r},Wc=r=>r&&r.__esModule?r:xF(Lf(r!=null?fF(hF(r)):{},"default",{value:r,enumerable:!0}),r);var dv=$n(()=>{});var gv=$n(()=>{});var yv=$n((xv,Yl)=>{var Mq=function(r,t){r=r||dv();var e=r.window,n=r.document,s=new function(){var i=/^(statics|enumerable|beans|preserve)$/,c=[],h=c.slice,g=Object.create,x=Object.getOwnPropertyDescriptor,b=Object.defineProperty,k=c.forEach||function(R,$){for(var U=0,z=this.length;U<z;U++)R.call($,this[U],U,this)},w=function(R,$){for(var U in this)this.hasOwnProperty(U)&&R.call($,this[U],U,this)},S=Object.assign||function(R){for(var $=1,U=arguments.length;$<U;$++){var z=arguments[$];for(var j in z)z.hasOwnProperty(j)&&(R[j]=z[j])}return R},I=function(R,$,U){if(R){var z=x(R,"length");(z&&typeof z.value=="number"?k:w).call(R,$,U=U||R)}return U};function D(R,$,U,z,j){var F={};function V(G,J){J=J||(J=x($,G))&&(J.get?J:J.value),typeof J=="string"&&J[0]==="#"&&(J=R[J.substring(1)]||J);var nt=typeof J=="function",ot=J,at=j||nt&&!J.base?J&&J.get?G in R:R[G]:null,lt;(!j||!at)&&(nt&&at&&(J.base=at),nt&&z!==!1&&(lt=G.match(/^([gs]et|is)(([A-Z])(.*))$/))&&(F[lt[3].toLowerCase()+lt[4]]=lt[2]),(!ot||nt||!ot.get||typeof ot.get!="function"||!O.isPlainObject(ot))&&(ot={value:ot,writable:!0}),(x(R,G)||{configurable:!0}).configurable&&(ot.configurable=!0,ot.enumerable=U??!lt),b(R,G,ot))}if($){for(var T in $)$.hasOwnProperty(T)&&!i.test(T)&&V(T);for(var T in F){var M=F[T],W=R["set"+M],q=R["get"+M]||W&&R["is"+M];q&&(z===!0||q.length===0)&&V(T,{get:q,set:W})}}return R}function O(){for(var R=0,$=arguments.length;R<$;R++){var U=arguments[R];U&&S(this,U)}return this}return D(O,{inject:function(R){if(R){var $=R.statics===!0?R:R.statics,U=R.beans,z=R.preserve;$!==R&&D(this.prototype,R,R.enumerable,U,z),D(this,$,null,U,z)}for(var j=1,F=arguments.length;j<F;j++)this.inject(arguments[j]);return this},extend:function(){for(var R=this,$,U,z=0,j,F=arguments.length;z<F&&!($&&U);z++)j=arguments[z],$=$||j.initialize,U=U||j.prototype;return $=$||function(){R.apply(this,arguments)},U=$.prototype=U||g(this.prototype),b(U,"constructor",{value:$,writable:!0,configurable:!0}),D($,this),arguments.length&&this.inject.apply($,arguments),$.base=R,$}}).inject({enumerable:!1,initialize:O,set:O,inject:function(){for(var R=0,$=arguments.length;R<$;R++){var U=arguments[R];U&&D(this,U,U.enumerable,U.beans,U.preserve)}return this},extend:function(){var R=g(this);return R.inject.apply(R,arguments)},each:function(R,$){return I(this,R,$)},clone:function(){return new this.constructor(this)},statics:{set:S,each:I,create:g,define:b,describe:x,clone:function(R){return S(new R.constructor,R)},isPlainObject:function(R){var $=R!=null&&R.constructor;return $&&($===Object||$===O||$.name==="Object")},pick:function(R,$){return R!==t?R:$},slice:function(R,$,U){return h.call(R,$,U)}}})};typeof Yl!="undefined"&&(Yl.exports=s),s.inject({enumerable:!1,toString:function(){return this._id!=null?(this._class||"Object")+(this._name?" '"+this._name+"'":" @"+this._id):"{ "+s.each(this,function(i,c){if(!/^_/.test(c)){var h=typeof i;this.push(c+": "+(h==="number"?p.instance.number(i):h==="string"?"'"+i+"'":i))}},[]).join(", ")+" }"},getClassName:function(){return this._class||""},importJSON:function(i){return s.importJSON(i,this)},exportJSON:function(i){return s.exportJSON(this,i)},toJSON:function(){return s.serialize(this)},set:function(i,c){return i&&s.filter(this,i,c,this._prioritize),this}},{beans:!1,statics:{exports:{},extend:function i(){var c=i.base.apply(this,arguments),h=c.prototype._class;return h&&!s.exports[h]&&(s.exports[h]=c),c},equals:function(i,c){if(i===c)return!0;if(i&&i.equals)return i.equals(c);if(c&&c.equals)return c.equals(i);if(i&&c&&typeof i=="object"&&typeof c=="object"){if(Array.isArray(i)&&Array.isArray(c)){var h=i.length;if(h!==c.length)return!1;for(;h--;)if(!s.equals(i[h],c[h]))return!1}else{var g=Object.keys(i),h=g.length;if(h!==Object.keys(c).length)return!1;for(;h--;){var x=g[h];if(!(c.hasOwnProperty(x)&&s.equals(i[x],c[x])))return!1}}return!0}return!1},read:function(i,c,h,g){if(this===s){var x=this.peek(i,c);return i.__index++,x}var b=this.prototype,k=b._readIndex,w=c||k&&i.__index||0,S=i.length,I=i[w];if(g=g||S-w,I instanceof this||h&&h.readNull&&I==null&&g<=1)return k&&(i.__index=w+1),I&&h&&h.clone?I.clone():I;if(I=s.create(b),k&&(I.__read=!0),I=I.initialize.apply(I,w>0||w+g<S?s.slice(i,w,w+g):i)||I,k){i.__index=w+I.__read;var D=I.__filtered;D&&(i.__filtered=D,I.__filtered=t),I.__read=t}return I},peek:function(i,c){return i[i.__index=c||i.__index||0]},remain:function(i){return i.length-(i.__index||0)},readList:function(i,c,h,g){for(var x=[],b,k=c||0,w=g?k+g:i.length,S=k;S<w;S++)x.push(Array.isArray(b=i[S])?this.read(b,0,h):this.read(i,S,h,1));return x},readNamed:function(i,c,h,g,x){var b=this.getNamed(i,c),k=b!==t;if(k){var w=i.__filtered;if(!w){var S=this.getSource(i);w=i.__filtered=s.create(S),w.__unfiltered=S}w[c]=t}return this.read(k?[b]:i,h,g,x)},readSupported:function(i,c){var h=this.getSource(i),g=this,x=!1;return h&&Object.keys(h).forEach(function(b){if(b in c){var k=g.readNamed(i,b);k!==t&&(c[b]=k),x=!0}}),x},getSource:function(i){var c=i.__source;if(c===t){var h=i.length===1&&i[0];c=i.__source=h&&s.isPlainObject(h)?h:null}return c},getNamed:function(i,c){var h=this.getSource(i);if(h)return c?h[c]:i.__filtered||h},hasNamed:function(i,c){return!!this.getNamed(i,c)},filter:function(i,c,h,g){var x;function b(D){if(!(h&&D in h)&&!(x&&D in x)){var O=c[D];O!==t&&(i[D]=O)}}if(g){for(var k={},w=0,S,I=g.length;w<I;w++)(S=g[w])in c&&(b(S),k[S]=!0);x=k}return Object.keys(c.__unfiltered||c).forEach(b),i},isPlainValue:function(i,c){return s.isPlainObject(i)||Array.isArray(i)||c&&typeof i=="string"},serialize:function(i,c,h,g){c=c||{};var x=!g,b;if(x&&(c.formatter=new p(c.precision),g={length:0,definitions:{},references:{},add:function(O,R){var $="#"+O._id,U=this.references[$];if(!U){this.length++;var z=R.call(O),j=O._class;j&&z[0]!==j&&z.unshift(j),this.definitions[$]=z,U=this.references[$]=[$]}return U}}),i&&i._serialize){b=i._serialize(c,g);var k=i._class;k&&!i._compactSerialize&&(x||!h)&&b[0]!==k&&b.unshift(k)}else if(Array.isArray(i)){b=[];for(var w=0,S=i.length;w<S;w++)b[w]=s.serialize(i[w],c,h,g)}else if(s.isPlainObject(i)){b={};for(var I=Object.keys(i),w=0,S=I.length;w<S;w++){var D=I[w];b[D]=s.serialize(i[D],c,h,g)}}else typeof i=="number"?b=c.formatter.number(i,c.precision):b=i;return x&&g.length>0?[["dictionary",g.definitions],b]:b},deserialize:function(i,c,h,g,x){var b=i,k=!h,w=k&&i&&i.length&&i[0][0]==="dictionary";if(h=h||{},Array.isArray(i)){var S=i[0],I=S==="dictionary";if(i.length==1&&/^#/.test(S))return h.dictionary[S];S=s.exports[S],b=[];for(var D=S?1:0,O=i.length;D<O;D++)b.push(s.deserialize(i[D],c,h,I,w));if(S){var R=b;c?b=c(S,R,k||x):b=new S(R)}}else if(s.isPlainObject(i)){b={},g&&(h.dictionary=b);for(var $ in i)b[$]=s.deserialize(i[$],c,h)}return w?b[1]:b},exportJSON:function(i,c){var h=s.serialize(i,c);return c&&c.asString==!1?h:JSON.stringify(h)},importJSON:function(i,c){return s.deserialize(typeof i=="string"?JSON.parse(i):i,function(h,g,x){var b=x&&c&&c.constructor===h,k=b?c:s.create(h.prototype);if(g.length===1&&k instanceof L&&(b||!(k instanceof K))){var w=g[0];s.isPlainObject(w)&&(w.insert=!1,b&&(g=g.concat([{insert:!0}])))}return(b?k.set:h).apply(k,g),b&&(c=null),k})},push:function(i,c){var h=c.length;if(h<4096)i.push.apply(i,c);else{var g=i.length;i.length+=h;for(var x=0;x<h;x++)i[g+x]=c[x]}return i},splice:function(i,c,h,g){var x=c&&c.length,b=h===t;h=b?i.length:h,h>i.length&&(h=i.length);for(var k=0;k<x;k++)c[k]._index=h+k;if(b)return s.push(i,c),[];var w=[h,g];c&&s.push(w,c);for(var S=i.splice.apply(i,w),k=0,I=S.length;k<I;k++)S[k]._index=t;for(var k=h+x,I=i.length;k<I;k++)i[k]._index=k;return S},capitalize:function(i){return i.replace(/\b[a-z]/g,function(c){return c.toUpperCase()})},camelize:function(i){return i.replace(/-(.)/g,function(c,h){return h.toUpperCase()})},hyphenate:function(i){return i.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase()}}});var o={on:function(i,c){if(typeof i!="string")s.each(i,function(b,k){this.on(k,b)},this);else{var h=this._eventTypes,g=h&&h[i],x=this._callbacks=this._callbacks||{};x=x[i]=x[i]||[],x.indexOf(c)===-1&&(x.push(c),g&&g.install&&x.length===1&&g.install.call(this,i))}return this},off:function(i,c){if(typeof i!="string"){s.each(i,function(k,w){this.off(w,k)},this);return}var h=this._eventTypes,g=h&&h[i],x=this._callbacks&&this._callbacks[i],b;return x&&(!c||(b=x.indexOf(c))!==-1&&x.length===1?(g&&g.uninstall&&g.uninstall.call(this,i),delete this._callbacks[i]):b!==-1&&x.splice(b,1)),this},once:function(i,c){return this.on(i,function h(){c.apply(this,arguments),this.off(i,h)})},emit:function(i,c){var h=this._callbacks&&this._callbacks[i];if(!h)return!1;var g=s.slice(arguments,1),x=c&&c.target&&!c.currentTarget;h=h.slice(),x&&(c.currentTarget=this);for(var b=0,k=h.length;b<k;b++)if(h[b].apply(this,g)==!1){c&&c.stop&&c.stop();break}return x&&delete c.currentTarget,!0},responds:function(i){return!!(this._callbacks&&this._callbacks[i])},attach:"#on",detach:"#off",fire:"#emit",_installEvents:function(i){var c=this._eventTypes,h=this._callbacks,g=i?"install":"uninstall";if(c){for(var x in h)if(h[x].length>0){var b=c[x],k=b&&b[g];k&&k.call(this,x)}}},statics:{inject:function i(c){var h=c._events;if(h){var g={};s.each(h,function(x,b){var k=typeof x=="string",w=k?x:b,S=s.capitalize(w),I=w.substring(2).toLowerCase();g[I]=k?{}:x,w="_"+w,c["get"+S]=function(){return this[w]},c["set"+S]=function(D){var O=this[w];O&&this.off(I,O),D&&this.on(I,D),this[w]=D}}),c._eventTypes=g}return i.base.apply(this,arguments)}}},a=s.extend({_class:"PaperScope",initialize:function i(){ye=this,this.settings=new s({applyMatrix:!0,insertItems:!0,handleSize:4,hitTolerance:0}),this.project=null,this.projects=[],this.tools=[],this._id=i._id++,i._scopes[this._id]=this;var c=i.prototype;if(!this.support){var h=Pe.getContext(1,1)||{};c.support={nativeDash:"setLineDash"in h||"mozDash"in h,nativeBlendModes:Tn.nativeModes},Pe.release(h)}if(!this.agent){var g=r.navigator.userAgent.toLowerCase(),x=(/(darwin|win|mac|linux|freebsd|sunos)/.exec(g)||[])[0],b=x==="darwin"?"mac":x,k=c.agent=c.browser={platform:b};b&&(k[b]=!0),g.replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom|node|jsdom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:v?([.\d]+))?/g,function(w,S,I,D,O){if(!k.chrome){var R=S==="opera"?D:/^(node|trident)$/.test(S)?O:I;k.version=R,k.versionNumber=parseFloat(R),S={trident:"msie",jsdom:"node"}[S]||S,k.name=S,k[S]=!0}}),k.chrome&&delete k.webkit,k.atom&&delete k.chrome}},version:"0.12.11",getView:function(){var i=this.project;return i&&i._view},getPaper:function(){return this},execute:function(i,c){var h=ye.PaperScript.execute(i,this,c);return oe.updateFocus(),h},install:function(i){var c=this;s.each(["project","view","tool"],function(g){s.define(i,g,{configurable:!0,get:function(){return c[g]}})});for(var h in this)!/^_/.test(h)&&this[h]&&(i[h]=this[h])},setup:function(i){return ye=this,this.project=new P(i),this},createCanvas:function(i,c){return Pe.getCanvas(i,c)},activate:function(){ye=this},clear:function(){for(var i=this.projects,c=this.tools,h=i.length-1;h>=0;h--)i[h].remove();for(var h=c.length-1;h>=0;h--)c[h].remove()},remove:function(){this.clear(),delete a._scopes[this._id]},statics:new function(){function i(c){return c+="Attribute",function(h,g){return h[c](g)||h[c]("data-paper-"+g)}}return{_scopes:{},_id:0,get:function(c){return this._scopes[c]||null},getAttribute:i("get"),hasAttribute:i("has")}}}),l=s.extend(o,{initialize:function(i){this._scope=ye,this._index=this._scope[this._list].push(this)-1,(i||!this._scope[this._reference])&&this.activate()},activate:function(){if(!this._scope)return!1;var i=this._scope[this._reference];return i&&i!==this&&i.emit("deactivate"),this._scope[this._reference]=this,this.emit("activate",i),!0},isActive:function(){return this._scope[this._reference]===this},remove:function(){return this._index==null?!1:(s.splice(this._scope[this._list],null,this._index,1),this._scope[this._reference]==this&&(this._scope[this._reference]=null),this._scope=null,!0)},getView:function(){return this._scope.getView()}}),u={findItemBoundsCollisions:function(i,c,h){function g(k){for(var w=new Array(k.length),S=0;S<k.length;S++){var I=k[S].getBounds();w[S]=[I.left,I.top,I.right,I.bottom]}return w}var x=g(i),b=!c||c===i?x:g(c);return this.findBoundsCollisions(x,b,h||0)},findCurveBoundsCollisions:function(i,c,h,g){function x(R){for(var $=Math.min,U=Math.max,z=new Array(R.length),j=0;j<R.length;j++){var F=R[j];z[j]=[$(F[0],F[2],F[4],F[6]),$(F[1],F[3],F[5],F[7]),U(F[0],F[2],F[4],F[6]),U(F[1],F[3],F[5],F[7])]}return z}var b=x(i),k=!c||c===i?b:x(c);if(g){for(var w=this.findBoundsCollisions(b,k,h||0,!1,!0),S=this.findBoundsCollisions(b,k,h||0,!0,!0),I=[],D=0,O=w.length;D<O;D++)I[D]={hor:w[D],ver:S[D]};return I}return this.findBoundsCollisions(b,k,h||0)},findBoundsCollisions:function(i,c,h,g,x){var b=!c||i===c,k=b?i:i.concat(c),w=i.length,S=k.length;function I(Wt,Kt,Yt){for(var Et=0,Pt=Wt.length;Et<Pt;){var Ut=Pt+Et>>>1;k[Wt[Ut]][Kt]<Yt?Et=Ut+1:Pt=Ut}return Et-1}for(var D=g?1:0,O=D+2,R=g?0:1,$=R+2,U=new Array(S),z=0;z<S;z++)U[z]=z;U.sort(function(Wt,Kt){return k[Wt][D]-k[Kt][D]});for(var j=[],F=new Array(w),z=0;z<S;z++){var V=U[z],T=k[V],M=b?V:V-w,W=V<w,q=b||!W,G=W?[]:null;if(j.length){var J=I(j,O,T[D]-h)+1;if(j.splice(0,J),b&&x){G=G.concat(j);for(var nt=0;nt<j.length;nt++){var ot=j[nt];F[ot].push(M)}}else for(var at=T[$],lt=T[R],nt=0;nt<j.length;nt++){var ot=j[nt],pt=k[ot],ut=ot<w,gt=b||ot>=w;(x||(W&&gt||q&&ut)&&at>=pt[R]-h&&lt<=pt[$]+h)&&(W&&gt&&G.push(b?ot:ot-w),q&&ut&&F[ot].push(M))}}if(W&&(i===c&&G.push(V),F[V]=G),j.length){var bt=T[O],kt=I(j,O,bt);j.splice(kt+1,0,V)}else j.push(V)}for(var z=0;z<F.length;z++){var Rt=F[z];Rt&&Rt.sort(function(Kt,Yt){return Kt-Yt})}return F}},p=s.extend({initialize:function(i){this.precision=s.pick(i,5),this.multiplier=Math.pow(10,this.precision)},number:function(i){return this.precision<16?Math.round(i*this.multiplier)/this.multiplier:i},pair:function(i,c,h){return this.number(i)+(h||",")+this.number(c)},point:function(i,c){return this.number(i.x)+(c||",")+this.number(i.y)},size:function(i,c){return this.number(i.width)+(c||",")+this.number(i.height)},rectangle:function(i,c){return this.point(i,c)+(c||",")+this.size(i,c)}});p.instance=new p;var f=new function(){var i=[[.5773502691896257],[0,.7745966692414834],[.33998104358485626,.8611363115940526],[0,.5384693101056831,.906179845938664],[.2386191860831969,.6612093864662645,.932469514203152],[0,.4058451513773972,.7415311855993945,.9491079123427585],[.1834346424956498,.525532409916329,.7966664774136267,.9602898564975363],[0,.3242534234038089,.6133714327005904,.8360311073266358,.9681602395076261],[.14887433898163122,.4333953941292472,.6794095682990244,.8650633666889845,.9739065285171717],[0,.26954315595234496,.5190961292068118,.7301520055740494,.8870625997680953,.978228658146057],[.1252334085114689,.3678314989981802,.5873179542866175,.7699026741943047,.9041172563704749,.9815606342467192],[0,.2304583159551348,.44849275103644687,.6423493394403402,.8015780907333099,.9175983992229779,.9841830547185881],[.10805494870734367,.31911236892788974,.5152486363581541,.6872929048116855,.827201315069765,.9284348836635735,.9862838086968123],[0,.20119409399743451,.3941513470775634,.5709721726085388,.7244177313601701,.8482065834104272,.937273392400706,.9879925180204854],[.09501250983763744,.2816035507792589,.45801677765722737,.6178762444026438,.755404408355003,.8656312023878318,.9445750230732326,.9894009349916499]],c=[[1],[.8888888888888888,.5555555555555556],[.6521451548625461,.34785484513745385],[.5688888888888889,.47862867049936647,.23692688505618908],[.46791393457269104,.3607615730481386,.17132449237917036],[.4179591836734694,.3818300505051189,.27970539148927664,.1294849661688697],[.362683783378362,.31370664587788727,.22238103445337448,.10122853629037626],[.3302393550012598,.31234707704000286,.26061069640293544,.1806481606948574,.08127438836157441],[.29552422471475287,.26926671930999635,.21908636251598204,.1494513491505806,.06667134430868814],[.2729250867779006,.26280454451024665,.23319376459199048,.18629021092773426,.1255803694649046,.05566856711617366],[.24914704581340277,.2334925365383548,.20316742672306592,.16007832854334622,.10693932599531843,.04717533638651183],[.2325515532308739,.22628318026289723,.2078160475368885,.17814598076194574,.13887351021978725,.09212149983772845,.04048400476531588],[.2152638534631578,.2051984637212956,.18553839747793782,.15720316715819355,.12151857068790319,.08015808715976021,.03511946033175186],[.2025782419255613,.19843148532711158,.1861610000155622,.16626920581699392,.13957067792615432,.10715922046717194,.07036604748810812,.03075324199611727],[.1894506104550685,.18260341504492358,.16915651939500254,.14959598881657674,.12462897125553388,.09515851168249279,.062253523938647894,.027152459411754096]],h=Math.abs,g=Math.sqrt,x=Math.pow,b=Math.log2||function(O){return Math.log(O)*Math.LOG2E},k=1e-12,w=112e-18;function S(O,R,$){return O<R?R:O>$?$:O}function I(O,R,$){function U(J){var nt=J*134217729,ot=J-nt,at=ot+nt,lt=J-at;return[at,lt]}var z=R*R-O*$,j=R*R+O*$;if(h(z)*3<j){var F=U(O),V=U(R),T=U($),M=R*R,W=V[0]*V[0]-M+2*V[0]*V[1]+V[1]*V[1],q=O*$,G=F[0]*T[0]-q+F[0]*T[1]+F[1]*T[0]+F[1]*T[1];z=M-q+(W-G)}return z}function D(){var O=Math.max.apply(Math,arguments);return O&&(O<1e-8||O>1e8)?x(2,-Math.round(b(O))):0}return{EPSILON:k,MACHINE_EPSILON:w,CURVETIME_EPSILON:1e-8,GEOMETRIC_EPSILON:1e-7,TRIGONOMETRIC_EPSILON:1e-8,KAPPA:4*(g(2)-1)/3,isZero:function(O){return O>=-k&&O<=k},isMachineZero:function(O){return O>=-w&&O<=w},clamp:S,integrate:function(O,R,$,U){for(var z=i[U-2],j=c[U-2],F=($-R)*.5,V=F+R,T=0,M=U+1>>1,W=U&1?j[T++]*O(V):0;T<M;){var q=F*z[T];W+=j[T++]*(O(V+q)+O(V-q))}return F*W},findRoot:function(O,R,$,U,z,j,F){for(var V=0;V<j;V++){var T=O($),M=T/R($),W=$-M;if(h(M)<F){$=W;break}T>0?(z=$,$=W<=U?(U+z)*.5:W):(U=$,$=W>=z?(U+z)*.5:W)}return S($,U,z)},solveQuadratic:function(O,R,$,U,z,j){var F,V=Infinity;if(h(O)<k){if(h(R)<k)return h($)<k?-1:0;F=-$/R}else{R*=-.5;var T=I(O,R,$);if(T&&h(T)<w){var M=D(h(O),h(R),h($));M&&(O*=M,R*=M,$*=M,T=I(O,R,$))}if(T>=-w){var W=T<0?0:g(T),q=R+(R<0?-W:W);q===0?(F=$/O,V=-F):(F=q/O,V=$/q)}}var G=0,J=z==null,nt=z-k,ot=j+k;return isFinite(F)&&(J||F>nt&&F<ot)&&(U[G++]=J?F:S(F,z,j)),V!==F&&isFinite(V)&&(J||V>nt&&V<ot)&&(U[G++]=J?V:S(V,z,j)),G},solveCubic:function(O,R,$,U,z,j,F){var V=D(h(O),h(R),h($),h(U)),T,M,W,q,G;V&&(O*=V,R*=V,$*=V,U*=V);function J(kt){T=kt;var Rt=O*T;M=Rt+R,W=M*T+$,q=(Rt+M)*T+W,G=W*T+U}if(h(O)<k)O=R,M=$,W=U,T=Infinity;else if(h(U)<k)M=R,W=$,T=0;else{J(-(R/O)/3);var nt=G/O,ot=x(h(nt),1/3),at=nt<0?-1:1,lt=-q/O,pt=lt>0?1.324717957244746*Math.max(ot,g(lt)):ot,ut=T-at*pt;if(ut!==T){do J(ut),ut=q===0?T:T-G/q/(1+w);while(at*ut>at*T);h(O)*T*T>h(U/T)&&(W=-U/T,M=(W-$)/T)}}var gt=f.solveQuadratic(O,M,W,z,j,F),bt=j==null;return isFinite(T)&&(gt===0||gt>0&&T!==z[0]&&T!==z[1])&&(bt||T>j-k&&T<F+k)&&(z[gt++]=bt?T:S(T,j,F)),gt}}},m={_id:1,_pools:{},get:function(i){if(i){var c=this._pools[i];return c||(c=this._pools[i]={_id:1}),c._id++}else return this._id++}},d=s.extend({_class:"Point",_readIndex:!0,initialize:function(c,h){var g=typeof c,x=this.__read,b=0;if(g==="number"){var k=typeof h=="number";this._set(c,k?h:c),x&&(b=k?2:1)}else if(g==="undefined"||c===null)this._set(0,0),x&&(b=c===null?1:0);else{var w=g==="string"?c.split(/[\s,]+/)||[]:c;b=1,Array.isArray(w)?this._set(+w[0],+(w.length>1?w[1]:w[0])):"x"in w?this._set(w.x||0,w.y||0):"width"in w?this._set(w.width||0,w.height||0):"angle"in w?(this._set(w.length||0,0),this.setAngle(w.angle||0)):(this._set(0,0),b=0)}return x&&(this.__read=b),this},set:"#initialize",_set:function(i,c){return this.x=i,this.y=c,this},equals:function(i){return this===i||i&&(this.x===i.x&&this.y===i.y||Array.isArray(i)&&this.x===i[0]&&this.y===i[1])||!1},clone:function(){return new d(this.x,this.y)},toString:function(){var i=p.instance;return"{ x: "+i.number(this.x)+", y: "+i.number(this.y)+" }"},_serialize:function(i){var c=i.formatter;return[c.number(this.x),c.number(this.y)]},getLength:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},setLength:function(i){if(this.isZero()){var c=this._angle||0;this._set(Math.cos(c)*i,Math.sin(c)*i)}else{var h=i/this.getLength();f.isZero(h)&&this.getAngle(),this._set(this.x*h,this.y*h)}},getAngle:function(){return this.getAngleInRadians.apply(this,arguments)*180/Math.PI},setAngle:function(i){this.setAngleInRadians.call(this,i*Math.PI/180)},getAngleInDegrees:"#getAngle",setAngleInDegrees:"#setAngle",getAngleInRadians:function(){if(arguments.length){var i=d.read(arguments),c=this.getLength()*i.getLength();if(f.isZero(c))return NaN;var h=this.dot(i)/c;return Math.acos(h<-1?-1:h>1?1:h)}else return this.isZero()?this._angle||0:this._angle=Math.atan2(this.y,this.x)},setAngleInRadians:function(i){if(this._angle=i,!this.isZero()){var c=this.getLength();this._set(Math.cos(i)*c,Math.sin(i)*c)}},getQuadrant:function(){return this.x>=0?this.y>=0?1:4:this.y>=0?2:3}},{beans:!1,getDirectedAngle:function(){var i=d.read(arguments);return Math.atan2(this.cross(i),this.dot(i))*180/Math.PI},getDistance:function(){var i=arguments,c=d.read(i),h=c.x-this.x,g=c.y-this.y,x=h*h+g*g,b=s.read(i);return b?x:Math.sqrt(x)},normalize:function(i){i===t&&(i=1);var c=this.getLength(),h=c!==0?i/c:0,g=new d(this.x*h,this.y*h);return h>=0&&(g._angle=this._angle),g},rotate:function(i,c){if(i===0)return this.clone();i=i*Math.PI/180;var h=c?this.subtract(c):this,g=Math.sin(i),x=Math.cos(i);return h=new d(h.x*x-h.y*g,h.x*g+h.y*x),c?h.add(c):h},transform:function(i){return i?i._transformPoint(this):this},add:function(){var i=d.read(arguments);return new d(this.x+i.x,this.y+i.y)},subtract:function(){var i=d.read(arguments);return new d(this.x-i.x,this.y-i.y)},multiply:function(){var i=d.read(arguments);return new d(this.x*i.x,this.y*i.y)},divide:function(){var i=d.read(arguments);return new d(this.x/i.x,this.y/i.y)},modulo:function(){var i=d.read(arguments);return new d(this.x%i.x,this.y%i.y)},negate:function(){return new d(-this.x,-this.y)},isInside:function(){return C.read(arguments).contains(this)},isClose:function(){var i=arguments,c=d.read(i),h=s.read(i);return this.getDistance(c)<=h},isCollinear:function(){var i=d.read(arguments);return d.isCollinear(this.x,this.y,i.x,i.y)},isColinear:"#isCollinear",isOrthogonal:function(){var i=d.read(arguments);return d.isOrthogonal(this.x,this.y,i.x,i.y)},isZero:function(){var i=f.isZero;return i(this.x)&&i(this.y)},isNaN:function(){return isNaN(this.x)||isNaN(this.y)},isInQuadrant:function(i){return this.x*(i>1&&i<4?-1:1)>=0&&this.y*(i>2?-1:1)>=0},dot:function(){var i=d.read(arguments);return this.x*i.x+this.y*i.y},cross:function(){var i=d.read(arguments);return this.x*i.y-this.y*i.x},project:function(){var i=d.read(arguments),c=i.isZero()?0:this.dot(i)/i.dot(i);return new d(i.x*c,i.y*c)},statics:{min:function(){var i=arguments,c=d.read(i),h=d.read(i);return new d(Math.min(c.x,h.x),Math.min(c.y,h.y))},max:function(){var i=arguments,c=d.read(i),h=d.read(i);return new d(Math.max(c.x,h.x),Math.max(c.y,h.y))},random:function(){return new d(Math.random(),Math.random())},isCollinear:function(i,c,h,g){return Math.abs(i*g-c*h)<=Math.sqrt((i*i+c*c)*(h*h+g*g))*1e-8},isOrthogonal:function(i,c,h,g){return Math.abs(i*h+c*g)<=Math.sqrt((i*i+c*c)*(h*h+g*g))*1e-8}}},s.each(["round","ceil","floor","abs"],function(i){var c=Math[i];this[i]=function(){return new d(c(this.x),c(this.y))}},{})),y=d.extend({initialize:function(c,h,g,x){this._x=c,this._y=h,this._owner=g,this._setter=x},_set:function(i,c,h){return this._x=i,this._y=c,h||this._owner[this._setter](this),this},getX:function(){return this._x},setX:function(i){this._x=i,this._owner[this._setter](this)},getY:function(){return this._y},setY:function(i){this._y=i,this._owner[this._setter](this)},isSelected:function(){return!!(this._owner._selection&this._getSelection())},setSelected:function(i){this._owner._changeSelection(this._getSelection(),i)},_getSelection:function(){return this._setter==="setPosition"?4:0}}),_=s.extend({_class:"Size",_readIndex:!0,initialize:function(c,h){var g=typeof c,x=this.__read,b=0;if(g==="number"){var k=typeof h=="number";this._set(c,k?h:c),x&&(b=k?2:1)}else if(g==="undefined"||c===null)this._set(0,0),x&&(b=c===null?1:0);else{var w=g==="string"?c.split(/[\s,]+/)||[]:c;b=1,Array.isArray(w)?this._set(+w[0],+(w.length>1?w[1]:w[0])):"width"in w?this._set(w.width||0,w.height||0):"x"in w?this._set(w.x||0,w.y||0):(this._set(0,0),b=0)}return x&&(this.__read=b),this},set:"#initialize",_set:function(i,c){return this.width=i,this.height=c,this},equals:function(i){return i===this||i&&(this.width===i.width&&this.height===i.height||Array.isArray(i)&&this.width===i[0]&&this.height===i[1])||!1},clone:function(){return new _(this.width,this.height)},toString:function(){var i=p.instance;return"{ width: "+i.number(this.width)+", height: "+i.number(this.height)+" }"},_serialize:function(i){var c=i.formatter;return[c.number(this.width),c.number(this.height)]},add:function(){var i=_.read(arguments);return new _(this.width+i.width,this.height+i.height)},subtract:function(){var i=_.read(arguments);return new _(this.width-i.width,this.height-i.height)},multiply:function(){var i=_.read(arguments);return new _(this.width*i.width,this.height*i.height)},divide:function(){var i=_.read(arguments);return new _(this.width/i.width,this.height/i.height)},modulo:function(){var i=_.read(arguments);return new _(this.width%i.width,this.height%i.height)},negate:function(){return new _(-this.width,-this.height)},isZero:function(){var i=f.isZero;return i(this.width)&&i(this.height)},isNaN:function(){return isNaN(this.width)||isNaN(this.height)},statics:{min:function(i,c){return new _(Math.min(i.width,c.width),Math.min(i.height,c.height))},max:function(i,c){return new _(Math.max(i.width,c.width),Math.max(i.height,c.height))},random:function(){return new _(Math.random(),Math.random())}}},s.each(["round","ceil","floor","abs"],function(i){var c=Math[i];this[i]=function(){return new _(c(this.width),c(this.height))}},{})),v=_.extend({initialize:function(c,h,g,x){this._width=c,this._height=h,this._owner=g,this._setter=x},_set:function(i,c,h){return this._width=i,this._height=c,h||this._owner[this._setter](this),this},getWidth:function(){return this._width},setWidth:function(i){this._width=i,this._owner[this._setter](this)},getHeight:function(){return this._height},setHeight:function(i){this._height=i,this._owner[this._setter](this)}}),C=s.extend({_class:"Rectangle",_readIndex:!0,beans:!0,initialize:function(c,h,g,x){var b=arguments,k=typeof c,w;if(k==="number"?(this._set(c,h,g,x),w=4):k==="undefined"||c===null?(this._set(0,0,0,0),w=c===null?1:0):b.length===1&&(Array.isArray(c)?(this._set.apply(this,c),w=1):c.x!==t||c.width!==t?(this._set(c.x||0,c.y||0,c.width||0,c.height||0),w=1):c.from===t&&c.to===t&&(this._set(0,0,0,0),s.readSupported(b,this)&&(w=1))),w===t){var S=d.readNamed(b,"from"),I=s.peek(b),D=S.x,O=S.y,R,$;if(I&&I.x!==t||s.hasNamed(b,"to")){var U=d.readNamed(b,"to");R=U.x-D,$=U.y-O,R<0&&(D=U.x,R=-R),$<0&&(O=U.y,$=-$)}else{var z=_.read(b);R=z.width,$=z.height}this._set(D,O,R,$),w=b.__index}var j=b.__filtered;return j&&(this.__filtered=j),this.__read&&(this.__read=w),this},set:"#initialize",_set:function(i,c,h,g){return this.x=i,this.y=c,this.width=h,this.height=g,this},clone:function(){return new C(this.x,this.y,this.width,this.height)},equals:function(i){var c=s.isPlainValue(i)?C.read(arguments):i;return c===this||c&&this.x===c.x&&this.y===c.y&&this.width===c.width&&this.height===c.height||!1},toString:function(){var i=p.instance;return"{ x: "+i.number(this.x)+", y: "+i.number(this.y)+", width: "+i.number(this.width)+", height: "+i.number(this.height)+" }"},_serialize:function(i){var c=i.formatter;return[c.number(this.x),c.number(this.y),c.number(this.width),c.number(this.height)]},getPoint:function(i){var c=i?d:y;return new c(this.x,this.y,this,"setPoint")},setPoint:function(){var i=d.read(arguments);this.x=i.x,this.y=i.y},getSize:function(i){var c=i?_:v;return new c(this.width,this.height,this,"setSize")},_fw:1,_fh:1,setSize:function(){var i=_.read(arguments),c=this._sx,h=this._sy,g=i.width,x=i.height;c&&(this.x+=(this.width-g)*c),h&&(this.y+=(this.height-x)*h),this.width=g,this.height=x,this._fw=this._fh=1},getLeft:function(){return this.x},setLeft:function(i){if(!this._fw){var c=i-this.x;this.width-=this._sx===.5?c*2:c}this.x=i,this._sx=this._fw=0},getTop:function(){return this.y},setTop:function(i){if(!this._fh){var c=i-this.y;this.height-=this._sy===.5?c*2:c}this.y=i,this._sy=this._fh=0},getRight:function(){return this.x+this.width},setRight:function(i){if(!this._fw){var c=i-this.x;this.width=this._sx===.5?c*2:c}this.x=i-this.width,this._sx=1,this._fw=0},getBottom:function(){return this.y+this.height},setBottom:function(i){if(!this._fh){var c=i-this.y;this.height=this._sy===.5?c*2:c}this.y=i-this.height,this._sy=1,this._fh=0},getCenterX:function(){return this.x+this.width/2},setCenterX:function(i){this._fw||this._sx===.5?this.x=i-this.width/2:(this._sx&&(this.x+=(i-this.x)*2*this._sx),this.width=(i-this.x)*2),this._sx=.5,this._fw=0},getCenterY:function(){return this.y+this.height/2},setCenterY:function(i){this._fh||this._sy===.5?this.y=i-this.height/2:(this._sy&&(this.y+=(i-this.y)*2*this._sy),this.height=(i-this.y)*2),this._sy=.5,this._fh=0},getCenter:function(i){var c=i?d:y;return new c(this.getCenterX(),this.getCenterY(),this,"setCenter")},setCenter:function(){var i=d.read(arguments);return this.setCenterX(i.x),this.setCenterY(i.y),this},getArea:function(){return this.width*this.height},isEmpty:function(){return this.width===0||this.height===0},contains:function(i){return i&&i.width!==t||(Array.isArray(i)?i:arguments).length===4?this._containsRectangle(C.read(arguments)):this._containsPoint(d.read(arguments))},_containsPoint:function(i){var c=i.x,h=i.y;return c>=this.x&&h>=this.y&&c<=this.x+this.width&&h<=this.y+this.height},_containsRectangle:function(i){var c=i.x,h=i.y;return c>=this.x&&h>=this.y&&c+i.width<=this.x+this.width&&h+i.height<=this.y+this.height},intersects:function(){var i=C.read(arguments),c=s.read(arguments)||0;return i.x+i.width>this.x-c&&i.y+i.height>this.y-c&&i.x<this.x+this.width+c&&i.y<this.y+this.height+c},intersect:function(){var i=C.read(arguments),c=Math.max(this.x,i.x),h=Math.max(this.y,i.y),g=Math.min(this.x+this.width,i.x+i.width),x=Math.min(this.y+this.height,i.y+i.height);return new C(c,h,g-c,x-h)},unite:function(){var i=C.read(arguments),c=Math.min(this.x,i.x),h=Math.min(this.y,i.y),g=Math.max(this.x+this.width,i.x+i.width),x=Math.max(this.y+this.height,i.y+i.height);return new C(c,h,g-c,x-h)},include:function(){var i=d.read(arguments),c=Math.min(this.x,i.x),h=Math.min(this.y,i.y),g=Math.max(this.x+this.width,i.x),x=Math.max(this.y+this.height,i.y);return new C(c,h,g-c,x-h)},expand:function(){var i=_.read(arguments),c=i.width,h=i.height;return new C(this.x-c/2,this.y-h/2,this.width+c,this.height+h)},scale:function(i,c){return this.expand(this.width*i-this.width,this.height*(c===t?i:c)-this.height)}},s.each([["Top","Left"],["Top","Right"],["Bottom","Left"],["Bottom","Right"],["Left","Center"],["Top","Center"],["Right","Center"],["Bottom","Center"]],function(i,c){var h=i.join(""),g=/^[RL]/.test(h);c>=4&&(i[1]+=g?"Y":"X");var x=i[g?0:1],b=i[g?1:0],k="get"+x,w="get"+b,S="set"+x,I="set"+b,D="get"+h,O="set"+h;this[D]=function(R){var $=R?d:y;return new $(this[k](),this[w](),this,O)},this[O]=function(){var R=d.read(arguments);this[S](R.x),this[I](R.y)}},{beans:!0})),N=C.extend({initialize:function(c,h,g,x,b,k){this._set(c,h,g,x,!0),this._owner=b,this._setter=k},_set:function(i,c,h,g,x){return this._x=i,this._y=c,this._width=h,this._height=g,x||this._owner[this._setter](this),this}},new function(){var i=C.prototype;return s.each(["x","y","width","height"],function(c){var h=s.capitalize(c),g="_"+c;this["get"+h]=function(){return this[g]},this["set"+h]=function(x){this[g]=x,this._dontNotify||this._owner[this._setter](this)}},s.each(["Point","Size","Center","Left","Top","Right","Bottom","CenterX","CenterY","TopLeft","TopRight","BottomLeft","BottomRight","LeftCenter","TopCenter","RightCenter","BottomCenter"],function(c){var h="set"+c;this[h]=function(){this._dontNotify=!0,i[h].apply(this,arguments),this._dontNotify=!1,this._owner[this._setter](this)}},{isSelected:function(){return!!(this._owner._selection&2)},setSelected:function(c){var h=this._owner;h._changeSelection&&h._changeSelection(2,c)}}))}),A=s.extend({_class:"Matrix",initialize:function i(c,h){var g=arguments,x=g.length,b=!0;if(x>=6?this._set.apply(this,g):x===1||x===2?c instanceof i?this._set(c._a,c._b,c._c,c._d,c._tx,c._ty,h):Array.isArray(c)?this._set.apply(this,h?c.concat([h]):c):b=!1:x?b=!1:this.reset(),!b)throw new Error("Unsupported matrix parameters");return this},set:"#initialize",_set:function(i,c,h,g,x,b,k){return this._a=i,this._b=c,this._c=h,this._d=g,this._tx=x,this._ty=b,k||this._changed(),this},_serialize:function(i,c){return s.serialize(this.getValues(),i,!0,c)},_changed:function(){var i=this._owner;i&&(i._applyMatrix?i.transform(null,!0):i._changed(25))},clone:function(){return new A(this._a,this._b,this._c,this._d,this._tx,this._ty)},equals:function(i){return i===this||i&&this._a===i._a&&this._b===i._b&&this._c===i._c&&this._d===i._d&&this._tx===i._tx&&this._ty===i._ty},toString:function(){var i=p.instance;return"[["+[i.number(this._a),i.number(this._c),i.number(this._tx)].join(", ")+"], ["+[i.number(this._b),i.number(this._d),i.number(this._ty)].join(", ")+"]]"},reset:function(i){return this._a=this._d=1,this._b=this._c=this._tx=this._ty=0,i||this._changed(),this},apply:function(i,c){var h=this._owner;return h?(h.transform(null,s.pick(i,!0),c),this.isIdentity()):!1},translate:function(){var i=d.read(arguments),c=i.x,h=i.y;return this._tx+=c*this._a+h*this._c,this._ty+=c*this._b+h*this._d,this._changed(),this},scale:function(){var i=arguments,c=d.read(i),h=d.read(i,0,{readNull:!0});return h&&this.translate(h),this._a*=c.x,this._b*=c.x,this._c*=c.y,this._d*=c.y,h&&this.translate(h.negate()),this._changed(),this},rotate:function(i){i*=Math.PI/180;var c=d.read(arguments,1),h=c.x,g=c.y,x=Math.cos(i),b=Math.sin(i),k=h-h*x+g*b,w=g-h*b-g*x,S=this._a,I=this._b,D=this._c,O=this._d;return this._a=x*S+b*D,this._b=x*I+b*O,this._c=-b*S+x*D,this._d=-b*I+x*O,this._tx+=k*S+w*D,this._ty+=k*I+w*O,this._changed(),this},shear:function(){var i=arguments,c=d.read(i),h=d.read(i,0,{readNull:!0});h&&this.translate(h);var g=this._a,x=this._b;return this._a+=c.y*this._c,this._b+=c.y*this._d,this._c+=c.x*g,this._d+=c.x*x,h&&this.translate(h.negate()),this._changed(),this},skew:function(){var i=arguments,c=d.read(i),h=d.read(i,0,{readNull:!0}),g=Math.PI/180,x=new d(Math.tan(c.x*g),Math.tan(c.y*g));return this.shear(x,h)},append:function(i,c){if(i){var h=this._a,g=this._b,x=this._c,b=this._d,k=i._a,w=i._c,S=i._b,I=i._d,D=i._tx,O=i._ty;this._a=k*h+S*x,this._c=w*h+I*x,this._b=k*g+S*b,this._d=w*g+I*b,this._tx+=D*h+O*x,this._ty+=D*g+O*b,c||this._changed()}return this},prepend:function(i,c){if(i){var h=this._a,g=this._b,x=this._c,b=this._d,k=this._tx,w=this._ty,S=i._a,I=i._c,D=i._b,O=i._d,R=i._tx,$=i._ty;this._a=S*h+I*g,this._c=S*x+I*b,this._b=D*h+O*g,this._d=D*x+O*b,this._tx=S*k+I*w+R,this._ty=D*k+O*w+$,c||this._changed()}return this},appended:function(i){return this.clone().append(i)},prepended:function(i){return this.clone().prepend(i)},invert:function(){var i=this._a,c=this._b,h=this._c,g=this._d,x=this._tx,b=this._ty,k=i*g-c*h,w=null;return k&&!isNaN(k)&&isFinite(x)&&isFinite(b)&&(this._a=g/k,this._b=-c/k,this._c=-h/k,this._d=i/k,this._tx=(h*b-g*x)/k,this._ty=(c*x-i*b)/k,w=this),w},inverted:function(){return this.clone().invert()},concatenate:"#append",preConcatenate:"#prepend",chain:"#appended",_shiftless:function(){return new A(this._a,this._b,this._c,this._d,0,0)},_orNullIfIdentity:function(){return this.isIdentity()?null:this},isIdentity:function(){return this._a===1&&this._b===0&&this._c===0&&this._d===1&&this._tx===0&&this._ty===0},isInvertible:function(){var i=this._a*this._d-this._c*this._b;return i&&!isNaN(i)&&isFinite(this._tx)&&isFinite(this._ty)},isSingular:function(){return!this.isInvertible()},transform:function(i,c,h){return arguments.length<3?this._transformPoint(d.read(arguments)):this._transformCoordinates(i,c,h)},_transformPoint:function(i,c,h){var g=i.x,x=i.y;return c||(c=new d),c._set(g*this._a+x*this._c+this._tx,g*this._b+x*this._d+this._ty,h)},_transformCoordinates:function(i,c,h){for(var g=0,x=2*h;g<x;g+=2){var b=i[g],k=i[g+1];c[g]=b*this._a+k*this._c+this._tx,c[g+1]=b*this._b+k*this._d+this._ty}return c},_transformCorners:function(i){var c=i.x,h=i.y,g=c+i.width,x=h+i.height,b=[c,h,g,h,g,x,c,x];return this._transformCoordinates(b,b,4)},_transformBounds:function(i,c,h){for(var g=this._transformCorners(i),x=g.slice(0,2),b=x.slice(),k=2;k<8;k++){var w=g[k],S=k&1;w<x[S]?x[S]=w:w>b[S]&&(b[S]=w)}return c||(c=new C),c._set(x[0],x[1],b[0]-x[0],b[1]-x[1],h)},inverseTransform:function(){return this._inverseTransform(d.read(arguments))},_inverseTransform:function(i,c,h){var g=this._a,x=this._b,b=this._c,k=this._d,w=this._tx,S=this._ty,I=g*k-x*b,D=null;if(I&&!isNaN(I)&&isFinite(w)&&isFinite(S)){var O=i.x-this._tx,R=i.y-this._ty;c||(c=new d),D=c._set((O*k-R*b)/I,(R*g-O*x)/I,h)}return D},decompose:function(){var i=this._a,c=this._b,h=this._c,g=this._d,x=i*g-c*h,b=Math.sqrt,k=Math.atan2,w=180/Math.PI,S,I,D;if(i!==0||c!==0){var O=b(i*i+c*c);S=Math.acos(i/O)*(c>0?1:-1),I=[O,x/O],D=[k(i*h+c*g,O*O),0]}else if(h!==0||g!==0){var R=b(h*h+g*g);S=Math.asin(h/R)*(g>0?1:-1),I=[x/R,R],D=[0,k(i*h+c*g,R*R)]}else S=0,D=I=[0,0];return{translation:this.getTranslation(),rotation:S*w,scaling:new d(I),skewing:new d(D[0]*w,D[1]*w)}},getValues:function(){return[this._a,this._b,this._c,this._d,this._tx,this._ty]},getTranslation:function(){return new d(this._tx,this._ty)},getScaling:function(){return this.decompose().scaling},getRotation:function(){return this.decompose().rotation},applyToContext:function(i){this.isIdentity()||i.transform(this._a,this._b,this._c,this._d,this._tx,this._ty)}},s.each(["a","b","c","d","tx","ty"],function(i){var c=s.capitalize(i),h="_"+i;this["get"+c]=function(){return this[h]},this["set"+c]=function(g){this[h]=g,this._changed()}},{})),B=s.extend({_class:"Line",initialize:function(c,h,g,x,b){var k=!1;arguments.length>=4?(this._px=c,this._py=h,this._vx=g,this._vy=x,k=b):(this._px=c.x,this._py=c.y,this._vx=h.x,this._vy=h.y,k=g),k||(this._vx-=this._px,this._vy-=this._py)},getPoint:function(){return new d(this._px,this._py)},getVector:function(){return new d(this._vx,this._vy)},getLength:function(){return this.getVector().getLength()},intersect:function(i,c){return B.intersect(this._px,this._py,this._vx,this._vy,i._px,i._py,i._vx,i._vy,!0,c)},getSide:function(i,c){return B.getSide(this._px,this._py,this._vx,this._vy,i.x,i.y,!0,c)},getDistance:function(i){return Math.abs(this.getSignedDistance(i))},getSignedDistance:function(i){return B.getSignedDistance(this._px,this._py,this._vx,this._vy,i.x,i.y,!0)},isCollinear:function(i){return d.isCollinear(this._vx,this._vy,i._vx,i._vy)},isOrthogonal:function(i){return d.isOrthogonal(this._vx,this._vy,i._vx,i._vy)},statics:{intersect:function(i,c,h,g,x,b,k,w,S,I){S||(h-=i,g-=c,k-=x,w-=b);var D=h*w-g*k;if(!f.isMachineZero(D)){var O=i-x,R=c-b,$=(k*R-w*O)/D,U=(h*R-g*O)/D,z=1e-12,j=-z,F=1+z;if(I||j<$&&$<F&&j<U&&U<F)return I||($=$<=0?0:$>=1?1:$),new d(i+$*h,c+$*g)}},getSide:function(i,c,h,g,x,b,k,w){k||(h-=i,g-=c);var S=x-i,I=b-c,D=S*g-I*h;return!w&&f.isMachineZero(D)&&(D=(S*h+S*h)/(h*h+g*g),D>=0&&D<=1&&(D=0)),D<0?-1:D>0?1:0},getSignedDistance:function(i,c,h,g,x,b,k){return k||(h-=i,g-=c),h===0?g>0?x-i:i-x:g===0?h<0?b-c:c-b:((x-i)*g-(b-c)*h)/(g>h?g*Math.sqrt(1+h*h/(g*g)):h*Math.sqrt(1+g*g/(h*h)))},getDistance:function(i,c,h,g,x,b,k){return Math.abs(B.getSignedDistance(i,c,h,g,x,b,k))}}}),P=l.extend({_class:"Project",_list:"projects",_reference:"project",_compactSerialize:!0,initialize:function(c){l.call(this,!0),this._children=[],this._namedChildren={},this._activeLayer=null,this._currentStyle=new ne(null,null,this),this._view=oe.create(this,c||Pe.getCanvas(1,1)),this._selectionItems={},this._selectionCount=0,this._updateVersion=0},_serialize:function(i,c){return s.serialize(this._children,i,!0,c)},_changed:function(i,c){if(i&1){var h=this._view;h&&(h._needsUpdate=!0,!h._requested&&h._autoUpdate&&h.requestUpdate())}var g=this._changes;if(g&&c){var x=this._changesById,b=c._id,k=x[b];k?k.flags|=i:g.push(x[b]={item:c,flags:i})}},clear:function(){for(var i=this._children,c=i.length-1;c>=0;c--)i[c].remove()},isEmpty:function(){return!this._children.length},remove:function i(){return i.base.call(this)?(this._view&&this._view.remove(),!0):!1},getView:function(){return this._view},getCurrentStyle:function(){return this._currentStyle},setCurrentStyle:function(i){this._currentStyle.set(i)},getIndex:function(){return this._index},getOptions:function(){return this._scope.settings},getLayers:function(){return this._children},getActiveLayer:function(){return this._activeLayer||new K({project:this,insert:!0})},getSymbolDefinitions:function(){var i=[],c={};return this.getItems({class:xt,match:function(h){var g=h._definition,x=g._id;return c[x]||(c[x]=!0,i.push(g)),!1}}),i},getSymbols:"getSymbolDefinitions",getSelectedItems:function(){var i=this._selectionItems,c=[];for(var h in i){var g=i[h],x=g._selection;x&1&&g.isInserted()?c.push(g):x||this._updateSelection(g)}return c},_updateSelection:function(i){var c=i._id,h=this._selectionItems;i._selection?h[c]!==i&&(this._selectionCount++,h[c]=i):h[c]===i&&(this._selectionCount--,delete h[c])},selectAll:function(){for(var i=this._children,c=0,h=i.length;c<h;c++)i[c].setFullySelected(!0)},deselectAll:function(){var i=this._selectionItems;for(var c in i)i[c].setFullySelected(!1)},addLayer:function(i){return this.insertLayer(t,i)},insertLayer:function(i,c){if(c instanceof K){c._remove(!1,!0),s.splice(this._children,[c],i,0),c._setProject(this,!0);var h=c._name;h&&c.setName(h),this._changes&&c._changed(5),this._activeLayer||(this._activeLayer=c)}else c=null;return c},_insertItem:function(i,c,h){return c=this.insertLayer(i,c)||(this._activeLayer||this._insertItem(t,new K(L.NO_INSERT),!0)).insertChild(i,c),h&&c.activate&&c.activate(),c},getItems:function(i){return L._getItems(this,i)},getItem:function(i){return L._getItems(this,i,null,null,!0)[0]||null},importJSON:function(i){this.activate();var c=this._activeLayer;return s.importJSON(i,c&&c.isEmpty()&&c)},removeOn:function(i){var c=this._removeSets;if(c){i==="mouseup"&&(c.mousedrag=null);var h=c[i];if(h){for(var g in h){var x=h[g];for(var b in c){var k=c[b];k&&k!=h&&delete k[x._id]}x.remove()}c[i]=null}}},draw:function(i,c,h){this._updateVersion++,i.save(),c.applyToContext(i);for(var g=this._children,x=new s({offset:new d(0,0),pixelRatio:h,viewMatrix:c.isIdentity()?null:c,matrices:[new A],updateMatrix:!0}),b=0,k=g.length;b<k;b++)g[b].draw(i,x);if(i.restore(),this._selectionCount>0){i.save(),i.strokeWidth=1;var w=this._selectionItems,S=this._scope.settings.handleSize,I=this._updateVersion;for(var D in w)w[D]._drawSelection(i,c,S,w,I);i.restore()}}}),L=s.extend(o,{statics:{extend:function i(c){return c._serializeFields&&(c._serializeFields=s.set({},this.prototype._serializeFields,c._serializeFields)),i.base.apply(this,arguments)},NO_INSERT:{insert:!1}},_class:"Item",_name:null,_applyMatrix:!0,_canApplyMatrix:!0,_canScaleStroke:!1,_pivot:null,_visible:!0,_blendMode:"normal",_opacity:1,_locked:!1,_guide:!1,_clipMask:!1,_selection:0,_selectBounds:!0,_selectChildren:!1,_serializeFields:{name:null,applyMatrix:null,matrix:new A,pivot:null,visible:!0,blendMode:"normal",opacity:1,locked:!1,guide:!1,clipMask:!1,selected:!1,data:{}},_prioritize:["applyMatrix"]},new function(){var i=["onMouseDown","onMouseUp","onMouseDrag","onClick","onDoubleClick","onMouseMove","onMouseEnter","onMouseLeave"];return s.each(i,function(c){this._events[c]={install:function(h){this.getView()._countItemEvent(h,1)},uninstall:function(h){this.getView()._countItemEvent(h,-1)}}},{_events:{onFrame:{install:function(){this.getView()._animateItem(this,!0)},uninstall:function(){this.getView()._animateItem(this,!1)}},onLoad:{},onError:{}},statics:{_itemHandlers:i}})},{initialize:function(){},_initialize:function(i,c){var h=i&&s.isPlainObject(i),g=h&&i.internal===!0,x=this._matrix=new A,b=h&&i.project||ye.project,k=ye.settings;return this._id=g?null:m.get(),this._parent=this._index=null,this._applyMatrix=this._canApplyMatrix&&k.applyMatrix,c&&x.translate(c),x._owner=this,this._style=new ne(b._currentStyle,this,b),g||h&&i.insert==!1||!k.insertItems&&!(h&&i.insert===!0)?this._setProject(b):(h&&i.parent||b)._insertItem(t,this,!0),h&&i!==L.NO_INSERT&&this.set(i,{internal:!0,insert:!0,project:!0,parent:!0}),h},_serialize:function(i,c){var h={},g=this;function x(b){for(var k in b){var w=g[k];s.equals(w,k==="leading"?b.fontSize*1.2:b[k])||(h[k]=s.serialize(w,i,k!=="data",c))}}return x(this._serializeFields),this instanceof Z||x(this._style._defaults),[this._class,h]},_changed:function(i){var c=this._symbol,h=this._parent||c,g=this._project;i&8&&(this._bounds=this._position=this._decomposed=t),i&16&&(this._globalMatrix=t),h&&i&72&&L._clearBoundsCache(h),i&2&&L._clearBoundsCache(this),g&&g._changed(i,this),c&&c._changed(i)},getId:function(){return this._id},getName:function(){return this._name},setName:function(i){if(this._name&&this._removeNamed(),i===+i+"")throw new Error("Names consisting only of numbers are not supported.");var c=this._getOwner();if(i&&c){var h=c._children,g=c._namedChildren;(g[i]=g[i]||[]).push(this),i in h||(h[i]=this)}this._name=i||t,this._changed(256)},getStyle:function(){return this._style},setStyle:function(i){this.getStyle().set(i)}},s.each(["locked","visible","blendMode","opacity","guide"],function(i){var c=s.capitalize(i),h="_"+i,g={locked:256,visible:265};this["get"+c]=function(){return this[h]},this["set"+c]=function(x){x!=this[h]&&(this[h]=x,this._changed(g[i]||257))}},{}),{beans:!0,getSelection:function(){return this._selection},setSelection:function(i){if(i!==this._selection){this._selection=i;var c=this._project;c&&(c._updateSelection(this),this._changed(257))}},_changeSelection:function(i,c){var h=this._selection;this.setSelection(c?h|i:h&~i)},isSelected:function(){if(this._selectChildren){for(var i=this._children,c=0,h=i.length;c<h;c++)if(i[c].isSelected())return!0}return!!(this._selection&1)},setSelected:function(i){if(this._selectChildren)for(var c=this._children,h=0,g=c.length;h<g;h++)c[h].setSelected(i);this._changeSelection(1,i)},isFullySelected:function(){var i=this._children,c=!!(this._selection&1);if(i&&c){for(var h=0,g=i.length;h<g;h++)if(!i[h].isFullySelected())return!1;return!0}return c},setFullySelected:function(i){var c=this._children;if(c)for(var h=0,g=c.length;h<g;h++)c[h].setFullySelected(i);this._changeSelection(1,i)},isClipMask:function(){return this._clipMask},setClipMask:function(i){this._clipMask!=(i=!!i)&&(this._clipMask=i,i&&(this.setFillColor(null),this.setStrokeColor(null)),this._changed(257),this._parent&&this._parent._changed(2048))},getData:function(){return this._data||(this._data={}),this._data},setData:function(i){this._data=i},getPosition:function(i){var c=i?d:y,h=this._position||(this._position=this._getPositionFromBounds());return new c(h.x,h.y,this,"setPosition")},setPosition:function(){this.translate(d.read(arguments).subtract(this.getPosition(!0)))},_getPositionFromBounds:function(i){return this._pivot?this._matrix._transformPoint(this._pivot):(i||this.getBounds()).getCenter(!0)},getPivot:function(){var i=this._pivot;return i?new y(i.x,i.y,this,"setPivot"):null},setPivot:function(){this._pivot=d.read(arguments,0,{clone:!0,readNull:!0}),this._position=t}},s.each({getStrokeBounds:{stroke:!0},getHandleBounds:{handle:!0},getInternalBounds:{internal:!0}},function(i,c){this[c]=function(h){return this.getBounds(h,i)}},{beans:!0,getBounds:function(i,c){var h=c||i instanceof A,g=s.set({},h?c:i,this._boundsOptions);(!g.stroke||this.getStrokeScaling())&&(g.cacheItem=this);var x=this._getCachedBounds(h&&i,g).rect;return arguments.length?x:new N(x.x,x.y,x.width,x.height,this,"setBounds")},setBounds:function(){var i=C.read(arguments),c=this.getBounds(),h=this._matrix,g=new A,x=i.getCenter();g.translate(x),(i.width!=c.width||i.height!=c.height)&&(h.isInvertible()||(h.set(h._backup||new A().translate(h.getTranslation())),c=this.getBounds()),g.scale(c.width!==0?i.width/c.width:0,c.height!==0?i.height/c.height:0)),x=c.getCenter(),g.translate(-x.x,-x.y),this.transform(g)},_getBounds:function(i,c){var h=this._children;return!h||!h.length?new C:(L._updateBoundsCache(this,c.cacheItem),L._getBounds(h,i,c))},_getBoundsCacheKey:function(i,c){return[i.stroke?1:0,i.handle?1:0,c?1:0].join("")},_getCachedBounds:function(i,c,h){i=i&&i._orNullIfIdentity();var g=c.internal&&!h,x=c.cacheItem,b=g?null:this._matrix._orNullIfIdentity(),k=x&&(!i||i.equals(b))&&this._getBoundsCacheKey(c,g),w=this._bounds;if(L._updateBoundsCache(this._parent||this._symbol,x),k&&w&&k in w){var S=w[k];return{rect:S.rect.clone(),nonscaling:S.nonscaling}}var I=this._getBounds(i||b,c),D=I.rect||I,O=this._style,R=I.nonscaling||O.hasStroke()&&!O.getStrokeScaling();if(k){w||(this._bounds=w={});var S=w[k]={rect:D.clone(),nonscaling:R,internal:g}}return{rect:D,nonscaling:R}},_getStrokeMatrix:function(i,c){var h=this.getStrokeScaling()?null:c&&c.internal?this:this._parent||this._symbol&&this._symbol._item,g=h?h.getViewMatrix().invert():i;return g&&g._shiftless()},statics:{_updateBoundsCache:function(i,c){if(i&&c){var h=c._id,g=i._boundsCache=i._boundsCache||{ids:{},list:[]};g.ids[h]||(g.list.push(c),g.ids[h]=c)}},_clearBoundsCache:function(i){var c=i._boundsCache;if(c){i._bounds=i._position=i._boundsCache=t;for(var h=0,g=c.list,x=g.length;h<x;h++){var b=g[h];b!==i&&(b._bounds=b._position=t,b._boundsCache&&L._clearBoundsCache(b))}}},_getBounds:function(i,c,h){var g=Infinity,x=-g,b=g,k=x,w=!1;h=h||{};for(var S=0,I=i.length;S<I;S++){var D=i[S];if(D._visible&&!D.isEmpty(!0)){var O=D._getCachedBounds(c&&c.appended(D._matrix),h,!0),R=O.rect;g=Math.min(R.x,g),b=Math.min(R.y,b),x=Math.max(R.x+R.width,x),k=Math.max(R.y+R.height,k),O.nonscaling&&(w=!0)}}return{rect:isFinite(g)?new C(g,b,x-g,k-b):new C,nonscaling:w}}}}),{beans:!0,_decompose:function(){return this._applyMatrix?null:this._decomposed||(this._decomposed=this._matrix.decompose())},getRotation:function(){var i=this._decompose();return i?i.rotation:0},setRotation:function(i){var c=this.getRotation();if(c!=null&&i!=null){var h=this._decomposed;this.rotate(i-c),h&&(h.rotation=i,this._decomposed=h)}},getScaling:function(){var i=this._decompose(),c=i&&i.scaling;return new y(c?c.x:1,c?c.y:1,this,"setScaling")},setScaling:function(){var i=this.getScaling(),c=d.read(arguments,0,{clone:!0,readNull:!0});if(i&&c&&!i.equals(c)){var h=this.getRotation(),g=this._decomposed,x=new A,b=f.isZero;if(b(i.x)||b(i.y))x.translate(g.translation),h&&x.rotate(h),x.scale(c.x,c.y),this._matrix.set(x);else{var k=this.getPosition(!0);x.translate(k),h&&x.rotate(h),x.scale(c.x/i.x,c.y/i.y),h&&x.rotate(-h),x.translate(k.negate()),this.transform(x)}g&&(g.scaling=c,this._decomposed=g)}},getMatrix:function(){return this._matrix},setMatrix:function(){var i=this._matrix;i.set.apply(i,arguments)},getGlobalMatrix:function(i){var c=this._globalMatrix;if(c)for(var h=this._parent,g=[];h;){if(!h._globalMatrix){c=null;for(var x=0,b=g.length;x<b;x++)g[x]._globalMatrix=null;break}g.push(h),h=h._parent}if(!c){c=this._globalMatrix=this._matrix.clone();var h=this._parent;h&&c.prepend(h.getGlobalMatrix(!0))}return i?c:c.clone()},getViewMatrix:function(){return this.getGlobalMatrix().prepend(this.getView()._matrix)},getApplyMatrix:function(){return this._applyMatrix},setApplyMatrix:function(i){(this._applyMatrix=this._canApplyMatrix&&!!i)&&this.transform(null,!0)},getTransformContent:"#getApplyMatrix",setTransformContent:"#setApplyMatrix"},{getProject:function(){return this._project},_setProject:function(i,c){if(this._project!==i){this._project&&this._installEvents(!1),this._project=i;for(var h=this._children,g=0,x=h&&h.length;g<x;g++)h[g]._setProject(i);c=!0}c&&this._installEvents(!0)},getView:function(){return this._project._view},_installEvents:function i(c){i.base.call(this,c);for(var h=this._children,g=0,x=h&&h.length;g<x;g++)h[g]._installEvents(c)},getLayer:function(){for(var i=this;i=i._parent;)if(i instanceof K)return i;return null},getParent:function(){return this._parent},setParent:function(i){return i.addChild(this)},_getOwner:"#getParent",getChildren:function(){return this._children},setChildren:function(i){this.removeChildren(),this.addChildren(i)},getFirstChild:function(){return this._children&&this._children[0]||null},getLastChild:function(){return this._children&&this._children[this._children.length-1]||null},getNextSibling:function(){var i=this._getOwner();return i&&i._children[this._index+1]||null},getPreviousSibling:function(){var i=this._getOwner();return i&&i._children[this._index-1]||null},getIndex:function(){return this._index},equals:function(i){return i===this||i&&this._class===i._class&&this._style.equals(i._style)&&this._matrix.equals(i._matrix)&&this._locked===i._locked&&this._visible===i._visible&&this._blendMode===i._blendMode&&this._opacity===i._opacity&&this._clipMask===i._clipMask&&this._guide===i._guide&&this._equals(i)||!1},_equals:function(i){return s.equals(this._children,i._children)},clone:function(i){var c=new this.constructor(L.NO_INSERT),h=this._children,g=s.pick(i?i.insert:t,i===t||i===!0),x=s.pick(i?i.deep:t,!0);h&&c.copyAttributes(this),(!h||x)&&c.copyContent(this),h||c.copyAttributes(this),g&&c.insertAbove(this);var b=this._name,k=this._parent;if(b&&k){for(var h=k._children,w=b,S=1;h[b];)b=w+" "+S++;b!==w&&c.setName(b)}return c},copyContent:function(i){for(var c=i._children,h=0,g=c&&c.length;h<g;h++)this.addChild(c[h].clone(!1),!0)},copyAttributes:function(i,c){this.setStyle(i._style);for(var h=["_locked","_visible","_blendMode","_opacity","_clipMask","_guide"],g=0,x=h.length;g<x;g++){var b=h[g];i.hasOwnProperty(b)&&(this[b]=i[b])}c||this._matrix.set(i._matrix,!0),this.setApplyMatrix(i._applyMatrix),this.setPivot(i._pivot),this.setSelection(i._selection);var k=i._data,w=i._name;this._data=k?s.clone(k):null,w&&this.setName(w)},rasterize:function(i,c){var h=this.getStrokeBounds(),g=(i||this.getView().getResolution())/72,x=h.getTopLeft().floor(),b=h.getBottomRight().ceil(),k=new _(b.subtract(x)),w=new it(L.NO_INSERT);if(!k.isZero()){var S=Pe.getCanvas(k.multiply(g)),I=S.getContext("2d"),D=new A().scale(g).translate(x.negate());I.save(),D.applyToContext(I),this.draw(I,new s({matrices:[D]})),I.restore(),w.setCanvas(S)}return w.transform(new A().translate(x.add(k.divide(2))).scale(1/g)),(c===t||c)&&w.insertAbove(this),w},contains:function(){var i=this._matrix;return i.isInvertible()&&!!this._contains(i._inverseTransform(d.read(arguments)))},_contains:function(i){var c=this._children;if(c){for(var h=c.length-1;h>=0;h--)if(c[h].contains(i))return!0;return!1}return i.isInside(this.getInternalBounds())},isInside:function(){return C.read(arguments).contains(this.getBounds())},_asPathItem:function(){return new Ct.Rectangle({rectangle:this.getInternalBounds(),matrix:this._matrix,insert:!1})},intersects:function(i,c){return i instanceof L?this._asPathItem().getIntersections(i._asPathItem(),null,c,!0).length>0:!1}},new function(){function i(){var g=arguments;return this._hitTest(d.read(g),St.getOptions(g))}function c(){var g=arguments,x=d.read(g),b=St.getOptions(g),k=[];return this._hitTest(x,new s({all:k},b)),k}function h(g,x,b,k){var w=this._children;if(w)for(var S=w.length-1;S>=0;S--){var I=w[S],D=I!==k&&I._hitTest(g,x,b);if(D&&!x.all)return D}return null}return P.inject({hitTest:i,hitTestAll:c,_hitTest:h}),{hitTest:i,hitTestAll:c,_hitTestChildren:h}},{_hitTest:function(i,c,h){if(this._locked||!this._visible||this._guide&&!c.guides||this.isEmpty())return null;var g=this._matrix,x=h?h.appended(g):this.getGlobalMatrix().prepend(this.getView()._matrix),b=Math.max(c.tolerance,1e-12),k=c._tolerancePadding=new _(Ct._getStrokePadding(b,g._shiftless().invert()));if(i=g._inverseTransform(i),!i||!this._children&&!this.getBounds({internal:!0,stroke:!0,handle:!0}).expand(k.multiply(2))._containsPoint(i))return null;var w=!(c.guides&&!this._guide||c.selected&&!this.isSelected()||c.type&&c.type!==s.hyphenate(this._class)||c.class&&!(this instanceof c.class)),S=c.match,I=this,D,O;function R(T){return T&&S&&!S(T)&&(T=null),T&&c.all&&c.all.push(T),T}function $(T,M){var W=M?D["get"+M]():I.getPosition();if(i.subtract(W).divide(k).length<=1)return new St(T,I,{name:M?s.hyphenate(M):T,point:W})}var U=c.position,z=c.center,j=c.bounds;if(w&&this._parent&&(U||z||j)){if((z||j)&&(D=this.getInternalBounds()),O=U&&$("position")||z&&$("center","Center"),!O&&j)for(var F=["TopLeft","TopRight","BottomLeft","BottomRight","LeftCenter","TopCenter","RightCenter","BottomCenter"],V=0;V<8&&!O;V++)O=$("bounds",F[V]);O=R(O)}return O||(O=this._hitTestChildren(i,c,x)||w&&R(this._hitTestSelf(i,c,x,this.getStrokeScaling()?null:x._shiftless().invert()))||null),O&&O.point&&(O.point=g.transform(O.point)),O},_hitTestSelf:function(i,c){if(c.fill&&this.hasFill()&&this._contains(i))return new St("fill",this)},matches:function(i,c){function h(k,w){for(var S in k)if(k.hasOwnProperty(S)){var I=k[S],D=w[S];if(s.isPlainObject(I)&&s.isPlainObject(D)){if(!h(I,D))return!1}else if(!s.equals(I,D))return!1}return!0}var g=typeof i;if(g==="object"){for(var x in i)if(i.hasOwnProperty(x)&&!this.matches(x,i[x]))return!1;return!0}else{if(g==="function")return i(this);if(i==="match")return c(this);var b=/^(empty|editable)$/.test(i)?this["is"+s.capitalize(i)]():i==="type"?s.hyphenate(this._class):this[i];if(i==="class"){if(typeof c=="function")return this instanceof c;b=this._class}if(typeof c=="function")return!!c(b);if(c){if(c.test)return c.test(b);if(s.isPlainObject(c))return h(c,b)}return s.equals(b,c)}},getItems:function(i){return L._getItems(this,i,this._matrix)},getItem:function(i){return L._getItems(this,i,this._matrix,null,!0)[0]||null},statics:{_getItems:function i(c,h,g,x,b){if(!x){var k=typeof h=="object"&&h,w=k&&k.overlapping,S=k&&k.inside,I=w||S,R=I&&C.read([I]);x={items:[],recursive:k&&k.recursive!==!1,inside:!!S,overlapping:!!w,rect:R,path:w&&new Ct.Rectangle({rectangle:R,insert:!1})},k&&(h=s.filter({},h,{recursive:!0,inside:!0,overlapping:!0}))}var D=c._children,O=x.items,R=x.rect;g=R&&(g||new A);for(var $=0,U=D&&D.length;$<U;$++){var z=D[$],j=g&&g.appended(z._matrix),F=!0;if(R){var I=z.getBounds(j);if(!R.intersects(I))continue;R.contains(I)||x.overlapping&&(I.contains(R)||x.path.intersects(z,j))||(F=!1)}if(F&&z.matches(h)&&(O.push(z),b)||(x.recursive!==!1&&i(z,h,j,x,b),b&&O.length>0))break}return O}}},{importJSON:function(i){var c=s.importJSON(i,this);return c!==this?this.addChild(c):c},addChild:function(i){return this.insertChild(t,i)},insertChild:function(i,c){var h=c?this.insertChildren(i,[c]):null;return h&&h[0]},addChildren:function(i){return this.insertChildren(this._children.length,i)},insertChildren:function(i,c){var h=this._children;if(h&&c&&c.length>0){c=s.slice(c);for(var g={},x=c.length-1;x>=0;x--){var b=c[x],k=b&&b._id;!b||g[k]?c.splice(x,1):(b._remove(!1,!0),g[k]=!0)}s.splice(h,c,i,0);for(var w=this._project,S=w._changes,x=0,I=c.length;x<I;x++){var b=c[x],D=b._name;b._parent=this,b._setProject(w,!0),D&&b.setName(D),S&&b._changed(5)}this._changed(11)}else c=null;return c},_insertItem:"#insertChild",_insertAt:function(i,c){var h=i&&i._getOwner(),g=i!==this&&h?this:null;return g&&(g._remove(!1,!0),h._insertItem(i._index+c,g)),g},insertAbove:function(i){return this._insertAt(i,1)},insertBelow:function(i){return this._insertAt(i,0)},sendToBack:function(){var i=this._getOwner();return i?i._insertItem(0,this):null},bringToFront:function(){var i=this._getOwner();return i?i._insertItem(t,this):null},appendTop:"#addChild",appendBottom:function(i){return this.insertChild(0,i)},moveAbove:"#insertAbove",moveBelow:"#insertBelow",addTo:function(i){return i._insertItem(t,this)},copyTo:function(i){return this.clone(!1).addTo(i)},reduce:function(i){var c=this._children;if(c&&c.length===1){var h=c[0].reduce(i);return this._parent?(h.insertAbove(this),this.remove()):h.remove(),h}return this},_removeNamed:function(){var i=this._getOwner();if(i){var c=i._children,h=i._namedChildren,g=this._name,x=h[g],b=x?x.indexOf(this):-1;b!==-1&&(c[g]==this&&delete c[g],x.splice(b,1),x.length?c[g]=x[0]:delete h[g])}},_remove:function(i,c){var h=this._getOwner(),g=this._project,x=this._index;return this._style&&this._style._dispose(),h?(this._name&&this._removeNamed(),x!=null&&(g._activeLayer===this&&(g._activeLayer=this.getNextSibling()||this.getPreviousSibling()),s.splice(h._children,null,x,1)),this._installEvents(!1),i&&g._changes&&this._changed(5),c&&h._changed(11,this),this._parent=null,!0):!1},remove:function(){return this._remove(!0,!0)},replaceWith:function(i){var c=i&&i.insertBelow(this);return c&&this.remove(),c},removeChildren:function(i,c){if(!this._children)return null;i=i||0,c=s.pick(c,this._children.length);for(var h=s.splice(this._children,null,i,c-i),g=h.length-1;g>=0;g--)h[g]._remove(!0,!1);return h.length>0&&this._changed(11),h},clear:"#removeChildren",reverseChildren:function(){if(this._children){this._children.reverse();for(var i=0,c=this._children.length;i<c;i++)this._children[i]._index=i;this._changed(11)}},isEmpty:function(i){var c=this._children,h=c?c.length:0;if(i){for(var g=0;g<h;g++)if(!c[g].isEmpty(i))return!1;return!0}return!h},isEditable:function(){for(var i=this;i;){if(!i._visible||i._locked)return!1;i=i._parent}return!0},hasFill:function(){return this.getStyle().hasFill()},hasStroke:function(){return this.getStyle().hasStroke()},hasShadow:function(){return this.getStyle().hasShadow()},_getOrder:function(i){function c(k){var w=[];do w.unshift(k);while(k=k._parent);return w}for(var h=c(this),g=c(i),x=0,b=Math.min(h.length,g.length);x<b;x++)if(h[x]!=g[x])return h[x]._index<g[x]._index?1:-1;return 0},hasChildren:function(){return this._children&&this._children.length>0},isInserted:function(){return this._parent?this._parent.isInserted():!1},isAbove:function(i){return this._getOrder(i)===-1},isBelow:function(i){return this._getOrder(i)===1},isParent:function(i){return this._parent===i},isChild:function(i){return i&&i._parent===this},isDescendant:function(i){for(var c=this;c=c._parent;)if(c===i)return!0;return!1},isAncestor:function(i){return i?i.isDescendant(this):!1},isSibling:function(i){return this._parent===i._parent},isGroupedWith:function(i){for(var c=this._parent;c;){if(c._parent&&/^(Group|Layer|CompoundPath)$/.test(c._class)&&i.isDescendant(c))return!0;c=c._parent}return!1}},s.each(["rotate","scale","shear","skew"],function(i){var c=i==="rotate";this[i]=function(){var h=arguments,g=(c?s:d).read(h),x=d.read(h,0,{readNull:!0});return this.transform(new A()[i](g,x||this.getPosition(!0)))}},{translate:function(){var i=new A;return this.transform(i.translate.apply(i,arguments))},transform:function(i,c,h){var g=this._matrix,x=i&&!i.isIdentity(),b=h&&this._canApplyMatrix||this._applyMatrix&&(x||!g.isIdentity()||c&&this._children);if(!x&&!b)return this;if(x){!i.isInvertible()&&g.isInvertible()&&(g._backup=g.getValues()),g.prepend(i,!0);var k=this._style,w=k.getFillColor(!0),S=k.getStrokeColor(!0);w&&w.transform(i),S&&S.transform(i)}if(b&&(b=this._transformContent(g,c,h))){var I=this._pivot;I&&g._transformPoint(I,I,!0),g.reset(!0),h&&this._canApplyMatrix&&(this._applyMatrix=!0)}var D=this._bounds,O=this._position;(x||b)&&this._changed(25);var R=x&&D&&i.decompose();if(R&&R.skewing.isZero()&&R.rotation%90==0){for(var $ in D){var U=D[$];if(U.nonscaling)delete D[$];else if(b||!U.internal){var z=U.rect;i._transformBounds(z,z)}}this._bounds=D;var j=D[this._getBoundsCacheKey(this._boundsOptions||{})];j&&(this._position=this._getPositionFromBounds(j.rect))}else x&&O&&this._pivot&&(this._position=i._transformPoint(O,O));return this},_transformContent:function(i,c,h){var g=this._children;if(g){for(var x=0,b=g.length;x<b;x++)g[x].transform(i,c,h);return!0}},globalToLocal:function(){return this.getGlobalMatrix(!0)._inverseTransform(d.read(arguments))},localToGlobal:function(){return this.getGlobalMatrix(!0)._transformPoint(d.read(arguments))},parentToLocal:function(){return this._matrix._inverseTransform(d.read(arguments))},localToParent:function(){return this._matrix._transformPoint(d.read(arguments))},fitBounds:function(i,c){i=C.read(arguments);var h=this.getBounds(),g=h.height/h.width,x=i.height/i.width,b=(c?g>x:g<x)?i.width/h.width:i.height/h.height,k=new C(new d,new _(h.width*b,h.height*b));k.setCenter(i.getCenter()),this.setBounds(k)}}),{_setStyles:function(i,c,h){var g=this._style,x=this._matrix;if(g.hasFill()&&(i.fillStyle=g.getFillColor().toCanvasStyle(i,x)),g.hasStroke()){i.strokeStyle=g.getStrokeColor().toCanvasStyle(i,x),i.lineWidth=g.getStrokeWidth();var b=g.getStrokeJoin(),k=g.getStrokeCap(),w=g.getMiterLimit();if(b&&(i.lineJoin=b),k&&(i.lineCap=k),w&&(i.miterLimit=w),ye.support.nativeDash){var S=g.getDashArray(),I=g.getDashOffset();S&&S.length&&("setLineDash"in i?(i.setLineDash(S),i.lineDashOffset=I):(i.mozDash=S,i.mozDashOffset=I))}}if(g.hasShadow()){var D=c.pixelRatio||1,O=h._shiftless().prepend(new A().scale(D,D)),R=O.transform(new d(g.getShadowBlur(),0)),$=O.transform(this.getShadowOffset());i.shadowColor=g.getShadowColor().toCanvasStyle(i),i.shadowBlur=R.getLength(),i.shadowOffsetX=$.x,i.shadowOffsetY=$.y}},draw:function(i,c,h){var g=this._updateVersion=this._project._updateVersion;if(!(!this._visible||this._opacity===0)){var x=c.matrices,b=c.viewMatrix,k=this._matrix,w=x[x.length-1].appended(k);if(!!w.isInvertible()){b=b?b.appended(w):w,x.push(w),c.updateMatrix&&(this._globalMatrix=w);var S=this._blendMode,I=f.clamp(this._opacity,0,1),D=S==="normal",O=Tn.nativeModes[S],R=D&&I===1||c.dontStart||c.clip||(O||D&&I<1)&&this._canComposite(),$=c.pixelRatio||1,U,z,j;if(!R){var F=this.getStrokeBounds(b);if(!F.width||!F.height){x.pop();return}j=c.offset,z=c.offset=F.getTopLeft().floor(),U=i,i=Pe.getContext(F.getSize().ceil().add(1).multiply($)),$!==1&&i.scale($,$)}i.save();var V=h?h.appended(k):this._canScaleStroke&&!this.getStrokeScaling(!0)&&b,T=!R&&c.clipItem,M=!V||T;if(R?(i.globalAlpha=I,O&&(i.globalCompositeOperation=S)):M&&i.translate(-z.x,-z.y),M&&(R?k:b).applyToContext(i),T&&c.clipItem.draw(i,c.extend({clip:!0})),V){i.setTransform($,0,0,$,0,0);var W=c.offset;W&&i.translate(-W.x,-W.y)}this._draw(i,c,b,V),i.restore(),x.pop(),c.clip&&!c.dontFinish&&i.clip(this.getFillRule()),R||(Tn.process(S,i,U,I,z.subtract(j).multiply($)),Pe.release(i),c.offset=j)}}},_isUpdated:function(i){var c=this._parent;if(c instanceof Dt)return c._isUpdated(i);var h=this._updateVersion===i;return!h&&c&&c._visible&&c._isUpdated(i)&&(this._updateVersion=i,h=!0),h},_drawSelection:function(i,c,h,g,x){var b=this._selection,k=b&1,w=b&2||k&&this._selectBounds,S=b&4;if(this._drawSelected||(k=!1),(k||w||S)&&this._isUpdated(x)){var I,D=this.getSelectedColor(!0)||(I=this.getLayer())&&I.getSelectedColor(!0),O=c.appended(this.getGlobalMatrix(!0)),R=h/2;if(i.strokeStyle=i.fillStyle=D?D.toCanvasStyle(i):"#009dec",k&&this._drawSelected(i,O,g),S){var $=this.getPosition(!0),U=this._parent,z=U?U.localToGlobal($):$,j=z.x,F=z.y;i.beginPath(),i.arc(j,F,R,0,Math.PI*2,!0),i.stroke();for(var V=[[0,-1],[1,0],[0,1],[-1,0]],T=R,M=h+1,W=0;W<4;W++){var q=V[W],G=q[0],J=q[1];i.moveTo(j+G*T,F+J*T),i.lineTo(j+G*M,F+J*M),i.stroke()}}if(w){var nt=O._transformCorners(this.getInternalBounds());i.beginPath();for(var W=0;W<8;W++)i[W?"lineTo":"moveTo"](nt[W],nt[++W]);i.closePath(),i.stroke();for(var W=0;W<8;W++)i.fillRect(nt[W]-R,nt[++W]-R,h,h)}}},_canComposite:function(){return!1}},s.each(["down","drag","up","move"],function(i){this["removeOn"+s.capitalize(i)]=function(){var c={};return c[i]=!0,this.removeOn(c)}},{removeOn:function(i){for(var c in i)if(i[c]){var h="mouse"+c,g=this._project,x=g._removeSets=g._removeSets||{};x[h]=x[h]||{},x[h][this._id]=this}return this}}),{tween:function(i,c,h){h||(h=c,c=i,i=null,h||(h=c,c=null));var g=h&&h.easing,x=h&&h.start,b=h!=null&&(typeof h=="number"?h:h.duration),k=new wr(this,i,c,b,g,x);function w(S){k._handleFrame(S.time*1e3),k.running||this.off("frame",w)}return b&&this.on("frame",w),k},tweenTo:function(i,c){return this.tween(null,i,c)},tweenFrom:function(i,c){return this.tween(i,null,c)}}),Z=L.extend({_class:"Group",_selectBounds:!1,_selectChildren:!0,_serializeFields:{children:[]},initialize:function(c){this._children=[],this._namedChildren={},this._initialize(c)||this.addChildren(Array.isArray(c)?c:arguments)},_changed:function i(c){i.base.call(this,c),c&2050&&(this._clipItem=t)},_getClipItem:function(){var i=this._clipItem;if(i===t){i=null;for(var c=this._children,h=0,g=c.length;h<g;h++)if(c[h]._clipMask){i=c[h];break}this._clipItem=i}return i},isClipped:function(){return!!this._getClipItem()},setClipped:function(i){var c=this.getFirstChild();c&&c.setClipMask(i)},_getBounds:function i(c,h){var g=this._getClipItem();return g?g._getCachedBounds(g._matrix.prepended(c),s.set({},h,{stroke:!1})):i.base.call(this,c,h)},_hitTestChildren:function i(c,h,g){var x=this._getClipItem();return(!x||x.contains(c))&&i.base.call(this,c,h,g,x)},_draw:function(i,c){var h=c.clip,g=!h&&this._getClipItem();c=c.extend({clipItem:g,clip:!1}),h?(i.beginPath(),c.dontStart=c.dontFinish=!0):g&&g.draw(i,c.extend({clip:!0}));for(var x=this._children,b=0,k=x.length;b<k;b++){var w=x[b];w!==g&&w.draw(i,c)}}}),K=Z.extend({_class:"Layer",initialize:function(){Z.apply(this,arguments)},_getOwner:function(){return this._parent||this._index!=null&&this._project},isInserted:function i(){return this._parent?i.base.call(this):this._index!=null},activate:function(){this._project._activeLayer=this},_hitTestSelf:function(){}}),et=L.extend({_class:"Shape",_applyMatrix:!1,_canApplyMatrix:!1,_canScaleStroke:!0,_serializeFields:{type:null,size:null,radius:null},initialize:function(c,h){this._initialize(c,h)},_equals:function(i){return this._type===i._type&&this._size.equals(i._size)&&s.equals(this._radius,i._radius)},copyContent:function(i){this.setType(i._type),this.setSize(i._size),this.setRadius(i._radius)},getType:function(){return this._type},setType:function(i){this._type=i},getShape:"#getType",setShape:"#setType",getSize:function(){var i=this._size;return new v(i.width,i.height,this,"setSize")},setSize:function(){var i=_.read(arguments);if(!this._size)this._size=i.clone();else if(!this._size.equals(i)){var c=this._type,h=i.width,g=i.height;c==="rectangle"?this._radius.set(_.min(this._radius,i.divide(2).abs())):c==="circle"?(h=g=(h+g)/2,this._radius=h/2):c==="ellipse"&&this._radius._set(h/2,g/2),this._size._set(h,g),this._changed(9)}},getRadius:function(){var i=this._radius;return this._type==="circle"?i:new v(i.width,i.height,this,"setRadius")},setRadius:function(i){var c=this._type;if(c==="circle"){if(i===this._radius)return;var h=i*2;this._radius=i,this._size._set(h,h)}else if(i=_.read(arguments),!this._radius)this._radius=i.clone();else{if(this._radius.equals(i))return;if(this._radius.set(i),c==="rectangle"){var h=_.max(this._size,i.multiply(2));this._size.set(h)}else c==="ellipse"&&this._size._set(i.width*2,i.height*2)}this._changed(9)},isEmpty:function(){return!1},toPath:function(i){var c=new Ct[s.capitalize(this._type)]({center:new d,size:this._size,radius:this._radius,insert:!1});return c.copyAttributes(this),ye.settings.applyMatrix&&c.setApplyMatrix(!0),(i===t||i)&&c.insertAbove(this),c},toShape:"#clone",_asPathItem:function(){return this.toPath(!1)},_draw:function(i,c,h,g){var x=this._style,b=x.hasFill(),k=x.hasStroke(),w=c.dontFinish||c.clip,S=!g;if(b||k||w){var I=this._type,D=this._radius,O=I==="circle";if(c.dontStart||i.beginPath(),S&&O)i.arc(0,0,D,0,Math.PI*2,!0);else{var R=O?D:D.width,$=O?D:D.height,U=this._size,z=U.width,j=U.height;if(S&&I==="rectangle"&&R===0&&$===0)i.rect(-z/2,-j/2,z,j);else{var F=z/2,V=j/2,T=1-.5522847498307936,M=R*T,W=$*T,q=[-F,-V+$,-F,-V+W,-F+M,-V,-F+R,-V,F-R,-V,F-M,-V,F,-V+W,F,-V+$,F,V-$,F,V-W,F-M,V,F-R,V,-F+R,V,-F+M,V,-F,V-W,-F,V-$];g&&g.transform(q,q,32),i.moveTo(q[0],q[1]),i.bezierCurveTo(q[2],q[3],q[4],q[5],q[6],q[7]),F!==R&&i.lineTo(q[8],q[9]),i.bezierCurveTo(q[10],q[11],q[12],q[13],q[14],q[15]),V!==$&&i.lineTo(q[16],q[17]),i.bezierCurveTo(q[18],q[19],q[20],q[21],q[22],q[23]),F!==R&&i.lineTo(q[24],q[25]),i.bezierCurveTo(q[26],q[27],q[28],q[29],q[30],q[31])}}i.closePath()}!w&&(b||k)&&(this._setStyles(i,c,h),b&&(i.fill(x.getFillRule()),i.shadowColor="rgba(0,0,0,0)"),k&&i.stroke())},_canComposite:function(){return!(this.hasFill()&&this.hasStroke())},_getBounds:function(i,c){var h=new C(this._size).setCenter(0,0),g=this._style,x=c.stroke&&g.hasStroke()&&g.getStrokeWidth();return i&&(h=i._transformBounds(h)),x?h.expand(Ct._getStrokePadding(x,this._getStrokeMatrix(i,c))):h}},new function(){function i(h,g,x){var b=h._radius;if(!b.isZero())for(var k=h._size.divide(2),w=1;w<=4;w++){var S=new d(w>1&&w<4?-1:1,w>2?-1:1),I=S.multiply(k),D=I.subtract(S.multiply(b)),O=new C(x?I.add(S.multiply(x)):I,D);if(O.contains(g))return{point:D,quadrant:w}}}function c(h,g,x,b){var k=h.divide(g);return(!b||k.isInQuadrant(b))&&k.subtract(k.normalize()).multiply(g).divide(x).length<=1}return{_contains:function h(g){if(this._type==="rectangle"){var x=i(this,g);return x?g.subtract(x.point).divide(this._radius).getLength()<=1:h.base.call(this,g)}else return g.divide(this.size).getLength()<=.5},_hitTestSelf:function h(g,x,b,k){var w=!1,S=this._style,I=x.stroke&&S.hasStroke(),D=x.fill&&S.hasFill();if(I||D){var O=this._type,R=this._radius,$=I?S.getStrokeWidth()/2:0,U=x._tolerancePadding.add(Ct._getStrokePadding($,!S.getStrokeScaling()&&k));if(O==="rectangle"){var z=U.multiply(2),j=i(this,g,z);if(j)w=c(g.subtract(j.point),R,U,j.quadrant);else{var F=new C(this._size).setCenter(0,0),V=F.expand(z),T=F.expand(z.negate());w=V._containsPoint(g)&&!T._containsPoint(g)}}else w=c(g,R,U)}return w?new St(I?"stroke":"fill",this):h.base.apply(this,arguments)}}},{statics:new function(){function i(c,h,g,x,b){var k=s.create(et.prototype);return k._type=c,k._size=g,k._radius=x,k._initialize(s.getNamed(b),h),k}return{Circle:function(){var c=arguments,h=d.readNamed(c,"center"),g=s.readNamed(c,"radius");return i("circle",h,new _(g*2),g,c)},Rectangle:function(){var c=arguments,h=C.readNamed(c,"rectangle"),g=_.min(_.readNamed(c,"radius"),h.getSize(!0).divide(2));return i("rectangle",h.getCenter(!0),h.getSize(!0),g,c)},Ellipse:function(){var c=arguments,h=et._readEllipse(c),g=h.radius;return i("ellipse",h.center,g.multiply(2),g,c)},_readEllipse:function(c){var h,g;if(s.hasNamed(c,"radius"))h=d.readNamed(c,"center"),g=_.readNamed(c,"radius");else{var x=C.readNamed(c,"rectangle");h=x.getCenter(!0),g=x.getSize(!0).divide(2)}return{center:h,radius:g}}}}}),it=L.extend({_class:"Raster",_applyMatrix:!1,_canApplyMatrix:!1,_boundsOptions:{stroke:!1,handle:!1},_serializeFields:{crossOrigin:null,source:null},_prioritize:["crossOrigin"],_smoothing:!0,beans:!0,initialize:function(c,h){if(!this._initialize(c,h!==t&&d.read(arguments))){var g,x=typeof c,b=x==="string"?n.getElementById(c):x==="object"?c:null;if(b&&b!==L.NO_INSERT){if(b.getContext||b.naturalHeight!=null)g=b;else if(b){var k=_.read(arguments);k.isZero()||(g=Pe.getCanvas(k))}}g?this.setImage(g):this.setSource(c)}this._size||(this._size=new _,this._loaded=!1)},_equals:function(i){return this.getSource()===i.getSource()},copyContent:function(i){var c=i._image,h=i._canvas;if(c)this._setImage(c);else if(h){var g=Pe.getCanvas(i._size);g.getContext("2d").drawImage(h,0,0),this._setImage(g)}this._crossOrigin=i._crossOrigin},getSize:function(){var i=this._size;return new v(i?i.width:0,i?i.height:0,this,"setSize")},setSize:function(){var i=_.read(arguments);if(!i.equals(this._size))if(i.width>0&&i.height>0){var c=this.getElement();this._setImage(Pe.getCanvas(i)),c&&this.getContext(!0).drawImage(c,0,0,i.width,i.height)}else this._canvas&&Pe.release(this._canvas),this._size=i.clone()},getWidth:function(){return this._size?this._size.width:0},setWidth:function(i){this.setSize(i,this.getHeight())},getHeight:function(){return this._size?this._size.height:0},setHeight:function(i){this.setSize(this.getWidth(),i)},getLoaded:function(){return this._loaded},isEmpty:function(){var i=this._size;return!i||i.width===0&&i.height===0},getResolution:function(){var i=this._matrix,c=new d(0,0).transform(i),h=new d(1,0).transform(i).subtract(c),g=new d(0,1).transform(i).subtract(c);return new _(72/h.getLength(),72/g.getLength())},getPpi:"#getResolution",getImage:function(){return this._image},setImage:function(i){var c=this;function h(g){var x=c.getView(),b=g&&g.type||"load";x&&c.responds(b)&&(ye=x._scope,c.emit(b,new We(g)))}this._setImage(i),this._loaded?setTimeout(h,0):i&&te.add(i,{load:function(g){c._setImage(i),h(g)},error:h})},_setImage:function(i){this._canvas&&Pe.release(this._canvas),i&&i.getContext?(this._image=null,this._canvas=i,this._loaded=!0):(this._image=i,this._canvas=null,this._loaded=!!(i&&i.src&&i.complete)),this._size=new _(i?i.naturalWidth||i.width:0,i?i.naturalHeight||i.height:0),this._context=null,this._changed(1033)},getCanvas:function(){if(!this._canvas){var i=Pe.getContext(this._size);try{this._image&&i.drawImage(this._image,0,0),this._canvas=i.canvas}catch(c){Pe.release(i)}}return this._canvas},setCanvas:"#setImage",getContext:function(i){return this._context||(this._context=this.getCanvas().getContext("2d")),i&&(this._image=null,this._changed(1025)),this._context},setContext:function(i){this._context=i},getSource:function(){var i=this._image;return i&&i.src||this.toDataURL()},setSource:function(i){var c=new r.Image,h=this._crossOrigin;h&&(c.crossOrigin=h),i&&(c.src=i),this.setImage(c)},getCrossOrigin:function(){var i=this._image;return i&&i.crossOrigin||this._crossOrigin||""},setCrossOrigin:function(i){this._crossOrigin=i;var c=this._image;c&&(c.crossOrigin=i)},getSmoothing:function(){return this._smoothing},setSmoothing:function(i){this._smoothing=i,this._changed(257)},getElement:function(){return this._canvas||this._loaded&&this._image}},{beans:!1,getSubCanvas:function(){var i=C.read(arguments),c=Pe.getContext(i.getSize());return c.drawImage(this.getCanvas(),i.x,i.y,i.width,i.height,0,0,i.width,i.height),c.canvas},getSubRaster:function(){var i=C.read(arguments),c=new it(L.NO_INSERT);return c._setImage(this.getSubCanvas(i)),c.translate(i.getCenter().subtract(this.getSize().divide(2))),c._matrix.prepend(this._matrix),c.insertAbove(this),c},toDataURL:function(){var i=this._image,c=i&&i.src;if(/^data:/.test(c))return c;var h=this.getCanvas();return h?h.toDataURL.apply(h,arguments):null},drawImage:function(i){var c=d.read(arguments,1);this.getContext(!0).drawImage(i,c.x,c.y)},getAverageColor:function(i){var c,h;if(i?i instanceof Ft?(h=i,c=i.getBounds()):typeof i=="object"&&("width"in i?c=new C(i):"x"in i&&(c=new C(i.x-.5,i.y-.5,1,1))):c=this.getBounds(),!c)return null;var g=32,x=Math.min(c.width,g),b=Math.min(c.height,g),k=it._sampleContext;k?k.clearRect(0,0,g+1,g+1):k=it._sampleContext=Pe.getContext(new _(g)),k.save();var w=new A().scale(x/c.width,b/c.height).translate(-c.x,-c.y);w.applyToContext(k),h&&h.draw(k,new s({clip:!0,matrices:[w]})),this._matrix.applyToContext(k);var S=this.getElement(),I=this._size;S&&k.drawImage(S,-I.width/2,-I.height/2),k.restore();for(var D=k.getImageData(.5,.5,Math.ceil(x),Math.ceil(b)).data,O=[0,0,0],R=0,$=0,U=D.length;$<U;$+=4){var z=D[$+3];R+=z,z/=255,O[0]+=D[$]*z,O[1]+=D[$+1]*z,O[2]+=D[$+2]*z}for(var $=0;$<3;$++)O[$]/=R;return R?Bt.read(O):null},getPixel:function(){var i=d.read(arguments),c=this.getContext().getImageData(i.x,i.y,1,1).data;return new Bt("rgb",[c[0]/255,c[1]/255,c[2]/255],c[3]/255)},setPixel:function(){var i=arguments,c=d.read(i),h=Bt.read(i),g=h._convert("rgb"),x=h._alpha,b=this.getContext(!0),k=b.createImageData(1,1),w=k.data;w[0]=g[0]*255,w[1]=g[1]*255,w[2]=g[2]*255,w[3]=x!=null?x*255:255,b.putImageData(k,c.x,c.y)},clear:function(){var i=this._size;this.getContext(!0).clearRect(0,0,i.width+1,i.height+1)},createImageData:function(){var i=_.read(arguments);return this.getContext().createImageData(i.width,i.height)},getImageData:function(){var i=C.read(arguments);return i.isEmpty()&&(i=new C(this._size)),this.getContext().getImageData(i.x,i.y,i.width,i.height)},setImageData:function(i){var c=d.read(arguments,1);this.getContext(!0).putImageData(i,c.x,c.y)},_getBounds:function(i,c){var h=new C(this._size).setCenter(0,0);return i?i._transformBounds(h):h},_hitTestSelf:function(i){if(this._contains(i)){var c=this;return new St("pixel",c,{offset:i.add(c._size.divide(2)).round(),color:{get:function(){return c.getPixel(this.offset)}}})}},_draw:function(i,c,h){var g=this.getElement();g&&g.width>0&&g.height>0&&(i.globalAlpha=f.clamp(this._opacity,0,1),this._setStyles(i,c,h),Qt.setPrefixed(i,"imageSmoothingEnabled",this._smoothing),i.drawImage(g,-this._size.width/2,-this._size.height/2))},_canComposite:function(){return!0}}),xt=L.extend({_class:"SymbolItem",_applyMatrix:!1,_canApplyMatrix:!1,_boundsOptions:{stroke:!0},_serializeFields:{symbol:null},initialize:function(c,h){this._initialize(c,h!==t&&d.read(arguments,1))||this.setDefinition(c instanceof wt?c:new wt(c))},_equals:function(i){return this._definition===i._definition},copyContent:function(i){this.setDefinition(i._definition)},getDefinition:function(){return this._definition},setDefinition:function(i){this._definition=i,this._changed(9)},getSymbol:"#getDefinition",setSymbol:"#setDefinition",isEmpty:function(){return this._definition._item.isEmpty()},_getBounds:function(i,c){var h=this._definition._item;return h._getCachedBounds(h._matrix.prepended(i),c)},_hitTestSelf:function(i,c,h){var g=c.extend({all:!1}),x=this._definition._item._hitTest(i,g,h);return x&&(x.item=this),x},_draw:function(i,c){this._definition._item.draw(i,c)}}),wt=s.extend({_class:"SymbolDefinition",initialize:function(c,h){this._id=m.get(),this.project=ye.project,c&&this.setItem(c,h)},_serialize:function(i,c){return c.add(this,function(){return s.serialize([this._class,this._item],i,!1,c)})},_changed:function(i){i&8&&L._clearBoundsCache(this),i&1&&this.project._changed(i)},getItem:function(){return this._item},setItem:function(i,c){i._symbol&&(i=i.clone()),this._item&&(this._item._symbol=null),this._item=i,i.remove(),i.setSelected(!1),c||i.setPosition(new d),i._symbol=this,this._changed(9)},getDefinition:"#getItem",setDefinition:"#setItem",place:function(i){return new xt(this,i)},clone:function(){return new wt(this._item.clone(!1))},equals:function(i){return i===this||i&&this._item.equals(i._item)||!1}}),St=s.extend({_class:"HitResult",initialize:function(c,h,g){this.type=c,this.item=h,g&&this.inject(g)},statics:{getOptions:function(i){var c=i&&s.read(i);return new s({type:null,tolerance:ye.settings.hitTolerance,fill:!c,stroke:!c,segments:!c,handles:!1,ends:!1,position:!1,center:!1,bounds:!1,guides:!1,selected:!1},c)}}}),yt=s.extend({_class:"Segment",beans:!0,_selection:0,initialize:function(c,h,g,x,b,k){var w=arguments.length,S,I,D,O;w>0&&(c==null||typeof c=="object"?w===1&&c&&"point"in c?(S=c.point,I=c.handleIn,D=c.handleOut,O=c.selection):(S=c,I=h,D=g,O=x):(S=[c,h],I=g!==t?[g,x]:null,D=b!==t?[b,k]:null)),new Nt(S,this,"_point"),new Nt(I,this,"_handleIn"),new Nt(D,this,"_handleOut"),O&&this.setSelection(O)},_serialize:function(i,c){var h=this._point,g=this._selection,x=g||this.hasHandles()?[h,this._handleIn,this._handleOut]:h;return g&&x.push(g),s.serialize(x,i,!0,c)},_changed:function(i){var c=this._path;if(!!c){var h=c._curves,g=this._index,x;h&&((!i||i===this._point||i===this._handleIn)&&(x=g>0?h[g-1]:c._closed?h[h.length-1]:null)&&x._changed(),(!i||i===this._point||i===this._handleOut)&&(x=h[g])&&x._changed()),c._changed(41)}},getPoint:function(){return this._point},setPoint:function(){this._point.set(d.read(arguments))},getHandleIn:function(){return this._handleIn},setHandleIn:function(){this._handleIn.set(d.read(arguments))},getHandleOut:function(){return this._handleOut},setHandleOut:function(){this._handleOut.set(d.read(arguments))},hasHandles:function(){return!this._handleIn.isZero()||!this._handleOut.isZero()},isSmooth:function(){var i=this._handleIn,c=this._handleOut;return!i.isZero()&&!c.isZero()&&i.isCollinear(c)},clearHandles:function(){this._handleIn._set(0,0),this._handleOut._set(0,0)},getSelection:function(){return this._selection},setSelection:function(i){var c=this._selection,h=this._path;this._selection=i=i||0,h&&i!==c&&(h._updateSelection(this,c,i),h._changed(257))},_changeSelection:function(i,c){var h=this._selection;this.setSelection(c?h|i:h&~i)},isSelected:function(){return!!(this._selection&7)},setSelected:function(i){this._changeSelection(7,i)},getIndex:function(){return this._index!==t?this._index:null},getPath:function(){return this._path||null},getCurve:function(){var i=this._path,c=this._index;return i?(c>0&&!i._closed&&c===i._segments.length-1&&c--,i.getCurves()[c]||null):null},getLocation:function(){var i=this.getCurve();return i?new It(i,this===i._segment1?0:1):null},getNext:function(){var i=this._path&&this._path._segments;return i&&(i[this._index+1]||this._path._closed&&i[0])||null},smooth:function(i,c,h){var g=i||{},x=g.type,b=g.factor,k=this.getPrevious(),w=this.getNext(),S=(k||this)._point,I=this._point,D=(w||this)._point,O=S.getDistance(I),R=I.getDistance(D);if(!x||x==="catmull-rom"){var $=b===t?.5:b,U=Math.pow(O,$),z=U*U,j=Math.pow(R,$),F=j*j;if(!c&&k){var V=2*F+3*j*U+z,T=3*j*(j+U);this.setHandleIn(T!==0?new d((F*S._x+V*I._x-z*D._x)/T-I._x,(F*S._y+V*I._y-z*D._y)/T-I._y):new d)}if(!h&&w){var V=2*z+3*U*j+F,T=3*U*(U+j);this.setHandleOut(T!==0?new d((z*D._x+V*I._x-F*S._x)/T-I._x,(z*D._y+V*I._y-F*S._y)/T-I._y):new d)}}else if(x==="geometric"){if(k&&w){var M=S.subtract(D),W=b===t?.4:b,q=W*O/(O+R);c||this.setHandleIn(M.multiply(q)),h||this.setHandleOut(M.multiply(q-W))}}else throw new Error("Smoothing method '"+x+"' not supported.")},getPrevious:function(){var i=this._path&&this._path._segments;return i&&(i[this._index-1]||this._path._closed&&i[i.length-1])||null},isFirst:function(){return!this._index},isLast:function(){var i=this._path;return i&&this._index===i._segments.length-1||!1},reverse:function(){var i=this._handleIn,c=this._handleOut,h=i.clone();i.set(c),c.set(h)},reversed:function(){return new yt(this._point,this._handleOut,this._handleIn)},remove:function(){return this._path?!!this._path.removeSegment(this._index):!1},clone:function(){return new yt(this._point,this._handleIn,this._handleOut)},equals:function(i){return i===this||i&&this._class===i._class&&this._point.equals(i._point)&&this._handleIn.equals(i._handleIn)&&this._handleOut.equals(i._handleOut)||!1},toString:function(){var i=["point: "+this._point];return this._handleIn.isZero()||i.push("handleIn: "+this._handleIn),this._handleOut.isZero()||i.push("handleOut: "+this._handleOut),"{ "+i.join(", ")+" }"},transform:function(i){this._transformCoordinates(i,new Array(6),!0),this._changed()},interpolate:function(i,c,h){var g=1-h,x=h,b=i._point,k=c._point,w=i._handleIn,S=c._handleIn,I=c._handleOut,D=i._handleOut;this._point._set(g*b._x+x*k._x,g*b._y+x*k._y,!0),this._handleIn._set(g*w._x+x*S._x,g*w._y+x*S._y,!0),this._handleOut._set(g*D._x+x*I._x,g*D._y+x*I._y,!0),this._changed()},_transformCoordinates:function(i,c,h){var g=this._point,x=!h||!this._handleIn.isZero()?this._handleIn:null,b=!h||!this._handleOut.isZero()?this._handleOut:null,k=g._x,w=g._y,S=2;return c[0]=k,c[1]=w,x&&(c[S++]=x._x+k,c[S++]=x._y+w),b&&(c[S++]=b._x+k,c[S++]=b._y+w),i&&(i._transformCoordinates(c,c,S/2),k=c[0],w=c[1],h?(g._x=k,g._y=w,S=2,x&&(x._x=c[S++]-k,x._y=c[S++]-w),b&&(b._x=c[S++]-k,b._y=c[S++]-w)):(x||(c[S++]=k,c[S++]=w),b||(c[S++]=k,c[S++]=w))),c}}),Nt=d.extend({initialize:function(c,h,g){var x,b,k;if(!c)x=b=0;else if((x=c[0])!==t)b=c[1];else{var w=c;(x=w.x)===t&&(w=d.read(arguments),x=w.x),b=w.y,k=w.selected}this._x=x,this._y=b,this._owner=h,h[g]=this,k&&this.setSelected(!0)},_set:function(i,c){return this._x=i,this._y=c,this._owner._changed(this),this},getX:function(){return this._x},setX:function(i){this._x=i,this._owner._changed(this)},getY:function(){return this._y},setY:function(i){this._y=i,this._owner._changed(this)},isZero:function(){var i=f.isZero;return i(this._x)&&i(this._y)},isSelected:function(){return!!(this._owner._selection&this._getSelection())},setSelected:function(i){this._owner._changeSelection(this._getSelection(),i)},_getSelection:function(){var i=this._owner;return this===i._point?1:this===i._handleIn?2:this===i._handleOut?4:0}}),ht=s.extend({_class:"Curve",beans:!0,initialize:function(c,h,g,x,b,k,w,S){var I=arguments.length,D,O,R,$,U,z;I===3?(this._path=c,D=h,O=g):I?I===1?"segment1"in c?(D=new yt(c.segment1),O=new yt(c.segment2)):"point1"in c?(R=c.point1,U=c.handle1,z=c.handle2,$=c.point2):Array.isArray(c)&&(R=[c[0],c[1]],$=[c[6],c[7]],U=[c[2]-c[0],c[3]-c[1]],z=[c[4]-c[6],c[5]-c[7]]):I===2?(D=new yt(c),O=new yt(h)):I===4?(R=c,U=h,z=g,$=x):I===8&&(R=[c,h],$=[w,S],U=[g-c,x-h],z=[b-w,k-S]):(D=new yt,O=new yt),this._segment1=D||new yt(R,null,U),this._segment2=O||new yt($,z,null)},_serialize:function(i,c){return s.serialize(this.hasHandles()?[this.getPoint1(),this.getHandle1(),this.getHandle2(),this.getPoint2()]:[this.getPoint1(),this.getPoint2()],i,!0,c)},_changed:function(){this._length=this._bounds=t},clone:function(){return new ht(this._segment1,this._segment2)},toString:function(){var i=["point1: "+this._segment1._point];return this._segment1._handleOut.isZero()||i.push("handle1: "+this._segment1._handleOut),this._segment2._handleIn.isZero()||i.push("handle2: "+this._segment2._handleIn),i.push("point2: "+this._segment2._point),"{ "+i.join(", ")+" }"},classify:function(){return ht.classify(this.getValues())},remove:function(){var i=!1;if(this._path){var c=this._segment2,h=c._handleOut;i=c.remove(),i&&this._segment1._handleOut.set(h)}return i},getPoint1:function(){return this._segment1._point},setPoint1:function(){this._segment1._point.set(d.read(arguments))},getPoint2:function(){return this._segment2._point},setPoint2:function(){this._segment2._point.set(d.read(arguments))},getHandle1:function(){return this._segment1._handleOut},setHandle1:function(){this._segment1._handleOut.set(d.read(arguments))},getHandle2:function(){return this._segment2._handleIn},setHandle2:function(){this._segment2._handleIn.set(d.read(arguments))},getSegment1:function(){return this._segment1},getSegment2:function(){return this._segment2},getPath:function(){return this._path},getIndex:function(){return this._segment1._index},getNext:function(){var i=this._path&&this._path._curves;return i&&(i[this._segment1._index+1]||this._path._closed&&i[0])||null},getPrevious:function(){var i=this._path&&this._path._curves;return i&&(i[this._segment1._index-1]||this._path._closed&&i[i.length-1])||null},isFirst:function(){return!this._segment1._index},isLast:function(){var i=this._path;return i&&this._segment1._index===i._curves.length-1||!1},isSelected:function(){return this.getPoint1().isSelected()&&this.getHandle1().isSelected()&&this.getHandle2().isSelected()&&this.getPoint2().isSelected()},setSelected:function(i){this.getPoint1().setSelected(i),this.getHandle1().setSelected(i),this.getHandle2().setSelected(i),this.getPoint2().setSelected(i)},getValues:function(i){return ht.getValues(this._segment1,this._segment2,i)},getPoints:function(){for(var i=this.getValues(),c=[],h=0;h<8;h+=2)c.push(new d(i[h],i[h+1]));return c}},{getLength:function(){return this._length==null&&(this._length=ht.getLength(this.getValues(),0,1)),this._length},getArea:function(){return ht.getArea(this.getValues())},getLine:function(){return new B(this._segment1._point,this._segment2._point)},getPart:function(i,c){return new ht(ht.getPart(this.getValues(),i,c))},getPartLength:function(i,c){return ht.getLength(this.getValues(),i,c)},divideAt:function(i){return this.divideAtTime(i&&i.curve===this?i.time:this.getTimeAt(i))},divideAtTime:function(i,c){var h=1e-8,g=1-h,x=null;if(i>=h&&i<=g){var b=ht.subdivide(this.getValues(),i),k=b[0],w=b[1],S=c||this.hasHandles(),I=this._segment1,D=this._segment2,O=this._path;S&&(I._handleOut._set(k[2]-k[0],k[3]-k[1]),D._handleIn._set(w[4]-w[6],w[5]-w[7]));var R=k[6],$=k[7],U=new yt(new d(R,$),S&&new d(k[4]-R,k[5]-$),S&&new d(w[2]-R,w[3]-$));O?(O.insert(I._index+1,U),x=this.getNext()):(this._segment2=U,this._changed(),x=new ht(U,D))}return x},splitAt:function(i){var c=this._path;return c?c.splitAt(i):null},splitAtTime:function(i){return this.splitAt(this.getLocationAtTime(i))},divide:function(i,c){return this.divideAtTime(i===t?.5:c?i:this.getTimeAt(i))},split:function(i,c){return this.splitAtTime(i===t?.5:c?i:this.getTimeAt(i))},reversed:function(){return new ht(this._segment2.reversed(),this._segment1.reversed())},clearHandles:function(){this._segment1._handleOut._set(0,0),this._segment2._handleIn._set(0,0)},statics:{getValues:function(i,c,h,g){var x=i._point,b=i._handleOut,k=c._handleIn,w=c._point,S=x.x,I=x.y,D=w.x,O=w.y,R=g?[S,I,S,I,D,O,D,O]:[S,I,S+b._x,I+b._y,D+k._x,O+k._y,D,O];return h&&h._transformCoordinates(R,R,4),R},subdivide:function(i,c){var h=i[0],g=i[1],x=i[2],b=i[3],k=i[4],w=i[5],S=i[6],I=i[7];c===t&&(c=.5);var D=1-c,O=D*h+c*x,R=D*g+c*b,$=D*x+c*k,U=D*b+c*w,z=D*k+c*S,j=D*w+c*I,F=D*O+c*$,V=D*R+c*U,T=D*$+c*z,M=D*U+c*j,W=D*F+c*T,q=D*V+c*M;return[[h,g,O,R,F,V,W,q],[W,q,T,M,z,j,S,I]]},getMonoCurves:function(i,c){var h=[],g=c?0:1,x=i[g+0],b=i[g+2],k=i[g+4],w=i[g+6];if(x>=b==b>=k&&b>=k==k>=w||ht.isStraight(i))h.push(i);else{var S=3*(b-k)-x+w,I=2*(x+k)-4*b,D=b-x,O=1e-8,R=1-O,$=[],U=f.solveQuadratic(S,I,D,$,O,R);if(!U)h.push(i);else{$.sort();var z=$[0],j=ht.subdivide(i,z);h.push(j[0]),U>1&&(z=($[1]-z)/(1-z),j=ht.subdivide(j[1],z),h.push(j[0])),h.push(j[1])}}return h},solveCubic:function(i,c,h,g,x,b){var k=i[c],w=i[c+2],S=i[c+4],I=i[c+6],D=0;if(!(k<h&&I<h&&w<h&&S<h||k>h&&I>h&&w>h&&S>h)){var O=3*(w-k),R=3*(S-w)-O,$=I-k-O-R;D=f.solveCubic($,R,O,k-h,g,x,b)}return D},getTimeOf:function(i,c){var h=new d(i[0],i[1]),g=new d(i[6],i[7]),x=1e-12,b=1e-7,k=c.isClose(h,x)?0:c.isClose(g,x)?1:null;if(k===null)for(var w=[c.x,c.y],S=[],I=0;I<2;I++)for(var D=ht.solveCubic(i,I,w[I],S,0,1),O=0;O<D;O++){var R=S[O];if(c.isClose(ht.getPoint(i,R),b))return R}return c.isClose(h,b)?0:c.isClose(g,b)?1:null},getNearestTime:function(i,c){if(ht.isStraight(i)){var h=i[0],g=i[1],x=i[6],b=i[7],k=x-h,w=b-g,S=k*k+w*w;if(S===0)return 0;var I=((c.x-h)*k+(c.y-g)*w)/S;return I<1e-12?0:I>.999999999999?1:ht.getTimeOf(i,new d(h+I*k,g+I*w))}var D=100,O=Infinity,R=0;function $(j){if(j>=0&&j<=1){var F=c.getDistance(ht.getPoint(i,j),!0);if(F<O)return O=F,R=j,!0}}for(var U=0;U<=D;U++)$(U/D);for(var z=1/(D*2);z>1e-8;)!$(R-z)&&!$(R+z)&&(z/=2);return R},getPart:function(i,c,h){var g=c>h;if(g){var x=c;c=h,h=x}return c>0&&(i=ht.subdivide(i,c)[1]),h<1&&(i=ht.subdivide(i,(h-c)/(1-c))[0]),g?[i[6],i[7],i[4],i[5],i[2],i[3],i[0],i[1]]:i},isFlatEnough:function(i,c){var h=i[0],g=i[1],x=i[2],b=i[3],k=i[4],w=i[5],S=i[6],I=i[7],D=3*x-2*h-S,O=3*b-2*g-I,R=3*k-2*S-h,$=3*w-2*I-g;return Math.max(D*D,R*R)+Math.max(O*O,$*$)<=16*c*c},getArea:function(i){var c=i[0],h=i[1],g=i[2],x=i[3],b=i[4],k=i[5],w=i[6],S=i[7];return 3*((S-h)*(g+b)-(w-c)*(x+k)+x*(c-b)-g*(h-k)+S*(b+c/3)-w*(k+h/3))/20},getBounds:function(i){for(var c=i.slice(0,2),h=c.slice(),g=[0,0],x=0;x<2;x++)ht._addBounds(i[x],i[x+2],i[x+4],i[x+6],x,0,c,h,g);return new C(c[0],c[1],h[0]-c[0],h[1]-c[1])},_addBounds:function(i,c,h,g,x,b,k,w,S){function I(W,q){var G=W-q,J=W+q;G<k[x]&&(k[x]=G),J>w[x]&&(w[x]=J)}b/=2;var D=k[x]+b,O=w[x]-b;if(i<D||c<D||h<D||g<D||i>O||c>O||h>O||g>O)if(c<i!=c<g&&h<i!=h<g)I(i,0),I(g,0);else{var R=3*(c-h)-i+g,$=2*(i+h)-4*c,U=c-i,z=f.solveQuadratic(R,$,U,S),j=1e-8,F=1-j;I(g,0);for(var V=0;V<z;V++){var T=S[V],M=1-T;j<=T&&T<=F&&I(M*M*M*i+3*M*M*T*c+3*M*T*T*h+T*T*T*g,b)}}}}},s.each(["getBounds","getStrokeBounds","getHandleBounds"],function(i){this[i]=function(){this._bounds||(this._bounds={});var c=this._bounds[i];return c||(c=this._bounds[i]=Ct[i]([this._segment1,this._segment2],!1,this._path)),c.clone()}},{}),s.each({isStraight:function(i,c,h,g){if(c.isZero()&&h.isZero())return!0;var x=g.subtract(i);if(x.isZero())return!1;if(x.isCollinear(c)&&x.isCollinear(h)){var b=new B(i,g),k=1e-7;if(b.getDistance(i.add(c))<k&&b.getDistance(g.add(h))<k){var w=x.dot(x),S=x.dot(c)/w,I=x.dot(h)/w;return S>=0&&S<=1&&I<=0&&I>=-1}}return!1},isLinear:function(i,c,h,g){var x=g.subtract(i).divide(3);return c.equals(x)&&h.negate().equals(x)}},function(i,c){this[c]=function(h){var g=this._segment1,x=this._segment2;return i(g._point,g._handleOut,x._handleIn,x._point,h)},this.statics[c]=function(h,g){var x=h[0],b=h[1],k=h[6],w=h[7];return i(new d(x,b),new d(h[2]-x,h[3]-b),new d(h[4]-k,h[5]-w),new d(k,w),g)}},{statics:{},hasHandles:function(){return!this._segment1._handleOut.isZero()||!this._segment2._handleIn.isZero()},hasLength:function(i){return(!this.getPoint1().equals(this.getPoint2())||this.hasHandles())&&this.getLength()>(i||0)},isCollinear:function(i){return i&&this.isStraight()&&i.isStraight()&&this.getLine().isCollinear(i.getLine())},isHorizontal:function(){return this.isStraight()&&Math.abs(this.getTangentAtTime(.5).y)<1e-8},isVertical:function(){return this.isStraight()&&Math.abs(this.getTangentAtTime(.5).x)<1e-8}}),{beans:!1,getLocationAt:function(i,c){return this.getLocationAtTime(c?i:this.getTimeAt(i))},getLocationAtTime:function(i){return i!=null&&i>=0&&i<=1?new It(this,i):null},getTimeAt:function(i,c){return ht.getTimeAt(this.getValues(),i,c)},getParameterAt:"#getTimeAt",getTimesWithTangent:function(){var i=d.read(arguments);return i.isZero()?[]:ht.getTimesWithTangent(this.getValues(),i)},getOffsetAtTime:function(i){return this.getPartLength(0,i)},getLocationOf:function(){return this.getLocationAtTime(this.getTimeOf(d.read(arguments)))},getOffsetOf:function(){var i=this.getLocationOf.apply(this,arguments);return i?i.getOffset():null},getTimeOf:function(){return ht.getTimeOf(this.getValues(),d.read(arguments))},getParameterOf:"#getTimeOf",getNearestLocation:function(){var i=d.read(arguments),c=this.getValues(),h=ht.getNearestTime(c,i),g=ht.getPoint(c,h);return new It(this,h,g,null,i.getDistance(g))},getNearestPoint:function(){var i=this.getNearestLocation.apply(this,arguments);return i&&i.getPoint()}},new function(){var i=["getPoint","getTangent","getNormal","getWeightedTangent","getWeightedNormal","getCurvature"];return s.each(i,function(c){this[c+"At"]=function(h,g){var x=this.getValues();return ht[c](x,g?h:ht.getTimeAt(x,h))},this[c+"AtTime"]=function(h){return ht[c](this.getValues(),h)}},{statics:{_evaluateMethods:i}})},new function(){function i(g){var x=g[0],b=g[1],k=g[2],w=g[3],S=g[4],I=g[5],D=g[6],O=g[7],R=9*(k-S)+3*(D-x),$=6*(x+S)-12*k,U=3*(k-x),z=9*(w-I)+3*(O-b),j=6*(b+I)-12*w,F=3*(w-b);return function(V){var T=(R*V+$)*V+U,M=(z*V+j)*V+F;return Math.sqrt(T*T+M*M)}}function c(g,x){return Math.max(2,Math.min(16,Math.ceil(Math.abs(x-g)*32)))}function h(g,x,b,k){if(x==null||x<0||x>1)return null;var w=g[0],S=g[1],I=g[2],D=g[3],O=g[4],R=g[5],$=g[6],U=g[7],z=f.isZero;z(I-w)&&z(D-S)&&(I=w,D=S),z(O-$)&&z(R-U)&&(O=$,R=U);var j=3*(I-w),F=3*(O-I)-j,V=$-w-j-F,T=3*(D-S),M=3*(R-D)-T,W=U-S-T-M,q,G;if(b===0)q=x===0?w:x===1?$:((V*x+F)*x+j)*x+w,G=x===0?S:x===1?U:((W*x+M)*x+T)*x+S;else{var J=1e-8,nt=1-J;if(x<J?(q=j,G=T):x>nt?(q=3*($-O),G=3*(U-R)):(q=(3*V*x+2*F)*x+j,G=(3*W*x+2*M)*x+T),k){q===0&&G===0&&(x<J||x>nt)&&(q=O-I,G=R-D);var ot=Math.sqrt(q*q+G*G);ot&&(q/=ot,G/=ot)}if(b===3){var O=6*V*x+2*F,R=6*W*x+2*M,at=Math.pow(q*q+G*G,3/2);q=at!==0?(q*R-G*O)/at:0,G=0}}return b===2?new d(G,-q):new d(q,G)}return{statics:{classify:function(g){var x=g[0],b=g[1],k=g[2],w=g[3],S=g[4],I=g[5],D=g[6],O=g[7],R=x*(O-I)+b*(S-D)+D*I-O*S,$=k*(b-O)+w*(D-x)+x*O-b*D,U=S*(w-b)+I*(x-k)+k*b-w*x,z=3*U,j=z-$,F=j-$+R,V=Math.sqrt(F*F+j*j+z*z),T=V!==0?1/V:0,M=f.isZero,W="serpentine";F*=T,j*=T,z*=T;function q(ot,at,lt){var pt=at!==t,ut=pt&&at>0&&at<1,gt=pt&&lt>0&&lt<1;return pt&&(!(ut||gt)||ot==="loop"&&!(ut&&gt))&&(ot="arch",ut=gt=!1),{type:ot,roots:ut||gt?ut&&gt?at<lt?[at,lt]:[lt,at]:[ut?at:lt]:null}}if(M(F))return M(j)?q(M(z)?"line":"quadratic"):q(W,z/(3*j));var G=3*j*j-4*F*z;if(M(G))return q("cusp",j/(2*F));var J=G>0?Math.sqrt(G/3):Math.sqrt(-G),nt=2*F;return q(G>0?W:"loop",(j+J)/nt,(j-J)/nt)},getLength:function(g,x,b,k){if(x===t&&(x=0),b===t&&(b=1),ht.isStraight(g)){var w=g;b<1&&(w=ht.subdivide(w,b)[0],x/=b),x>0&&(w=ht.subdivide(w,x)[1]);var S=w[6]-w[0],I=w[7]-w[1];return Math.sqrt(S*S+I*I)}return f.integrate(k||i(g),x,b,c(x,b))},getTimeAt:function(g,x,b){if(b===t&&(b=x<0?1:0),x===0)return b;var k=Math.abs,w=1e-12,S=x>0,I=S?b:0,D=S?1:b,O=i(g),R=ht.getLength(g,I,D,O),$=k(x)-R;if(k($)<w)return S?D:I;if($>w)return null;var U=x/R,z=0;function j(F){return z+=f.integrate(O,b,F,c(b,F)),b=F,z-x}return f.findRoot(j,O,b+U,I,D,32,1e-12)},getPoint:function(g,x){return h(g,x,0,!1)},getTangent:function(g,x){return h(g,x,1,!0)},getWeightedTangent:function(g,x){return h(g,x,1,!1)},getNormal:function(g,x){return h(g,x,2,!0)},getWeightedNormal:function(g,x){return h(g,x,2,!1)},getCurvature:function(g,x){return h(g,x,3,!1).x},getPeaks:function(g){var x=g[0],b=g[1],k=g[2],w=g[3],S=g[4],I=g[5],D=g[6],O=g[7],R=-x+3*k-3*S+D,$=3*x-6*k+3*S,U=-3*x+3*k,z=-b+3*w-3*I+O,j=3*b-6*w+3*I,F=-3*b+3*w,V=1e-8,T=1-V,M=[];return f.solveCubic(9*(R*R+z*z),9*(R*$+j*z),2*($*$+j*j)+3*(U*R+F*z),U*$+j*F,M,V,T),M.sort()}}}},new function(){function i($,U,z,j,F,V,T){var M=!T&&z.getPrevious()===F,W=!T&&z!==F&&z.getNext()===F,q=1e-8,G=1-q;if(j!==null&&j>=(M?q:0)&&j<=(W?G:1)&&V!==null&&V>=(W?q:0)&&V<=(M?G:1)){var J=new It(z,j,null,T),nt=new It(F,V,null,T);J._intersection=nt,nt._intersection=J,(!U||U(J))&&It.insert($,J,!0)}}function c($,U,z,j,F,V,T,M,W,q,G,J,nt){if(++W>=4096||++M>=40)return W;var ot=1e-9,at=U[0],lt=U[1],pt=U[6],ut=U[7],gt=B.getSignedDistance,bt=gt(at,lt,pt,ut,U[2],U[3]),kt=gt(at,lt,pt,ut,U[4],U[5]),Rt=bt*kt>0?3/4:4/9,Wt=Rt*Math.min(0,bt,kt),Kt=Rt*Math.max(0,bt,kt),Yt=gt(at,lt,pt,ut,$[0],$[1]),Et=gt(at,lt,pt,ut,$[2],$[3]),Pt=gt(at,lt,pt,ut,$[4],$[5]),Ut=gt(at,lt,pt,ut,$[6],$[7]),se=h(Yt,Et,Pt,Ut),Jt=se[0],de=se[1],me,Se;if(bt===0&&kt===0&&Yt===0&&Et===0&&Pt===0&&Ut===0||(me=g(Jt,de,Wt,Kt))==null||(Se=g(Jt.reverse(),de.reverse(),Wt,Kt))==null)return W;var Ee=q+(G-q)*me,ke=q+(G-q)*Se;if(Math.max(nt-J,ke-Ee)<ot){var Lr=(Ee+ke)/2,zr=(J+nt)/2;i(F,V,T?j:z,T?zr:Lr,T?z:j,T?Lr:zr)}else{$=ht.getPart($,me,Se);var en=nt-J;if(Se-me>.8)if(ke-Ee>en){var Tr=ht.subdivide($,.5),Lr=(Ee+ke)/2;W=c(U,Tr[0],j,z,F,V,!T,M,W,J,nt,Ee,Lr),W=c(U,Tr[1],j,z,F,V,!T,M,W,J,nt,Lr,ke)}else{var Tr=ht.subdivide(U,.5),zr=(J+nt)/2;W=c(Tr[0],$,j,z,F,V,!T,M,W,J,zr,Ee,ke),W=c(Tr[1],$,j,z,F,V,!T,M,W,zr,nt,Ee,ke)}else en===0||en>=ot?W=c(U,$,j,z,F,V,!T,M,W,J,nt,Ee,ke):W=c($,U,z,j,F,V,T,M,W,Ee,ke,J,nt)}return W}function h($,U,z,j){var F=[0,$],V=[1/3,U],T=[2/3,z],M=[1,j],W=U-(2*$+j)/3,q=z-($+2*j)/3,G;if(W*q<0)G=[[F,V,M],[F,T,M]];else{var J=W/q;G=[J>=2?[F,V,M]:J<=.5?[F,T,M]:[F,V,T,M],[F,M]]}return(W||q)<0?G.reverse():G}function g($,U,z,j){return $[0][1]<z?x($,!0,z):U[0][1]>j?x(U,!1,j):$[0][0]}function x($,U,z){for(var j=$[0][0],F=$[0][1],V=1,T=$.length;V<T;V++){var M=$[V][0],W=$[V][1];if(U?W>=z:W<=z)return W===z?M:j+(z-F)*(M-j)/(W-F);j=M,F=W}return null}function b($,U,z,j,F){var V=f.isZero;if(V(j)&&V(F)){var T=ht.getTimeOf($,new d(U,z));return T===null?[]:[T]}for(var M=Math.atan2(-F,j),W=Math.sin(M),q=Math.cos(M),G=[],J=[],nt=0;nt<8;nt+=2){var ot=$[nt]-U,at=$[nt+1]-z;G.push(ot*q-at*W,ot*W+at*q)}return ht.solveCubic(G,1,0,J,0,1),J}function k($,U,z,j,F,V,T){for(var M=U[0],W=U[1],q=U[6],G=U[7],J=b($,M,W,q-M,G-W),nt=0,ot=J.length;nt<ot;nt++){var at=J[nt],lt=ht.getPoint($,at),pt=ht.getTimeOf(U,lt);pt!==null&&i(F,V,T?j:z,T?pt:at,T?z:j,T?at:pt)}}function w($,U,z,j,F,V){var T=B.intersect($[0],$[1],$[6],$[7],U[0],U[1],U[6],U[7]);T&&i(F,V,z,ht.getTimeOf($,T),j,ht.getTimeOf(U,T))}function S($,U,z,j,F,V){var T=1e-12,M=Math.min,W=Math.max;if(W($[0],$[2],$[4],$[6])+T>M(U[0],U[2],U[4],U[6])&&M($[0],$[2],$[4],$[6])-T<W(U[0],U[2],U[4],U[6])&&W($[1],$[3],$[5],$[7])+T>M(U[1],U[3],U[5],U[7])&&M($[1],$[3],$[5],$[7])-T<W(U[1],U[3],U[5],U[7])){var q=O($,U);if(q)for(var G=0;G<2;G++){var J=q[G];i(F,V,z,J[0],j,J[1],!0)}else{var nt=ht.isStraight($),ot=ht.isStraight(U),at=nt&&ot,lt=nt&&!ot,pt=F.length;if((at?w:nt||ot?k:c)(lt?U:$,lt?$:U,lt?j:z,lt?z:j,F,V,lt,0,0,0,1,0,1),!at||F.length===pt)for(var G=0;G<4;G++){var ut=G>>1,gt=G&1,bt=ut*6,kt=gt*6,Rt=new d($[bt],$[bt+1]),Wt=new d(U[kt],U[kt+1]);Rt.isClose(Wt,T)&&i(F,V,z,ut,j,gt)}}}return F}function I($,U,z,j){var F=ht.classify($);if(F.type==="loop"){var V=F.roots;i(z,j,U,V[0],U,V[1])}return z}function D($,U,z,j,F,V){var T=1e-7,M=!U;M&&(U=$);for(var W=$.length,q=U.length,G=new Array(W),J=M?G:new Array(q),nt=[],ot=0;ot<W;ot++)G[ot]=$[ot].getValues(j);if(!M)for(var ot=0;ot<q;ot++)J[ot]=U[ot].getValues(F);for(var at=u.findCurveBoundsCollisions(G,J,T),lt=0;lt<W;lt++){var pt=$[lt],ut=G[lt];M&&I(ut,pt,nt,z);var gt=at[lt];if(gt)for(var bt=0;bt<gt.length;bt++){if(V&&nt.length)return nt;var kt=gt[bt];if(!M||kt>lt){var Rt=U[kt],Wt=J[kt];S(ut,Wt,pt,Rt,nt,z)}}}return nt}function O($,U){function z(Ut){var se=Ut[6]-Ut[0],Jt=Ut[7]-Ut[1];return se*se+Jt*Jt}var j=Math.abs,F=B.getDistance,V=1e-8,T=1e-7,M=ht.isStraight($),W=ht.isStraight(U),q=M&&W,G=z($)<z(U),J=G?U:$,nt=G?$:U,ot=J[0],at=J[1],lt=J[6]-ot,pt=J[7]-at;if(F(ot,at,lt,pt,nt[0],nt[1],!0)<T&&F(ot,at,lt,pt,nt[6],nt[7],!0)<T)!q&&F(ot,at,lt,pt,J[2],J[3],!0)<T&&F(ot,at,lt,pt,J[4],J[5],!0)<T&&F(ot,at,lt,pt,nt[2],nt[3],!0)<T&&F(ot,at,lt,pt,nt[4],nt[5],!0)<T&&(M=W=q=!0);else if(q)return null;if(M^W)return null;for(var ut=[$,U],gt=[],bt=0;bt<4&&gt.length<2;bt++){var kt=bt&1,Rt=kt^1,Wt=bt>>1,Kt=ht.getTimeOf(ut[kt],new d(ut[Rt][Wt?6:0],ut[Rt][Wt?7:1]));if(Kt!=null){var Yt=kt?[Wt,Kt]:[Kt,Wt];(!gt.length||j(Yt[0]-gt[0][0])>V&&j(Yt[1]-gt[0][1])>V)&&gt.push(Yt)}if(bt>2&&!gt.length)break}if(gt.length!==2)gt=null;else if(!q){var Et=ht.getPart($,gt[0][0],gt[1][0]),Pt=ht.getPart(U,gt[0][1],gt[1][1]);(j(Pt[2]-Et[2])>T||j(Pt[3]-Et[3])>T||j(Pt[4]-Et[4])>T||j(Pt[5]-Et[5])>T)&&(gt=null)}return gt}function R($,U){var z=$[0],j=$[1],F=$[2],V=$[3],T=$[4],M=$[5],W=$[6],q=$[7],G=U.normalize(),J=G.x,nt=G.y,ot=3*W-9*T+9*F-3*z,at=3*q-9*M+9*V-3*j,lt=6*T-12*F+6*z,pt=6*M-12*V+6*j,ut=3*F-3*z,gt=3*V-3*j,bt=2*ot*nt-2*at*J,kt=[];if(Math.abs(bt)<f.CURVETIME_EPSILON){var Rt=ot*gt-at*ut,bt=ot*pt-at*lt;if(bt!=0){var Wt=-Rt/bt;Wt>=0&&Wt<=1&&kt.push(Wt)}}else{var Kt=(lt*lt-4*ot*ut)*nt*nt+(-2*lt*pt+4*at*ut+4*ot*gt)*J*nt+(pt*pt-4*at*gt)*J*J,Yt=lt*nt-pt*J;if(Kt>=0&&bt!=0){var Et=Math.sqrt(Kt),Pt=-(Yt+Et)/bt,Ut=(-Yt+Et)/bt;Pt>=0&&Pt<=1&&kt.push(Pt),Ut>=0&&Ut<=1&&kt.push(Ut)}}return kt}return{getIntersections:function($){var U=this.getValues(),z=$&&$!==this&&$.getValues();return z?S(U,z,this,$,[]):I(U,this,[])},statics:{getOverlaps:O,getIntersections:D,getCurveLineIntersections:b,getTimesWithTangent:R}}}),It=s.extend({_class:"CurveLocation",initialize:function(c,h,g,x,b){if(h>=.99999999){var k=c.getNext();k&&(h=0,c=k)}this._setCurve(c),this._time=h,this._point=g||c.getPointAtTime(h),this._overlap=x,this._distance=b,this._intersection=this._next=this._previous=null},_setPath:function(i){this._path=i,this._version=i?i._version:0},_setCurve:function(i){this._setPath(i._path),this._curve=i,this._segment=null,this._segment1=i._segment1,this._segment2=i._segment2},_setSegment:function(i){var c=i.getCurve();c?this._setCurve(c):(this._setPath(i._path),this._segment1=i,this._segment2=null),this._segment=i,this._time=i===this._segment1?0:1,this._point=i._point.clone()},getSegment:function(){var i=this._segment;if(!i){var c=this.getCurve(),h=this.getTime();h===0?i=c._segment1:h===1?i=c._segment2:h!=null&&(i=c.getPartLength(0,h)<c.getPartLength(h,1)?c._segment1:c._segment2),this._segment=i}return i},getCurve:function(){var i=this._path,c=this;i&&i._version!==this._version&&(this._time=this._offset=this._curveOffset=this._curve=null);function h(g){var x=g&&g.getCurve();if(x&&(c._time=x.getTimeOf(c._point))!=null)return c._setCurve(x),x}return this._curve||h(this._segment)||h(this._segment1)||h(this._segment2.getPrevious())},getPath:function(){var i=this.getCurve();return i&&i._path},getIndex:function(){var i=this.getCurve();return i&&i.getIndex()},getTime:function(){var i=this.getCurve(),c=this._time;return i&&c==null?this._time=i.getTimeOf(this._point):c},getParameter:"#getTime",getPoint:function(){return this._point},getOffset:function(){var i=this._offset;if(i==null){i=0;var c=this.getPath(),h=this.getIndex();if(c&&h!=null)for(var g=c.getCurves(),x=0;x<h;x++)i+=g[x].getLength();this._offset=i+=this.getCurveOffset()}return i},getCurveOffset:function(){var i=this._curveOffset;if(i==null){var c=this.getCurve(),h=this.getTime();this._curveOffset=i=h!=null&&c&&c.getPartLength(0,h)}return i},getIntersection:function(){return this._intersection},getDistance:function(){return this._distance},divide:function(){var i=this.getCurve(),c=i&&i.divideAtTime(this.getTime());return c&&this._setSegment(c._segment1),c},split:function(){var i=this.getCurve(),c=i._path,h=i&&i.splitAtTime(this.getTime());return h&&this._setSegment(c.getLastSegment()),h},equals:function(i,c){var h=this===i;if(!h&&i instanceof It){var g=this.getCurve(),x=i.getCurve(),b=g._path,k=x._path;if(b===k){var w=Math.abs,S=1e-7,I=w(this.getOffset()-i.getOffset()),D=!c&&this._intersection,O=!c&&i._intersection;h=(I<S||b&&w(b.getLength()-I)<S)&&(!D&&!O||D&&O&&D.equals(O,!0))}}return h},toString:function(){var i=[],c=this.getPoint(),h=p.instance;c&&i.push("point: "+c);var g=this.getIndex();g!=null&&i.push("index: "+g);var x=this.getTime();return x!=null&&i.push("time: "+h.number(x)),this._distance!=null&&i.push("distance: "+h.number(this._distance)),"{ "+i.join(", ")+" }"},isTouching:function(){var i=this._intersection;if(i&&this.getTangent().isCollinear(i.getTangent())){var c=this.getCurve(),h=i.getCurve();return!(c.isStraight()&&h.isStraight()&&c.getLine().intersect(h.getLine()))}return!1},isCrossing:function(){var i=this._intersection;if(!i)return!1;var c=this.getTime(),h=i.getTime(),g=1e-8,x=1-g,b=c>=g&&c<=x,k=h>=g&&h<=x;if(b&&k)return!this.isTouching();var w=this.getCurve(),S=w&&c<g?w.getPrevious():w,I=i.getCurve(),D=I&&h<g?I.getPrevious():I;if(c>x&&(w=w.getNext()),h>x&&(I=I.getNext()),!S||!w||!D||!I)return!1;var O=[];function R(J,nt){var ot=J.getValues(),at=ht.classify(ot).roots||ht.getPeaks(ot),lt=at.length,pt=ht.getLength(ot,nt&&lt?at[lt-1]:0,!nt&&lt?at[0]:1);O.push(lt?pt:pt/32)}function $(J,nt,ot){return nt<ot?J>nt&&J<ot:J>nt||J<ot}b||(R(S,!0),R(w,!1)),k||(R(D,!0),R(I,!1));var U=this.getPoint(),z=Math.min.apply(Math,O),j=b?w.getTangentAtTime(c):w.getPointAt(z).subtract(U),F=b?j.negate():S.getPointAt(-z).subtract(U),V=k?I.getTangentAtTime(h):I.getPointAt(z).subtract(U),T=k?V.negate():D.getPointAt(-z).subtract(U),M=F.getAngle(),W=j.getAngle(),q=T.getAngle(),G=V.getAngle();return!!(b?$(M,q,G)^$(W,q,G)&&$(M,G,q)^$(W,G,q):$(q,M,W)^$(G,M,W)&&$(q,W,M)^$(G,W,M))},hasOverlap:function(){return!!this._overlap}},s.each(ht._evaluateMethods,function(i){var c=i+"At";this[i]=function(){var h=this.getCurve(),g=this.getTime();return g!=null&&h&&h[c](g,!0)}},{preserve:!0}),new function(){function i(c,h,g){var x=c.length,b=0,k=x-1;function w(U,z){for(var j=U+z;j>=-1&&j<=x;j+=z){var F=c[(j%x+x)%x];if(!h.getPoint().isClose(F.getPoint(),1e-7))break;if(h.equals(F))return F}return null}for(;b<=k;){var S=b+k>>>1,I=c[S],D;if(g&&(D=h.equals(I)?I:w(S,-1)||w(S,1)))return h._overlap&&(D._overlap=D._intersection._overlap=!0),D;var O=h.getPath(),R=I.getPath(),$=O!==R?O._id-R._id:h.getIndex()+h.getTime()-(I.getIndex()+I.getTime());$<0?k=S-1:b=S+1}return c.splice(b,0,h),h}return{statics:{insert:i,expand:function(c){for(var h=c.slice(),g=c.length-1;g>=0;g--)i(h,c[g]._intersection,!1);return h}}}}),Ft=L.extend({_class:"PathItem",_selectBounds:!1,_canScaleStroke:!0,beans:!0,initialize:function(){},statics:{create:function(i){var c,h,g;if(s.isPlainObject(i)?(h=i.segments,c=i.pathData):Array.isArray(i)?h=i:typeof i=="string"&&(c=i),h){var x=h[0];g=x&&Array.isArray(x[0])}else c&&(g=(c.match(/m/gi)||[]).length>1||/z\s*\S+/i.test(c));var b=g?Dt:Ct;return new b(i)}},_asPathItem:function(){return this},isClockwise:function(){return this.getArea()>=0},setClockwise:function(i){this.isClockwise()!=(i=!!i)&&this.reverse()},setPathData:function(i){var c=i&&i.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),h,g=!1,x,b,k=new d,w=new d;function S(T,M){var W=+h[T];return g&&(W+=k[M]),W}function I(T){return new d(S(T,"x"),S(T+1,"y"))}this.clear();for(var D=0,O=c&&c.length;D<O;D++){var R=c[D],$=R[0],U=$.toLowerCase();h=R.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);var z=h&&h.length;switch(g=$===U,x==="z"&&!/[mz]/.test(U)&&this.moveTo(k),U){case"m":case"l":for(var j=U==="m",F=0;F<z;F+=2)this[j?"moveTo":"lineTo"](k=I(F)),j&&(w=k,j=!1);b=k;break;case"h":case"v":var V=U==="h"?"x":"y";k=k.clone();for(var F=0;F<z;F++)k[V]=S(F,V),this.lineTo(k);b=k;break;case"c":for(var F=0;F<z;F+=6)this.cubicCurveTo(I(F),b=I(F+2),k=I(F+4));break;case"s":for(var F=0;F<z;F+=4)this.cubicCurveTo(/[cs]/.test(x)?k.multiply(2).subtract(b):k,b=I(F),k=I(F+2)),x=U;break;case"q":for(var F=0;F<z;F+=4)this.quadraticCurveTo(b=I(F),k=I(F+2));break;case"t":for(var F=0;F<z;F+=2)this.quadraticCurveTo(b=/[qt]/.test(x)?k.multiply(2).subtract(b):k,k=I(F)),x=U;break;case"a":for(var F=0;F<z;F+=7)this.arcTo(k=I(F+5),new _(+h[F],+h[F+1]),+h[F+2],+h[F+4],+h[F+3]);break;case"z":this.closePath(1e-12),k=w;break}x=U}},_canComposite:function(){return!(this.hasFill()&&this.hasStroke())},_contains:function(i){var c=i.isInside(this.getBounds({internal:!0,handle:!0}))?this._getWinding(i):{};return c.onPath||!!(this.getFillRule()==="evenodd"?c.windingL&1||c.windingR&1:c.winding)},getIntersections:function(i,c,h,g){var x=this===i||!i,b=this._matrix._orNullIfIdentity(),k=x?b:(h||i._matrix)._orNullIfIdentity();return x||this.getBounds(b).intersects(i.getBounds(k),1e-12)?ht.getIntersections(this.getCurves(),!x&&i.getCurves(),c,b,k,g):[]},getCrossings:function(i){return this.getIntersections(i,function(c){return c.isCrossing()})},getNearestLocation:function(){for(var i=d.read(arguments),c=this.getCurves(),h=Infinity,g=null,x=0,b=c.length;x<b;x++){var k=c[x].getNearestLocation(i);k._distance<h&&(h=k._distance,g=k)}return g},getNearestPoint:function(){var i=this.getNearestLocation.apply(this,arguments);return i&&i.getPoint()},interpolate:function(i,c,h){var g=!this._children,x=g?"_segments":"_children",b=i[x],k=c[x],w=this[x];if(!b||!k||b.length!==k.length)throw new Error("Invalid operands in interpolate() call: "+i+", "+c);var S=w.length,I=k.length;if(S<I)for(var D=g?yt:Ct,O=S;O<I;O++)this.add(new D);else S>I&&this[g?"removeSegments":"removeChildren"](I,S);for(var O=0;O<I;O++)w[O].interpolate(b[O],k[O],h);g&&(this.setClosed(i._closed),this._changed(9))},compare:function(i){var c=!1;if(i){var h=this._children||[this],g=i._children?i._children.slice():[i],x=h.length,b=g.length,k=[],w=0;c=!0;for(var S=u.findItemBoundsCollisions(h,g,f.GEOMETRIC_EPSILON),I=x-1;I>=0&&c;I--){var D=h[I];c=!1;var O=S[I];if(O)for(var R=O.length-1;R>=0&&!c;R--)D.compare(g[O[R]])&&(k[O[R]]||(k[O[R]]=!0,w++),c=!0)}c=c&&w===b}return c}}),Ct=Ft.extend({_class:"Path",_serializeFields:{segments:[],closed:!1},initialize:function(c){this._closed=!1,this._segments=[],this._version=0;var h=arguments,g=Array.isArray(c)?typeof c[0]=="object"?c:h:c&&c.size===t&&(c.x!==t||c.point!==t)?h:null;g&&g.length>0?this.setSegments(g):(this._curves=t,this._segmentSelection=0,!g&&typeof c=="string"&&(this.setPathData(c),c=null)),this._initialize(!g&&c)},_equals:function(i){return this._closed===i._closed&&s.equals(this._segments,i._segments)},copyContent:function(i){this.setSegments(i._segments),this._closed=i._closed},_changed:function i(c){if(i.base.call(this,c),c&8){if(this._length=this._area=t,c&32)this._version++;else if(this._curves)for(var h=0,g=this._curves.length;h<g;h++)this._curves[h]._changed()}else c&64&&(this._bounds=t)},getStyle:function(){var i=this._parent;return(i instanceof Dt?i:this)._style},getSegments:function(){return this._segments},setSegments:function(i){var c=this.isFullySelected(),h=i&&i.length;if(this._segments.length=0,this._segmentSelection=0,this._curves=t,h){var g=i[h-1];typeof g=="boolean"&&(this.setClosed(g),h--),this._add(yt.readList(i,0,{},h))}c&&this.setFullySelected(!0)},getFirstSegment:function(){return this._segments[0]},getLastSegment:function(){return this._segments[this._segments.length-1]},getCurves:function(){var i=this._curves,c=this._segments;if(!i){var h=this._countCurves();i=this._curves=new Array(h);for(var g=0;g<h;g++)i[g]=new ht(this,c[g],c[g+1]||c[0])}return i},getFirstCurve:function(){return this.getCurves()[0]},getLastCurve:function(){var i=this.getCurves();return i[i.length-1]},isClosed:function(){return this._closed},setClosed:function(i){if(this._closed!=(i=!!i)){if(this._closed=i,this._curves){var c=this._curves.length=this._countCurves();i&&(this._curves[c-1]=new ht(this,this._segments[c-1],this._segments[0]))}this._changed(41)}}},{beans:!0,getPathData:function(i,c){var h=this._segments,g=h.length,x=new p(c),b=new Array(6),k=!0,w,S,I,D,O,R,$,U,z=[];function j(V,T){if(V._transformCoordinates(i,b),w=b[0],S=b[1],k)z.push("M"+x.pair(w,S)),k=!1;else if(O=b[2],R=b[3],O===w&&R===S&&$===I&&U===D){if(!T){var M=w-I,W=S-D;z.push(M===0?"v"+x.number(W):W===0?"h"+x.number(M):"l"+x.pair(M,W))}}else z.push("c"+x.pair($-I,U-D)+" "+x.pair(O-I,R-D)+" "+x.pair(w-I,S-D));I=w,D=S,$=b[4],U=b[5]}if(!g)return"";for(var F=0;F<g;F++)j(h[F]);return this._closed&&g>0&&(j(h[0],!0),z.push("z")),z.join("")},isEmpty:function(){return!this._segments.length},_transformContent:function(i){for(var c=this._segments,h=new Array(6),g=0,x=c.length;g<x;g++)c[g]._transformCoordinates(i,h,!0);return!0},_add:function(i,c){for(var h=this._segments,g=this._curves,x=i.length,b=c==null,c=b?h.length:c,k=0;k<x;k++){var w=i[k];w._path&&(w=i[k]=w.clone()),w._path=this,w._index=c+k,w._selection&&this._updateSelection(w,0,w._selection)}if(b)s.push(h,i);else{h.splice.apply(h,[c,0].concat(i));for(var k=c+x,S=h.length;k<S;k++)h[k]._index=k}if(g){var I=this._countCurves(),D=c>0&&c+x-1===I?c-1:c,O=D,R=Math.min(D+x,I);i._curves&&(g.splice.apply(g,[D,0].concat(i._curves)),O+=i._curves.length);for(var k=O;k<R;k++)g.splice(k,0,new ht(this,null,null));this._adjustCurves(D,R)}return this._changed(41),i},_adjustCurves:function(i,c){for(var h=this._segments,g=this._curves,x,b=i;b<c;b++)x=g[b],x._path=this,x._segment1=h[b],x._segment2=h[b+1]||h[0],x._changed();(x=g[this._closed&&!i?h.length-1:i-1])&&(x._segment2=h[i]||h[0],x._changed()),(x=g[c])&&(x._segment1=h[c],x._changed())},_countCurves:function(){var i=this._segments.length;return!this._closed&&i>0?i-1:i},add:function(i){var c=arguments;return c.length>1&&typeof i!="number"?this._add(yt.readList(c)):this._add([yt.read(c)])[0]},insert:function(i,c){var h=arguments;return h.length>2&&typeof c!="number"?this._add(yt.readList(h,1),i):this._add([yt.read(h,1)],i)[0]},addSegment:function(){return this._add([yt.read(arguments)])[0]},insertSegment:function(i){return this._add([yt.read(arguments,1)],i)[0]},addSegments:function(i){return this._add(yt.readList(i))},insertSegments:function(i,c){return this._add(yt.readList(c),i)},removeSegment:function(i){return this.removeSegments(i,i+1)[0]||null},removeSegments:function(i,c,h){i=i||0,c=s.pick(c,this._segments.length);var g=this._segments,x=this._curves,b=g.length,k=g.splice(i,c-i),w=k.length;if(!w)return k;for(var S=0;S<w;S++){var I=k[S];I._selection&&this._updateSelection(I,I._selection,0),I._index=I._path=null}for(var S=i,D=g.length;S<D;S++)g[S]._index=S;if(x){for(var O=i>0&&c===b+(this._closed?1:0)?i-1:i,x=x.splice(O,w),S=x.length-1;S>=0;S--)x[S]._path=null;h&&(k._curves=x.slice(1)),this._adjustCurves(O,O)}return this._changed(41),k},clear:"#removeSegments",hasHandles:function(){for(var i=this._segments,c=0,h=i.length;c<h;c++)if(i[c].hasHandles())return!0;return!1},clearHandles:function(){for(var i=this._segments,c=0,h=i.length;c<h;c++)i[c].clearHandles()},getLength:function(){if(this._length==null){for(var i=this.getCurves(),c=0,h=0,g=i.length;h<g;h++)c+=i[h].getLength();this._length=c}return this._length},getArea:function(){var i=this._area;if(i==null){var c=this._segments,h=this._closed;i=0;for(var g=0,x=c.length;g<x;g++){var b=g+1===x;i+=ht.getArea(ht.getValues(c[g],c[b?0:g+1],null,b&&!h))}this._area=i}return i},isFullySelected:function(){var i=this._segments.length;return this.isSelected()&&i>0&&this._segmentSelection===i*7},setFullySelected:function(i){i&&this._selectSegments(!0),this.setSelected(i)},setSelection:function i(c){c&1||this._selectSegments(!1),i.base.call(this,c)},_selectSegments:function(i){var c=this._segments,h=c.length,g=i?7:0;this._segmentSelection=g*h;for(var x=0;x<h;x++)c[x]._selection=g},_updateSelection:function(i,c,h){i._selection=h;var g=this._segmentSelection+=h-c;g>0&&this.setSelected(!0)},divideAt:function(i){var c=this.getLocationAt(i),h;return c&&(h=c.getCurve().divideAt(c.getCurveOffset()))?h._segment1:null},splitAt:function(i){var c=this.getLocationAt(i),h=c&&c.index,g=c&&c.time,x=1e-8,b=1-x;g>b&&(h++,g=0);var k=this.getCurves();if(h>=0&&h<k.length){g>=x&&k[h++].divideAtTime(g);var w=this.removeSegments(h,this._segments.length,!0),S;return this._closed?(this.setClosed(!1),S=this):(S=new Ct(L.NO_INSERT),S.insertAbove(this),S.copyAttributes(this)),S._add(w,0),this.addSegment(w[0]),S}return null},split:function(i,c){var h,g=c===t?i:(h=this.getCurves()[i])&&h.getLocationAtTime(c);return g!=null?this.splitAt(g):null},join:function(i,c){var h=c||0;if(i&&i!==this){var g=i._segments,x=this.getLastSegment(),b=i.getLastSegment();if(!b)return this;x&&x._point.isClose(b._point,h)&&i.reverse();var k=i.getFirstSegment();if(x&&x._point.isClose(k._point,h))x.setHandleOut(k._handleOut),this._add(g.slice(1));else{var w=this.getFirstSegment();w&&w._point.isClose(k._point,h)&&i.reverse(),b=i.getLastSegment(),w&&w._point.isClose(b._point,h)?(w.setHandleIn(b._handleIn),this._add(g.slice(0,g.length-1),0)):this._add(g.slice())}i._closed&&this._add([g[0]]),i.remove()}var S=this.getFirstSegment(),I=this.getLastSegment();return S!==I&&S._point.isClose(I._point,h)&&(S.setHandleIn(I._handleIn),I.remove(),this.setClosed(!0)),this},reduce:function(i){for(var c=this.getCurves(),h=i&&i.simplify,g=h?1e-7:0,x=c.length-1;x>=0;x--){var b=c[x];!b.hasHandles()&&(!b.hasLength(g)||h&&b.isCollinear(b.getNext()))&&b.remove()}return this},reverse:function(){this._segments.reverse();for(var i=0,c=this._segments.length;i<c;i++){var h=this._segments[i],g=h._handleIn;h._handleIn=h._handleOut,h._handleOut=g,h._index=i}this._curves=null,this._changed(9)},flatten:function(i){for(var c=new zt(this,i||.25,256,!0),h=c.parts,g=h.length,x=[],b=0;b<g;b++)x.push(new yt(h[b].curve.slice(0,2)));!this._closed&&g>0&&x.push(new yt(h[g-1].curve.slice(6))),this.setSegments(x)},simplify:function(i){var c=new Mt(this).fit(i||2.5);return c&&this.setSegments(c),!!c},smooth:function(i){var c=this,h=i||{},g=h.type||"asymmetric",x=this._segments,b=x.length,k=this._closed;function w(Jt,de){var me=Jt&&Jt.index;if(me!=null){var Se=Jt.path;if(Se&&Se!==c)throw new Error(Jt._class+" "+me+" of "+Se+" is not part of "+c);de&&Jt instanceof ht&&me++}else me=typeof Jt=="number"?Jt:de;return Math.min(me<0&&k?me%b:me<0?me+b:me,b-1)}var S=k&&h.from===t&&h.to===t,I=w(h.from,0),D=w(h.to,b-1);if(I>D)if(k)I-=b;else{var O=I;I=D,D=O}if(/^(?:asymmetric|continuous)$/.test(g)){var R=g==="asymmetric",$=Math.min,U=D-I+1,z=U-1,j=S?$(U,4):1,F=j,V=j,T=[];if(k||(F=$(1,I),V=$(1,b-D-1)),z+=F+V,z<=1)return;for(var M=0,W=I-F;M<=z;M++,W++)T[M]=x[(W<0?W+b:W)%b]._point;for(var q=T[0]._x+2*T[1]._x,G=T[0]._y+2*T[1]._y,J=2,nt=z-1,ot=[q],at=[G],lt=[J],pt=[],ut=[],M=1;M<z;M++){var gt=M<nt,bt=gt||R?1:2,kt=gt?4:R?2:7,Rt=gt?4:R?3:8,Wt=gt?2:R?0:1,Kt=bt/J;J=lt[M]=kt-Kt,q=ot[M]=Rt*T[M]._x+Wt*T[M+1]._x-Kt*q,G=at[M]=Rt*T[M]._y+Wt*T[M+1]._y-Kt*G}pt[nt]=ot[nt]/lt[nt],ut[nt]=at[nt]/lt[nt];for(var M=z-2;M>=0;M--)pt[M]=(ot[M]-pt[M+1])/lt[M],ut[M]=(at[M]-ut[M+1])/lt[M];pt[z]=(3*T[z]._x-pt[nt])/2,ut[z]=(3*T[z]._y-ut[nt])/2;for(var M=F,Yt=z-V,W=I;M<=Yt;M++,W++){var Et=x[W<0?W+b:W],Pt=Et._point,Ut=pt[M]-Pt._x,se=ut[M]-Pt._y;(S||M<Yt)&&Et.setHandleOut(Ut,se),(S||M>F)&&Et.setHandleIn(-Ut,-se)}}else for(var M=I;M<=D;M++)x[M<0?M+b:M].smooth(h,!S&&M===I,!S&&M===D)},toShape:function(i){if(!this._closed)return null;var c=this._segments,h,g,x,b;function k(R,$){var U=c[R],z=U.getNext(),j=c[$],F=j.getNext();return U._handleOut.isZero()&&z._handleIn.isZero()&&j._handleOut.isZero()&&F._handleIn.isZero()&&z._point.subtract(U._point).isCollinear(F._point.subtract(j._point))}function w(R){var $=c[R],U=$.getPrevious(),z=$.getNext();return U._handleOut.isZero()&&$._handleIn.isZero()&&$._handleOut.isZero()&&z._handleIn.isZero()&&$._point.subtract(U._point).isOrthogonal(z._point.subtract($._point))}function S(R){var $=c[R],U=$.getNext(),z=$._handleOut,j=U._handleIn,F=.5522847498307936;if(z.isOrthogonal(j)){var V=$._point,T=U._point,M=new B(V,z,!0).intersect(new B(T,j,!0),!0);return M&&f.isZero(z.getLength()/M.subtract(V).getLength()-F)&&f.isZero(j.getLength()/M.subtract(T).getLength()-F)}return!1}function I(R,$){return c[R]._point.getDistance(c[$]._point)}if(!this.hasHandles()&&c.length===4&&k(0,2)&&k(1,3)&&w(1)?(h=et.Rectangle,g=new _(I(0,3),I(0,1)),b=c[1]._point.add(c[2]._point).divide(2)):c.length===8&&S(0)&&S(2)&&S(4)&&S(6)&&k(1,5)&&k(3,7)?(h=et.Rectangle,g=new _(I(1,6),I(0,3)),x=g.subtract(new _(I(0,7),I(1,2))).divide(2),b=c[3]._point.add(c[4]._point).divide(2)):c.length===4&&S(0)&&S(1)&&S(2)&&S(3)&&(f.isZero(I(0,2)-I(1,3))?(h=et.Circle,x=I(0,2)/2):(h=et.Ellipse,x=new _(I(2,0)/2,I(3,1)/2)),b=c[1]._point),h){var D=this.getPosition(!0),O=new h({center:D,size:g,radius:x,insert:!1});return O.copyAttributes(this,!0),O._matrix.prepend(this._matrix),O.rotate(b.subtract(D).getAngle()+90),(i===t||i)&&O.insertAbove(this),O}return null},toPath:"#clone",compare:function i(c){if(!c||c instanceof Dt)return i.base.call(this,c);var h=this.getCurves(),g=c.getCurves(),x=h.length,b=g.length;if(!x||!b)return x==b;for(var k=h[0].getValues(),w=[],S=0,I,D=0,O,R=0;R<b;R++){var j=g[R].getValues();w.push(j);var $=ht.getOverlaps(k,j);if($){I=!R&&$[0][0]>0?b-1:R,O=$[0][1];break}}for(var U=Math.abs,z=1e-8,j=w[I],F;k&&j;){var $=ht.getOverlaps(k,j);if($){var V=$[0][0];if(U(V-D)<z){D=$[1][0],D===1&&(k=++S<x?h[S].getValues():null,D=0);var T=$[0][1];if(U(T-O)<z){if(F||(F=[I,T]),O=$[1][1],O===1&&(++I>=b&&(I=0),j=w[I]||g[I].getValues(),O=0),!k)return F[0]===I&&F[1]===O;continue}}}break}return!1},_hitTestSelf:function(i,c,h,g){var x=this,b=this.getStyle(),k=this._segments,w=k.length,S=this._closed,I=c._tolerancePadding,D=I,O,R,$,U,z,j,F=c.stroke&&b.hasStroke(),V=c.fill&&b.hasFill(),T=c.curves,M=F?b.getStrokeWidth()/2:V&&c.tolerance>0||T?0:null;M!==null&&(M>0?(O=b.getStrokeJoin(),R=b.getStrokeCap(),$=b.getMiterLimit(),D=D.add(Ct._getStrokePadding(M,g))):O=R="round");function W(pt,ut){return i.subtract(pt).divide(ut).length<=1}function q(pt,ut,gt){if(!c.selected||ut.isSelected()){var bt=pt._point;if(ut!==bt&&(ut=ut.add(bt)),W(ut,D))return new St(gt,x,{segment:pt,point:ut})}}function G(pt,ut){return(ut||c.segments)&&q(pt,pt._point,"segment")||!ut&&c.handles&&(q(pt,pt._handleIn,"handle-in")||q(pt,pt._handleOut,"handle-out"))}function J(pt){U.add(pt)}function nt(pt){var ut=S||pt._index>0&&pt._index<w-1;if((ut?O:R)==="round")return W(pt._point,D);if(U=new Ct({internal:!0,closed:!0}),ut?pt.isSmooth()||Ct._addBevelJoin(pt,O,M,$,null,g,J,!0):R==="square"&&Ct._addSquareCap(pt,R,M,null,g,J,!0),!U.isEmpty()){var gt;return U.contains(i)||(gt=U.getNearestLocation(i))&&W(gt.getPoint(),I)}}if(c.ends&&!c.segments&&!S){if(j=G(k[0],!0)||G(k[w-1],!0))return j}else if(c.segments||c.handles){for(var ot=0;ot<w;ot++)if(j=G(k[ot]))return j}if(M!==null){if(z=this.getNearestLocation(i),z){var at=z.getTime();at===0||at===1&&w>1?nt(z.getSegment())||(z=null):W(z.getPoint(),D)||(z=null)}if(!z&&O==="miter"&&w>1)for(var ot=0;ot<w;ot++){var lt=k[ot];if(i.getDistance(lt._point)<=$*M&&nt(lt)){z=lt.getLocation();break}}}return!z&&V&&this._contains(i)||z&&!F&&!T?new St("fill",this):z?new St(F?"stroke":"curve",this,{location:z,point:z.getPoint()}):null}},s.each(ht._evaluateMethods,function(i){this[i+"At"]=function(c){var h=this.getLocationAt(c);return h&&h[i]()}},{beans:!1,getLocationOf:function(){for(var i=d.read(arguments),c=this.getCurves(),h=0,g=c.length;h<g;h++){var x=c[h].getLocationOf(i);if(x)return x}return null},getOffsetOf:function(){var i=this.getLocationOf.apply(this,arguments);return i?i.getOffset():null},getLocationAt:function(i){if(typeof i=="number"){for(var c=this.getCurves(),h=0,g=0,x=c.length;g<x;g++){var b=h,k=c[g];if(h+=k.getLength(),h>i)return k.getLocationAt(i-b)}if(c.length>0&&i<=this.getLength())return new It(c[c.length-1],1)}else if(i&&i.getPath&&i.getPath()===this)return i;return null},getOffsetsWithTangent:function(){var i=d.read(arguments);if(i.isZero())return[];for(var c=[],h=0,g=this.getCurves(),x=0,b=g.length;x<b;x++){for(var k=g[x],w=k.getTimesWithTangent(i),S=0,I=w.length;S<I;S++){var D=h+k.getOffsetAtTime(w[S]);c.indexOf(D)<0&&c.push(D)}h+=k.length}return c}}),new function(){function i(h,g,x,b){if(b<=0)return;var k=b/2,w=b-2,S=k-1,I=new Array(6),D,O;function R(V){var T=I[V],M=I[V+1];(D!=T||O!=M)&&(h.beginPath(),h.moveTo(D,O),h.lineTo(T,M),h.stroke(),h.beginPath(),h.arc(T,M,k,0,Math.PI*2,!0),h.fill())}for(var $=0,U=g.length;$<U;$++){var z=g[$],j=z._selection;if(z._transformCoordinates(x,I),D=I[0],O=I[1],j&2&&R(2),j&4&&R(4),h.fillRect(D-k,O-k,b,b),w>0&&!(j&1)){var F=h.fillStyle;h.fillStyle="#ffffff",h.fillRect(D-S,O-S,w,w),h.fillStyle=F}}}function c(h,g,x){var b=g._segments,k=b.length,w=new Array(6),S=!0,I,D,O,R,$,U,z,j;function F(T){if(x)T._transformCoordinates(x,w),I=w[0],D=w[1];else{var M=T._point;I=M._x,D=M._y}if(S)h.moveTo(I,D),S=!1;else{if(x)$=w[2],U=w[3];else{var W=T._handleIn;$=I+W._x,U=D+W._y}$===I&&U===D&&z===O&&j===R?h.lineTo(I,D):h.bezierCurveTo(z,j,$,U,I,D)}if(O=I,R=D,x)z=w[4],j=w[5];else{var W=T._handleOut;z=O+W._x,j=R+W._y}}for(var V=0;V<k;V++)F(b[V]);g._closed&&k>0&&F(b[0])}return{_draw:function(h,g,x,b){var k=g.dontStart,w=g.dontFinish||g.clip,S=this.getStyle(),I=S.hasFill(),D=S.hasStroke(),O=S.getDashArray(),R=!ye.support.nativeDash&&D&&O&&O.length;k||h.beginPath(),(I||D&&!R||w)&&(c(h,this,b),this._closed&&h.closePath());function $(T){return O[(T%R+R)%R]}if(!w&&(I||D)&&(this._setStyles(h,g,x),I&&(h.fill(S.getFillRule()),h.shadowColor="rgba(0,0,0,0)"),D)){if(R){k||h.beginPath();for(var U=new zt(this,.25,32,!1,b),z=U.length,j=-S.getDashOffset(),F,V=0;j>0;)j-=$(V--)+$(V--);for(;j<z;)F=j+$(V++),(j>0||F>0)&&U.drawPart(h,Math.max(j,0),Math.max(F,0)),j=F+$(V++)}h.stroke()}},_drawSelected:function(h,g){h.beginPath(),c(h,this,g),h.stroke(),i(h,this._segments,g,ye.settings.handleSize)}}},new function(){function i(c){var h=c._segments;if(!h.length)throw new Error("Use a moveTo() command first");return h[h.length-1]}return{moveTo:function(){var c=this._segments;c.length===1&&this.removeSegment(0),c.length||this._add([new yt(d.read(arguments))])},moveBy:function(){throw new Error("moveBy() is unsupported on Path items.")},lineTo:function(){this._add([new yt(d.read(arguments))])},cubicCurveTo:function(){var c=arguments,h=d.read(c),g=d.read(c),x=d.read(c),b=i(this);b.setHandleOut(h.subtract(b._point)),this._add([new yt(x,g.subtract(x))])},quadraticCurveTo:function(){var c=arguments,h=d.read(c),g=d.read(c),x=i(this)._point;this.cubicCurveTo(h.add(x.subtract(h).multiply(1/3)),h.add(g.subtract(h).multiply(1/3)),g)},curveTo:function(){var c=arguments,h=d.read(c),g=d.read(c),x=s.pick(s.read(c),.5),b=1-x,k=i(this)._point,w=h.subtract(k.multiply(b*b)).subtract(g.multiply(x*x)).divide(2*x*b);if(w.isNaN())throw new Error("Cannot put a curve through points with parameter = "+x);this.quadraticCurveTo(w,g)},arcTo:function(){var c=arguments,h=Math.abs,g=Math.sqrt,x=i(this),b=x._point,k=d.read(c),w,S=s.peek(c),I=s.pick(S,!0),D,O,R,$;if(typeof I=="boolean")var U=b.add(k).divide(2),w=U.add(U.subtract(b).rotate(I?-90:90));else if(s.remain(c)<=2)w=k,k=d.read(c);else if(!b.equals(k)){var z=_.read(c),j=f.isZero;if(j(z.width)||j(z.height))return this.lineTo(k);var F=s.read(c),I=!!s.read(c),V=!!s.read(c),U=b.add(k).divide(2),T=b.subtract(U).rotate(-F),M=T.x,W=T.y,q=h(z.width),G=h(z.height),J=q*q,nt=G*G,ot=M*M,at=W*W,lt=g(ot/J+at/nt);if(lt>1&&(q*=lt,G*=lt,J=q*q,nt=G*G),lt=(J*nt-J*at-nt*ot)/(J*at+nt*ot),h(lt)<1e-12&&(lt=0),lt<0)throw new Error("Cannot create an arc with the given arguments");D=new d(q*W/G,-G*M/q).multiply((V===I?-1:1)*g(lt)).rotate(F).add(U),$=new A().translate(D).rotate(F).scale(q,G),R=$._inverseTransform(b),O=R.getDirectedAngle($._inverseTransform(k)),!I&&O>0?O-=360:I&&O<0&&(O+=360)}if(w){var pt=new B(b.add(w).divide(2),w.subtract(b).rotate(90),!0),ut=new B(w.add(k).divide(2),k.subtract(w).rotate(90),!0),gt=new B(b,k),bt=gt.getSide(w);if(D=pt.intersect(ut,!0),!D){if(!bt)return this.lineTo(k);throw new Error("Cannot create an arc with the given arguments")}R=b.subtract(D),O=R.getDirectedAngle(k.subtract(D));var kt=gt.getSide(D,!0);kt===0?O=bt*h(O):bt===kt&&(O+=O<0?360:-360)}if(O){for(var Rt=1e-7,Wt=h(O),Kt=Wt>=360?4:Math.ceil((Wt-Rt)/90),Yt=O/Kt,Et=Yt*Math.PI/360,Pt=4/3*Math.sin(Et)/(1+Math.cos(Et)),Ut=[],se=0;se<=Kt;se++){var T=k,Jt=null;if(se<Kt&&(Jt=R.rotate(90).multiply(Pt),$?(T=$._transformPoint(R),Jt=$._transformPoint(R.add(Jt)).subtract(T)):T=D.add(R)),!se)x.setHandleOut(Jt);else{var de=R.rotate(-90).multiply(Pt);$&&(de=$._transformPoint(R.add(de)).subtract(T)),Ut.push(new yt(T,de,Jt))}R=R.rotate(Yt)}this._add(Ut)}},lineBy:function(){var c=d.read(arguments),h=i(this)._point;this.lineTo(h.add(c))},curveBy:function(){var c=arguments,h=d.read(c),g=d.read(c),x=s.read(c),b=i(this)._point;this.curveTo(b.add(h),b.add(g),x)},cubicCurveBy:function(){var c=arguments,h=d.read(c),g=d.read(c),x=d.read(c),b=i(this)._point;this.cubicCurveTo(b.add(h),b.add(g),b.add(x))},quadraticCurveBy:function(){var c=arguments,h=d.read(c),g=d.read(c),x=i(this)._point;this.quadraticCurveTo(x.add(h),x.add(g))},arcBy:function(){var c=arguments,h=i(this)._point,g=h.add(d.read(c)),x=s.pick(s.peek(c),!0);typeof x=="boolean"?this.arcTo(g,x):this.arcTo(g,h.add(d.read(c)))},closePath:function(c){this.setClosed(!0),this.join(this,c)}}},{_getBounds:function(i,c){var h=c.handle?"getHandleBounds":c.stroke?"getStrokeBounds":"getBounds";return Ct[h](this._segments,this._closed,this,i,c)},statics:{getBounds:function(i,c,h,g,x,b){var k=i[0];if(!k)return new C;var w=new Array(6),S=k._transformCoordinates(g,new Array(6)),I=S.slice(0,2),D=I.slice(),O=new Array(2);function R(z){z._transformCoordinates(g,w);for(var j=0;j<2;j++)ht._addBounds(S[j],S[j+4],w[j+2],w[j],j,b?b[j]:0,I,D,O);var F=S;S=w,w=F}for(var $=1,U=i.length;$<U;$++)R(i[$]);return c&&R(k),new C(I[0],I[1],D[0]-I[0],D[1]-I[1])},getStrokeBounds:function(i,c,h,g,x){var b=h.getStyle(),k=b.hasStroke(),w=b.getStrokeWidth(),S=k&&h._getStrokeMatrix(g,x),I=k&&Ct._getStrokePadding(w,S),D=Ct.getBounds(i,c,h,g,x,I);if(!k)return D;var O=w/2,R=b.getStrokeJoin(),$=b.getStrokeCap(),U=b.getMiterLimit(),z=new C(new _(I));function j(q){D=D.include(q)}function F(q){D=D.unite(z.setCenter(q._point.transform(g)))}function V(q,G){G==="round"||q.isSmooth()?F(q):Ct._addBevelJoin(q,G,O,U,g,S,j)}function T(q,G){G==="round"?F(q):Ct._addSquareCap(q,G,O,g,S,j)}var M=i.length-(c?0:1);if(M>0){for(var W=1;W<M;W++)V(i[W],R);c?V(i[0],R):(T(i[0],$),T(i[i.length-1],$))}return D},_getStrokePadding:function(i,c){if(!c)return[i,i];var h=new d(i,0).transform(c),g=new d(0,i).transform(c),x=h.getAngleInRadians(),b=h.getLength(),k=g.getLength(),w=Math.sin(x),S=Math.cos(x),I=Math.tan(x),D=Math.atan2(k*I,b),O=Math.atan2(k,I*b);return[Math.abs(b*Math.cos(D)*S+k*Math.sin(D)*w),Math.abs(k*Math.sin(O)*S+b*Math.cos(O)*w)]},_addBevelJoin:function(i,c,h,g,x,b,k,w){var S=i.getCurve(),I=S.getPrevious(),D=S.getPoint1().transform(x),O=I.getNormalAtTime(1).multiply(h).transform(b),R=S.getNormalAtTime(0).multiply(h).transform(b),$=O.getDirectedAngle(R);if(($<0||$>=180)&&(O=O.negate(),R=R.negate()),w&&k(D),k(D.add(O)),c==="miter"){var U=new B(D.add(O),new d(-O.y,O.x),!0).intersect(new B(D.add(R),new d(-R.y,R.x),!0),!0);U&&D.getDistance(U)<=g*h&&k(U)}k(D.add(R))},_addSquareCap:function(i,c,h,g,x,b,k){var w=i._point.transform(g),S=i.getLocation(),I=S.getNormal().multiply(S.getTime()===0?h:-h).transform(x);c==="square"&&(k&&(b(w.subtract(I)),b(w.add(I))),w=w.add(I.rotate(-90))),b(w.add(I)),b(w.subtract(I))},getHandleBounds:function(i,c,h,g,x){var b=h.getStyle(),k=x.stroke&&b.hasStroke(),w,S;if(k){var I=h._getStrokeMatrix(g,x),D=b.getStrokeWidth()/2,O=D;b.getStrokeJoin()==="miter"&&(O=D*b.getMiterLimit()),b.getStrokeCap()==="square"&&(O=Math.max(O,D*Math.SQRT2)),w=Ct._getStrokePadding(D,I),S=Ct._getStrokePadding(O,I)}for(var R=new Array(6),$=Infinity,U=-$,z=$,j=U,F=0,V=i.length;F<V;F++){var T=i[F];T._transformCoordinates(g,R);for(var M=0;M<6;M+=2){var W=M?w:S,q=W?W[0]:0,G=W?W[1]:0,J=R[M],nt=R[M+1],ot=J-q,at=J+q,lt=nt-G,pt=nt+G;ot<$&&($=ot),at>U&&(U=at),lt<z&&(z=lt),pt>j&&(j=pt)}}return new C($,z,U-$,j-z)}}});Ct.inject({statics:new function(){var i=.5522847498307936,c=[new yt([-1,0],[0,i],[0,-i]),new yt([0,-1],[-i,0],[i,0]),new yt([1,0],[0,-i],[0,i]),new yt([0,1],[i,0],[-i,0])];function h(x,b,k){var w=s.getNamed(k),S=new Ct(w&&w.insert==!1&&L.NO_INSERT);return S._add(x),S._closed=b,S.set(w,{insert:!0})}function g(x,b,k){for(var w=new Array(4),S=0;S<4;S++){var I=c[S];w[S]=new yt(I._point.multiply(b).add(x),I._handleIn.multiply(b),I._handleOut.multiply(b))}return h(w,!0,k)}return{Line:function(){var x=arguments;return h([new yt(d.readNamed(x,"from")),new yt(d.readNamed(x,"to"))],!1,x)},Circle:function(){var x=arguments,b=d.readNamed(x,"center"),k=s.readNamed(x,"radius");return g(b,new _(k),x)},Rectangle:function(){var x=arguments,b=C.readNamed(x,"rectangle"),k=_.readNamed(x,"radius",0,{readNull:!0}),w=b.getBottomLeft(!0),S=b.getTopLeft(!0),I=b.getTopRight(!0),D=b.getBottomRight(!0),O;if(!k||k.isZero())O=[new yt(w),new yt(S),new yt(I),new yt(D)];else{k=_.min(k,b.getSize(!0).divide(2));var R=k.width,$=k.height,U=R*i,z=$*i;O=[new yt(w.add(R,0),null,[-U,0]),new yt(w.subtract(0,$),[0,z]),new yt(S.add(0,$),null,[0,-z]),new yt(S.add(R,0),[-U,0],null),new yt(I.subtract(R,0),null,[U,0]),new yt(I.add(0,$),[0,-z],null),new yt(D.subtract(0,$),null,[0,z]),new yt(D.subtract(R,0),[U,0])]}return h(O,!0,x)},RoundRectangle:"#Rectangle",Ellipse:function(){var x=arguments,b=et._readEllipse(x);return g(b.center,b.radius,x)},Oval:"#Ellipse",Arc:function(){var x=arguments,b=d.readNamed(x,"from"),k=d.readNamed(x,"through"),w=d.readNamed(x,"to"),S=s.getNamed(x),I=new Ct(S&&S.insert==!1&&L.NO_INSERT);return I.moveTo(b),I.arcTo(k,w),I.set(S)},RegularPolygon:function(){for(var x=arguments,b=d.readNamed(x,"center"),k=s.readNamed(x,"sides"),w=s.readNamed(x,"radius"),S=360/k,I=k%3==0,D=new d(0,I?-w:w),O=I?-1:.5,R=new Array(k),$=0;$<k;$++)R[$]=new yt(b.add(D.rotate(($+O)*S)));return h(R,!0,x)},Star:function(){for(var x=arguments,b=d.readNamed(x,"center"),k=s.readNamed(x,"points")*2,w=s.readNamed(x,"radius1"),S=s.readNamed(x,"radius2"),I=360/k,D=new d(0,-1),O=new Array(k),R=0;R<k;R++)O[R]=new yt(b.add(D.rotate(I*R).multiply(R%2?S:w)));return h(O,!0,x)}}}});var Dt=Ft.extend({_class:"CompoundPath",_serializeFields:{children:[]},beans:!0,initialize:function(c){this._children=[],this._namedChildren={},this._initialize(c)||(typeof c=="string"?this.setPathData(c):this.addChildren(Array.isArray(c)?c:arguments))},insertChildren:function i(c,h){var g=h,x=g[0];x&&typeof x[0]=="number"&&(g=[g]);for(var b=h.length-1;b>=0;b--){var k=g[b];g===h&&!(k instanceof Ct)&&(g=s.slice(g)),Array.isArray(k)?g[b]=new Ct({segments:k,insert:!1}):k instanceof Dt&&(g.splice.apply(g,[b,1].concat(k.removeChildren())),k.remove())}return i.base.call(this,c,g)},reduce:function i(c){for(var h=this._children,g=h.length-1;g>=0;g--){var x=h[g].reduce(c);x.isEmpty()&&x.remove()}if(!h.length){var x=new Ct(L.NO_INSERT);return x.copyAttributes(this),x.insertAbove(this),this.remove(),x}return i.base.call(this)},isClosed:function(){for(var i=this._children,c=0,h=i.length;c<h;c++)if(!i[c]._closed)return!1;return!0},setClosed:function(i){for(var c=this._children,h=0,g=c.length;h<g;h++)c[h].setClosed(i)},getFirstSegment:function(){var i=this.getFirstChild();return i&&i.getFirstSegment()},getLastSegment:function(){var i=this.getLastChild();return i&&i.getLastSegment()},getCurves:function(){for(var i=this._children,c=[],h=0,g=i.length;h<g;h++)s.push(c,i[h].getCurves());return c},getFirstCurve:function(){var i=this.getFirstChild();return i&&i.getFirstCurve()},getLastCurve:function(){var i=this.getLastChild();return i&&i.getLastCurve()},getArea:function(){for(var i=this._children,c=0,h=0,g=i.length;h<g;h++)c+=i[h].getArea();return c},getLength:function(){for(var i=this._children,c=0,h=0,g=i.length;h<g;h++)c+=i[h].getLength();return c},getPathData:function(i,c){for(var h=this._children,g=[],x=0,b=h.length;x<b;x++){var k=h[x],w=k._matrix;g.push(k.getPathData(i&&!w.isIdentity()?i.appended(w):i,c))}return g.join("")},_hitTestChildren:function i(c,h,g){return i.base.call(this,c,h.class===Ct||h.type==="path"?h:s.set({},h,{fill:!1}),g)},_draw:function(i,c,h,g){var x=this._children;if(!!x.length){c=c.extend({dontStart:!0,dontFinish:!0}),i.beginPath();for(var b=0,k=x.length;b<k;b++)x[b].draw(i,c,g);if(!c.clip){this._setStyles(i,c,h);var w=this._style;w.hasFill()&&(i.fill(w.getFillRule()),i.shadowColor="rgba(0,0,0,0)"),w.hasStroke()&&i.stroke()}}},_drawSelected:function(i,c,h){for(var g=this._children,x=0,b=g.length;x<b;x++){var k=g[x],w=k._matrix;h[k._id]||k._drawSelected(i,w.isIdentity()?c:c.appended(w))}}},new function(){function i(c,h){var g=c._children;if(h&&!g.length)throw new Error("Use a moveTo() command first");return g[g.length-1]}return s.each(["lineTo","cubicCurveTo","quadraticCurveTo","curveTo","arcTo","lineBy","cubicCurveBy","quadraticCurveBy","curveBy","arcBy"],function(c){this[c]=function(){var h=i(this,!0);h[c].apply(h,arguments)}},{moveTo:function(){var c=i(this),h=c&&c.isEmpty()?c:new Ct(L.NO_INSERT);h!==c&&this.addChild(h),h.moveTo.apply(h,arguments)},moveBy:function(){var c=i(this,!0),h=c&&c.getLastSegment(),g=d.read(arguments);this.moveTo(h?g.add(h._point):g)},closePath:function(c){i(this,!0).closePath(c)}})},s.each(["reverse","flatten","simplify","smooth"],function(i){this[i]=function(c){for(var h=this._children,g,x=0,b=h.length;x<b;x++)g=h[x][i](c)||g;return g}},{}));Ft.inject(new function(){var i=Math.min,c=Math.max,h=Math.abs,g={unite:{"1":!0,"2":!0},intersect:{"2":!0},subtract:{"1":!0},exclude:{"1":!0,"-1":!0}};function x(F){return F._children||[F]}function b(F,V){var T=F.clone(!1).reduce({simplify:!0}).transform(null,!0,!0);if(V){for(var M=x(T),W=0,q=M.length;W<q;W++){var F=M[W];!F._closed&&!F.isEmpty()&&(F.closePath(1e-12),F.getFirstSegment().setHandleIn(0,0),F.getLastSegment().setHandleOut(0,0))}T=T.resolveCrossings().reorient(T.getFillRule()==="nonzero",!0)}return T}function k(F,V,T,M,W){var q=new Dt(L.NO_INSERT);return q.addChildren(F,!0),q=q.reduce({simplify:V}),W&&W.insert==!1||q.insertAbove(M&&T.isSibling(M)&&T.getIndex()<M.getIndex()?M:T),q.copyAttributes(T,!0),q}function w(F){return F.hasOverlap()||F.isCrossing()}function S(F,V,T,M){if(M&&(M.trace==!1||M.stroke)&&/^(subtract|intersect)$/.test(T))return I(F,V,T);var W=b(F,!0),q=V&&F!==V&&b(V,!0),G=g[T];G[T]=!0,q&&(G.subtract||G.exclude)^(q.isClockwise()^W.isClockwise())&&q.reverse();var J=$(It.expand(W.getIntersections(q,w))),nt=x(W),ot=q&&x(q),at=[],lt=[],pt;function ut(Jt){for(var de=0,me=Jt.length;de<me;de++){var Se=Jt[de];s.push(at,Se._segments),s.push(lt,Se.getCurves()),Se._overlapsOnly=!0}}function gt(Jt){for(var de=[],me=0,Se=Jt&&Jt.length;me<Se;me++)de.push(lt[Jt[me]]);return de}if(J.length){ut(nt),ot&&ut(ot);for(var bt=new Array(lt.length),kt=0,Rt=lt.length;kt<Rt;kt++)bt[kt]=lt[kt].getValues();for(var Wt=u.findCurveBoundsCollisions(bt,bt,0,!0),Kt={},kt=0;kt<lt.length;kt++){var Yt=lt[kt],Et=Yt._path._id,Pt=Kt[Et]=Kt[Et]||{};Pt[Yt.getIndex()]={hor:gt(Wt[kt].hor),ver:gt(Wt[kt].ver)}}for(var kt=0,Rt=J.length;kt<Rt;kt++)z(J[kt]._segment,W,q,Kt,G);for(var kt=0,Rt=at.length;kt<Rt;kt++){var Ut=at[kt],se=Ut._intersection;Ut._winding||z(Ut,W,q,Kt,G),se&&se._overlap||(Ut._path._overlapsOnly=!1)}pt=j(at,G)}else pt=R(ot?nt.concat(ot):nt.slice(),function(Jt){return!!G[Jt]});return k(pt,!0,F,V,M)}function I(F,V,T){var M=b(F),W=b(V),q=M.getIntersections(W,w),G=T==="subtract",J=T==="divide",nt={},ot=[];function at(ut){if(!nt[ut._id]&&(J||W.contains(ut.getPointAt(ut.getLength()/2))^G))return ot.unshift(ut),nt[ut._id]=!0}for(var lt=q.length-1;lt>=0;lt--){var pt=q[lt].split();pt&&(at(pt)&&pt.getFirstSegment().setHandleIn(0,0),M.getLastSegment().setHandleOut(0,0))}return at(M),k(ot,!1,F,V)}function D(F,V){for(var T=F;T;){if(T===V)return;T=T._previous}for(;F._next&&F._next!==V;)F=F._next;if(!F._next){for(;V._previous;)V=V._previous;F._next=V,V._previous=F}}function O(F){for(var V=F.length-1;V>=0;V--)F[V].clearHandles()}function R(F,V,T){var M=F&&F.length;if(M){var W=s.each(F,function(Wt,Kt){this[Wt._id]={container:null,winding:Wt.isClockwise()?1:-1,index:Kt}},{}),q=F.slice().sort(function(Wt,Kt){return h(Kt.getArea())-h(Wt.getArea())}),G=q[0],J=u.findItemBoundsCollisions(q,null,f.GEOMETRIC_EPSILON);T==null&&(T=G.isClockwise());for(var nt=0;nt<M;nt++){var ot=q[nt],at=W[ot._id],lt=0,pt=J[nt];if(pt){for(var ut=null,gt=pt.length-1;gt>=0;gt--)if(pt[gt]<nt){ut=ut||ot.getInteriorPoint();var bt=q[pt[gt]];if(bt.contains(ut)){var kt=W[bt._id];lt=kt.winding,at.winding+=lt,at.container=kt.exclude?kt.container:bt;break}}}if(V(at.winding)===V(lt))at.exclude=!0,F[at.index]=null;else{var Rt=at.container;ot.setClockwise(Rt?!Rt.isClockwise():T)}}}return F}function $(F,V,T){var M=V&&[],W=1e-8,q=1-W,G=!1,J=T||[],nt=T&&{},ot,at,lt;function pt(de){return de._path._id+"."+de._segment1._index}for(var ut=(T&&T.length)-1;ut>=0;ut--){var gt=T[ut];gt._path&&(nt[pt(gt)]=!0)}for(var ut=F.length-1;ut>=0;ut--){var bt=F[ut],kt=bt._time,Rt=kt,Wt=V&&!V(bt),gt=bt._curve,Kt;if(gt&&(gt!==at?(G=!gt.hasHandles()||nt&&nt[pt(gt)],ot=[],lt=null,at=gt):lt>=W&&(kt/=lt)),Wt){ot&&ot.push(bt);continue}else V&&M.unshift(bt);if(lt=Rt,kt<W)Kt=gt._segment1;else if(kt>q)Kt=gt._segment2;else{var Yt=gt.divideAtTime(kt,!0);G&&J.push(gt,Yt),Kt=Yt._segment1;for(var Et=ot.length-1;Et>=0;Et--){var Pt=ot[Et];Pt._time=(Pt._time-kt)/(1-kt)}}bt._setSegment(Kt);var Ut=Kt._intersection,se=bt._intersection;if(Ut){D(Ut,se);for(var Jt=Ut;Jt;)D(Jt._intersection,Ut),Jt=Jt._next}else Kt._intersection=se}return T||O(J),M||F}function U(F,V,T,M,W){var q=Array.isArray(V)?V:V[T?"hor":"ver"],G=T?1:0,J=G^1,nt=[F.x,F.y],ot=nt[G],at=nt[J],lt=1e-9,pt=1e-6,ut=ot-lt,gt=ot+lt,bt=0,kt=0,Rt=0,Wt=0,Kt=!1,Yt=!1,Et=1,Pt=[],Ut,se;function Jt(ir){var Er=ir[J+0],En=ir[J+6];if(!(at<i(Er,En)||at>c(Er,En))){var Mr=ir[G+0],Xn=ir[G+2],_i=ir[G+4],hs=ir[G+6];if(Er===En){(Mr<gt&&hs>ut||hs<gt&&Mr>ut)&&(Kt=!0);return}var ms=at===Er?0:at===En||ut>c(Mr,Xn,_i,hs)||gt<i(Mr,Xn,_i,hs)?1:ht.solveCubic(ir,J,at,Pt,0,1)>0?Pt[0]:1,An=ms===0?Mr:ms===1?hs:ht.getPoint(ir,ms)[T?"y":"x"],Ln=Er>En?1:-1,bi=Ut[J]>Ut[J+6]?1:-1,ds=Ut[G+6];return at!==Er?(An<ut?Rt+=Ln:An>gt?Wt+=Ln:Kt=!0,An>ot-pt&&An<ot+pt&&(Et/=2)):(Ln!==bi?Mr<ut?Rt+=Ln:Mr>gt&&(Wt+=Ln):Mr!=ds&&(ds<gt&&An>gt?(Wt+=Ln,Kt=!0):ds>ut&&An<ut&&(Rt+=Ln,Kt=!0)),Et/=4),Ut=ir,!W&&An>ut&&An<gt&&ht.getTangent(ir,ms)[T?"x":"y"]===0&&U(F,V,!T,M,!0)}}function de(ir){var Er=ir[J+0],En=ir[J+2],Mr=ir[J+4],Xn=ir[J+6];if(at<=c(Er,En,Mr,Xn)&&at>=i(Er,En,Mr,Xn)){for(var _i=ir[G+0],hs=ir[G+2],ms=ir[G+4],An=ir[G+6],Ln=ut>c(_i,hs,ms,An)||gt<i(_i,hs,ms,An)?[ir]:ht.getMonoCurves(ir,T),bi,ds=0,If=Ln.length;ds<If;ds++)if(bi=Jt(Ln[ds]))return bi}}for(var me=0,Se=q.length;me<Se;me++){var Ee=q[me],ke=Ee._path,Lr=Ee.getValues(),zr;if((!me||q[me-1]._path!==ke)&&(Ut=null,ke._closed||(se=ht.getValues(ke.getLastCurve().getSegment2(),Ee.getSegment1(),null,!M),se[J]!==se[J+6]&&(Ut=se)),!Ut)){Ut=Lr;for(var en=ke.getLastCurve();en&&en!==Ee;){var Tr=en.getValues();if(Tr[J]!==Tr[J+6]){Ut=Tr;break}en=en.getPrevious()}}if(zr=de(Lr))return zr;if(me+1===Se||q[me+1]._path!==ke){if(se&&(zr=de(se)))return zr;Kt&&!Rt&&!Wt&&(Rt=Wt=ke.isClockwise(M)^T?1:-1),bt+=Rt,kt+=Wt,Rt=Wt=0,Kt&&(Yt=!0,Kt=!1),se=null}}return bt=h(bt),kt=h(kt),{winding:c(bt,kt),windingL:bt,windingR:kt,quality:Et,onPath:Yt}}function z(F,V,T,M,W){var q=[],G=F,J=0,nt;do{var ot=F.getCurve();if(ot){var at=ot.getLength();q.push({segment:F,curve:ot,length:at}),J+=at}F=F.getNext()}while(F&&!F._intersection&&F!==G);for(var lt=[.5,.25,.75],nt={winding:0,quality:-1},pt=.001,ut=1-pt,gt=0;gt<lt.length&&nt.quality<.5;gt++)for(var at=J*lt[gt],bt=0,kt=q.length;bt<kt;bt++){var Rt=q[bt],Wt=Rt.length;if(at<=Wt){var ot=Rt.curve,Kt=ot._path,Yt=Kt._parent,Et=Yt instanceof Dt?Yt:Kt,Pt=f.clamp(ot.getTimeAt(at),pt,ut),Ut=ot.getPointAtTime(Pt),se=h(ot.getTangentAtTime(Pt).y)<Math.SQRT1_2,Jt=null;if(W.subtract&&T){var de=Et===V?T:V,me=de._getWinding(Ut,se,!0);if(Et===V&&me.winding||Et===T&&!me.winding){if(me.quality<1)continue;Jt={winding:0,quality:1}}}Jt=Jt||U(Ut,M[Kt._id][ot.getIndex()],se,!0),Jt.quality>nt.quality&&(nt=Jt);break}at-=Wt}for(var bt=q.length-1;bt>=0;bt--)q[bt].segment._winding=nt}function j(F,V){var T=[],M;function W(Se){var Ee;return!!(Se&&!Se._visited&&(!V||V[(Ee=Se._winding||{}).winding]&&!(V.unite&&Ee.winding===2&&Ee.windingL&&Ee.windingR)))}function q(Se){if(Se){for(var Ee=0,ke=M.length;Ee<ke;Ee++)if(Se===M[Ee])return!0}return!1}function G(Se){for(var Ee=Se._segments,ke=0,Lr=Ee.length;ke<Lr;ke++)Ee[ke]._visited=!0}function J(Se,Ee){var ke=Se._intersection,Lr=ke,zr=[];Ee&&(M=[Se]);function en(Tr,ir){for(;Tr&&Tr!==ir;){var Er=Tr._segment,En=Er&&Er._path;if(En){var Mr=Er.getNext()||En.getFirstSegment(),Xn=Mr._intersection;Er!==Se&&(q(Er)||q(Mr)||Mr&&W(Er)&&(W(Mr)||Xn&&W(Xn._segment)))&&zr.push(Er),Ee&&M.push(Er)}Tr=Tr._next}}if(ke){for(en(ke);ke&&ke._previous;)ke=ke._previous;en(ke,Lr)}return zr}F.sort(function(Se,Ee){var ke=Se._intersection,Lr=Ee._intersection,zr=!!(ke&&ke._overlap),en=!!(Lr&&Lr._overlap),Tr=Se._path,ir=Ee._path;return zr^en?zr?1:-1:!ke^!Lr?ke?1:-1:Tr!==ir?Tr._id-ir._id:Se._index-Ee._index});for(var nt=0,ot=F.length;nt<ot;nt++){var at=F[nt],lt=W(at),pt=null,ut=!1,gt=!0,bt=[],kt,Rt,Wt;if(lt&&at._path._overlapsOnly){var Kt=at._path,Yt=at._intersection._segment._path;Kt.compare(Yt)&&(Kt.getArea()&&T.push(Kt.clone(!1)),G(Kt),G(Yt),lt=!1)}for(;lt;){var Et=!pt,Pt=J(at,Et),Ut=Pt.shift(),ut=!Et&&(q(at)||q(Ut)),se=!ut&&Ut;if(Et&&(pt=new Ct(L.NO_INSERT),kt=null),ut){(at.isFirst()||at.isLast())&&(gt=at._path._closed),at._visited=!0;break}if(se&&kt&&(bt.push(kt),kt=null),kt||(se&&Pt.push(at),kt={start:pt._segments.length,crossings:Pt,visited:Rt=[],handleIn:Wt}),se&&(at=Ut),!W(at)){pt.removeSegments(kt.start);for(var Jt=0,de=Rt.length;Jt<de;Jt++)Rt[Jt]._visited=!1;Rt.length=0;do at=kt&&kt.crossings.shift(),(!at||!at._path)&&(at=null,kt=bt.pop(),kt&&(Rt=kt.visited,Wt=kt.handleIn));while(kt&&!W(at));if(!at)break}var me=at.getNext();pt.add(new yt(at._point,Wt,me&&at._handleOut)),at._visited=!0,Rt.push(at),at=me||at._path.getFirstSegment(),Wt=me&&me._handleIn}ut&&(gt&&(pt.getFirstSegment().setHandleIn(Wt),pt.setClosed(gt)),pt.getArea()!==0&&T.push(pt))}return T}return{_getWinding:function(F,V,T){return U(F,this.getCurves(),V,T)},unite:function(F,V){return S(this,F,"unite",V)},intersect:function(F,V){return S(this,F,"intersect",V)},subtract:function(F,V){return S(this,F,"subtract",V)},exclude:function(F,V){return S(this,F,"exclude",V)},divide:function(F,V){return V&&(V.trace==!1||V.stroke)?I(this,F,"divide"):k([this.subtract(F,V),this.intersect(F,V)],!0,this,F,V)},resolveCrossings:function(){var F=this._children,V=F||[this];function T(kt,Rt){var Wt=kt&&kt._intersection;return Wt&&Wt._overlap&&Wt._path===Rt}var M=!1,W=!1,q=this.getIntersections(null,function(kt){return kt.hasOverlap()&&(M=!0)||kt.isCrossing()&&(W=!0)}),G=M&&W&&[];if(q=It.expand(q),M)for(var J=$(q,function(kt){return kt.hasOverlap()},G),nt=J.length-1;nt>=0;nt--){var ot=J[nt],at=ot._path,lt=ot._segment,pt=lt.getPrevious(),ut=lt.getNext();T(pt,at)&&T(ut,at)&&(lt.remove(),pt._handleOut._set(0,0),ut._handleIn._set(0,0),pt!==lt&&!pt.getCurve().hasLength()&&(ut._handleIn.set(pt._handleIn),pt.remove()))}W&&($(q,M&&function(kt){var Rt=kt.getCurve(),Wt=kt.getSegment(),Kt=kt._intersection,Yt=Kt._curve,Et=Kt._segment;if(Rt&&Yt&&Rt._path&&Yt._path)return!0;Wt&&(Wt._intersection=null),Et&&(Et._intersection=null)},G),G&&O(G),V=j(s.each(V,function(kt){s.push(this,kt._segments)},[])));var gt=V.length,bt;return gt>1&&F?(V!==F&&this.setChildren(V),bt=this):gt===1&&!F&&(V[0]!==this&&this.setSegments(V[0].removeSegments()),bt=this),bt||(bt=new Dt(L.NO_INSERT),bt.addChildren(V),bt=bt.reduce(),bt.copyAttributes(this),this.replaceWith(bt)),bt},reorient:function(F,V){var T=this._children;return T&&T.length?this.setChildren(R(this.removeChildren(),function(M){return!!(F?M:M&1)},V)):V!==t&&this.setClockwise(V),this},getInteriorPoint:function(){var F=this.getBounds(),V=F.getCenter(!0);if(!this.contains(V)){for(var T=this.getCurves(),M=V.y,W=[],q=[],G=0,J=T.length;G<J;G++){var nt=T[G].getValues(),ot=nt[1],at=nt[3],lt=nt[5],pt=nt[7];if(M>=i(ot,at,lt,pt)&&M<=c(ot,at,lt,pt))for(var ut=ht.getMonoCurves(nt),gt=0,bt=ut.length;gt<bt;gt++){var kt=ut[gt],Rt=kt[1],Wt=kt[7];if(Rt!==Wt&&(M>=Rt&&M<=Wt||M>=Wt&&M<=Rt)){var Kt=M===Rt?kt[0]:M===Wt?kt[6]:ht.solveCubic(kt,1,M,q,0,1)===1?ht.getPoint(kt,q[0]).x:(kt[0]+kt[6])/2;W.push(Kt)}}}W.length>1&&(W.sort(function(Yt,Et){return Yt-Et}),V.x=(W[0]+W[1])/2)}return V}}});var zt=s.extend({_class:"PathFlattener",initialize:function(i,c,h,g,x){var b=[],k=[],w=0,S=1/(h||32),I=i._segments,D=I[0],O;function R(j,F){var V=ht.getValues(j,F,x);b.push(V),$(V,j._index,0,1)}function $(j,F,V,T){if(T-V>S&&!(g&&ht.isStraight(j))&&!ht.isFlatEnough(j,c||.25)){var M=ht.subdivide(j,.5),W=(V+T)/2;$(M[0],F,V,W),$(M[1],F,W,T)}else{var q=j[6]-j[0],G=j[7]-j[1],J=Math.sqrt(q*q+G*G);J>0&&(w+=J,k.push({offset:w,curve:j,index:F,time:T}))}}for(var U=1,z=I.length;U<z;U++)O=I[U],R(D,O),D=O;i._closed&&R(O||D,I[0]),this.curves=b,this.parts=k,this.length=w,this.index=0},_get:function(i){for(var c=this.parts,h=c.length,g,x,b=this.index;x=b,!(!b||c[--b].offset<i););for(;x<h;x++){var k=c[x];if(k.offset>=i){this.index=x;var w=c[x-1],S=w&&w.index===k.index?w.time:0,I=w?w.offset:0;return{index:k.index,time:S+(k.time-S)*(i-I)/(k.offset-I)}}}return{index:c[h-1].index,time:1}},drawPart:function(i,c,h){for(var g=this._get(c),x=this._get(h),b=g.index,k=x.index;b<=k;b++){var w=ht.getPart(this.curves[b],b===g.index?g.time:0,b===x.index?x.time:1);b===g.index&&i.moveTo(w[0],w[1]),i.bezierCurveTo.apply(i,w.slice(2))}}},s.each(ht._evaluateMethods,function(i){this[i+"At"]=function(c){var h=this._get(c);return ht[i](this.curves[h.index],h.time)}},{})),Mt=s.extend({initialize:function(i){for(var c=this.points=[],h=i._segments,g=i._closed,x=0,b,k=h.length;x<k;x++){var w=h[x].point;(!b||!b.equals(w))&&c.push(b=w.clone())}g&&(c.unshift(c[c.length-1]),c.push(c[1])),this.closed=g},fit:function(i){var c=this.points,h=c.length,g=null;return h>0&&(g=[new yt(c[0])],h>1&&(this.fitCubic(g,i,0,h-1,c[1].subtract(c[0]),c[h-2].subtract(c[h-1])),this.closed&&(g.shift(),g.pop()))),g},fitCubic:function(i,c,h,g,x,b){var k=this.points;if(g-h==1){var w=k[h],S=k[g],I=w.getDistance(S)/3;this.addCurve(i,[w,w.add(x.normalize(I)),S.add(b.normalize(I)),S]);return}for(var D=this.chordLengthParameterize(h,g),O=Math.max(c,c*c),R,$=!0,U=0;U<=4;U++){var z=this.generateBezier(h,g,D,x,b),j=this.findMaxError(h,g,z,D);if(j.error<c&&$){this.addCurve(i,z);return}if(R=j.index,j.error>=O)break;$=this.reparameterize(h,g,D,z),O=j.error}var F=k[R-1].subtract(k[R+1]);this.fitCubic(i,c,h,R,x,F),this.fitCubic(i,c,R,g,F.negate(),b)},addCurve:function(i,c){var h=i[i.length-1];h.setHandleOut(c[1].subtract(c[0])),i.push(new yt(c[3],c[2].subtract(c[3])))},generateBezier:function(i,c,h,g,x){for(var b=1e-12,k=Math.abs,w=this.points,S=w[i],I=w[c],D=[[0,0],[0,0]],O=[0,0],R=0,$=c-i+1;R<$;R++){var U=h[R],z=1-U,j=3*U*z,F=z*z*z,V=j*z,T=j*U,M=U*U*U,W=g.normalize(V),q=x.normalize(T),G=w[i+R].subtract(S.multiply(F+V)).subtract(I.multiply(T+M));D[0][0]+=W.dot(W),D[0][1]+=W.dot(q),D[1][0]=D[0][1],D[1][1]+=q.dot(q),O[0]+=W.dot(G),O[1]+=q.dot(G)}var J=D[0][0]*D[1][1]-D[1][0]*D[0][1],nt,ot;if(k(J)>b){var at=D[0][0]*O[1]-D[1][0]*O[0],lt=O[0]*D[1][1]-O[1]*D[0][1];nt=lt/J,ot=at/J}else{var pt=D[0][0]+D[0][1],ut=D[1][0]+D[1][1];nt=ot=k(pt)>b?O[0]/pt:k(ut)>b?O[1]/ut:0}var gt=I.getDistance(S),bt=b*gt,kt,Rt;if(nt<bt||ot<bt)nt=ot=gt/3;else{var Wt=I.subtract(S);kt=g.normalize(nt),Rt=x.normalize(ot),kt.dot(Wt)-Rt.dot(Wt)>gt*gt&&(nt=ot=gt/3,kt=Rt=null)}return[S,S.add(kt||g.normalize(nt)),I.add(Rt||x.normalize(ot)),I]},reparameterize:function(i,c,h,g){for(var x=i;x<=c;x++)h[x-i]=this.findRoot(g,this.points[x],h[x-i]);for(var x=1,b=h.length;x<b;x++)if(h[x]<=h[x-1])return!1;return!0},findRoot:function(i,c,h){for(var g=[],x=[],b=0;b<=2;b++)g[b]=i[b+1].subtract(i[b]).multiply(3);for(var b=0;b<=1;b++)x[b]=g[b+1].subtract(g[b]).multiply(2);var k=this.evaluate(3,i,h),w=this.evaluate(2,g,h),S=this.evaluate(1,x,h),I=k.subtract(c),D=w.dot(w)+I.dot(S);return f.isMachineZero(D)?h:h-I.dot(w)/D},evaluate:function(i,c,h){for(var g=c.slice(),x=1;x<=i;x++)for(var b=0;b<=i-x;b++)g[b]=g[b].multiply(1-h).add(g[b+1].multiply(h));return g[0]},chordLengthParameterize:function(i,c){for(var h=[0],g=i+1;g<=c;g++)h[g-i]=h[g-i-1]+this.points[g].getDistance(this.points[g-1]);for(var g=1,x=c-i;g<=x;g++)h[g]/=h[x];return h},findMaxError:function(i,c,h,g){for(var x=Math.floor((c-i+1)/2),b=0,k=i+1;k<c;k++){var w=this.evaluate(3,h,g[k-i]),S=w.subtract(this.points[k]),I=S.x*S.x+S.y*S.y;I>=b&&(b=I,x=k)}return{error:b,index:x}}}),jt=L.extend({_class:"TextItem",_applyMatrix:!1,_canApplyMatrix:!1,_serializeFields:{content:null},_boundsOptions:{stroke:!1,handle:!1},initialize:function(c){this._content="",this._lines=[];var h=c&&s.isPlainObject(c)&&c.x===t&&c.y===t;this._initialize(h&&c,!h&&d.read(arguments))},_equals:function(i){return this._content===i._content},copyContent:function(i){this.setContent(i._content)},getContent:function(){return this._content},setContent:function(i){this._content=""+i,this._lines=this._content.split(/\r\n|\n|\r/mg),this._changed(521)},isEmpty:function(){return!this._content},getCharacterStyle:"#getStyle",setCharacterStyle:"#setStyle",getParagraphStyle:"#getStyle",setParagraphStyle:"#setStyle"}),qt=jt.extend({_class:"PointText",initialize:function(){jt.apply(this,arguments)},getPoint:function(){var i=this._matrix.getTranslation();return new y(i.x,i.y,this,"setPoint")},setPoint:function(){var i=d.read(arguments);this.translate(i.subtract(this._matrix.getTranslation()))},_draw:function(i,c,h){if(!!this._content){this._setStyles(i,c,h);var g=this._lines,x=this._style,b=x.hasFill(),k=x.hasStroke(),w=x.getLeading(),S=i.shadowColor;i.font=x.getFontStyle(),i.textAlign=x.getJustification();for(var I=0,D=g.length;I<D;I++){i.shadowColor=S;var O=g[I];b&&(i.fillText(O,0,0),i.shadowColor="rgba(0,0,0,0)"),k&&i.strokeText(O,0,0),i.translate(0,w)}}},_getBounds:function(i,c){var h=this._style,g=this._lines,x=g.length,b=h.getJustification(),k=h.getLeading(),w=this.getView().getTextWidth(h.getFontStyle(),g),S=0;b!=="left"&&(S-=w/(b==="center"?2:1));var I=new C(S,x?-.75*k:0,w,x*k);return i?i._transformBounds(I,I):I}}),Bt=s.extend(new function(){var i={gray:["gray"],rgb:["red","green","blue"],hsb:["hue","saturation","brightness"],hsl:["hue","saturation","lightness"],gradient:["gradient","origin","destination","highlight"]},c={},h={transparent:[0,0,0,0]},g;function x(w){var S=w.match(/^#([\da-f]{2})([\da-f]{2})([\da-f]{2})([\da-f]{2})?$/i)||w.match(/^#([\da-f])([\da-f])([\da-f])([\da-f])?$/i),I="rgb",D;if(S){var O=S[4]?4:3;D=new Array(O);for(var R=0;R<O;R++){var $=S[R+1];D[R]=parseInt($.length==1?$+$:$,16)/255}}else if(S=w.match(/^(rgb|hsl)a?\((.*)\)$/)){I=S[1],D=S[2].trim().split(/[,\s]+/g);for(var U=I==="hsl",R=0,z=Math.min(D.length,4);R<z;R++){var j=D[R],$=parseFloat(j);if(U)if(R===0){var F=j.match(/([a-z]*)$/)[1];$*={turn:360,rad:180/Math.PI,grad:.9}[F]||1}else R<3&&($/=100);else R<3&&($/=/%$/.test(j)?100:255);D[R]=$}}else{var V=h[w];if(!V)if(e){g||(g=Pe.getContext(1,1),g.globalCompositeOperation="copy"),g.fillStyle="rgba(0,0,0,0)",g.fillStyle=w,g.fillRect(0,0,1,1);var T=g.getImageData(0,0,1,1).data;V=h[w]=[T[0]/255,T[1]/255,T[2]/255]}else V=[0,0,0];D=V.slice()}return[I,D]}var b=[[0,3,1],[2,0,1],[1,0,3],[1,2,0],[3,1,0],[0,1,2]],k={"rgb-hsb":function(w,S,I){var D=Math.max(w,S,I),O=Math.min(w,S,I),R=D-O,$=R===0?0:(D==w?(S-I)/R+(S<I?6:0):D==S?(I-w)/R+2:(w-S)/R+4)*60;return[$,D===0?0:R/D,D]},"hsb-rgb":function(w,S,I){w=(w/60%6+6)%6;var D=Math.floor(w),O=w-D,D=b[D],R=[I,I*(1-S),I*(1-S*O),I*(1-S*(1-O))];return[R[D[0]],R[D[1]],R[D[2]]]},"rgb-hsl":function(w,S,I){var D=Math.max(w,S,I),O=Math.min(w,S,I),R=D-O,$=R===0,U=$?0:(D==w?(S-I)/R+(S<I?6:0):D==S?(I-w)/R+2:(w-S)/R+4)*60,z=(D+O)/2,j=$?0:z<.5?R/(D+O):R/(2-D-O);return[U,j,z]},"hsl-rgb":function(w,S,I){if(w=(w/360%1+1)%1,S===0)return[I,I,I];for(var D=[w+1/3,w,w-1/3],O=I<.5?I*(1+S):I+S-I*S,R=2*I-O,$=[],U=0;U<3;U++){var z=D[U];z<0&&(z+=1),z>1&&(z-=1),$[U]=6*z<1?R+(O-R)*6*z:2*z<1?O:3*z<2?R+(O-R)*(2/3-z)*6:R}return $},"rgb-gray":function(w,S,I){return[w*.2989+S*.587+I*.114]},"gray-rgb":function(w){return[w,w,w]},"gray-hsb":function(w){return[0,0,w]},"gray-hsl":function(w){return[0,0,w]},"gradient-rgb":function(){return[]},"rgb-gradient":function(){return[]}};return s.each(i,function(w,S){c[S]=[],s.each(w,function(I,D){var O=s.capitalize(I),R=/^(hue|saturation)$/.test(I),$=c[S][D]=S==="gradient"?I==="gradient"?function(U){var z=this._components[0];return U=Ht.read(Array.isArray(U)?U:arguments,0,{readNull:!0}),z!==U&&(z&&z._removeOwner(this),U&&U._addOwner(this)),U}:function(){return d.read(arguments,0,{readNull:I==="highlight",clone:!0})}:function(U){return U==null||isNaN(U)?0:+U};this["get"+O]=function(){return this._type===S||R&&/^hs[bl]$/.test(this._type)?this._components[D]:this._convert(S)[D]},this["set"+O]=function(U){this._type!==S&&!(R&&/^hs[bl]$/.test(this._type))&&(this._components=this._convert(S),this._properties=i[S],this._type=S),this._components[D]=$.call(this,U),this._changed()}},this)},{_class:"Color",_readIndex:!0,initialize:function w(S){var I=arguments,D=this.__read,O=0,R,$,U,z;Array.isArray(S)&&(I=S,S=I[0]);var j=S!=null&&typeof S;if(j==="string"&&S in i&&(R=S,S=I[1],Array.isArray(S)?($=S,U=I[2]):(D&&(O=1),I=s.slice(I,1),j=typeof S)),!$){if(z=j==="number"?I:j==="object"&&S.length!=null?S:null,z){R||(R=z.length>=3?"rgb":"gray");var F=i[R].length;U=z[F],D&&(O+=z===arguments?F+(U!=null?1:0):1),z.length>F&&(z=s.slice(z,0,F))}else if(j==="string"){var V=x(S);R=V[0],$=V[1],$.length===4&&(U=$[3],$.length--)}else if(j==="object")if(S.constructor===w){if(R=S._type,$=S._components.slice(),U=S._alpha,R==="gradient")for(var T=1,M=$.length;T<M;T++){var W=$[T];W&&($[T]=W.clone())}}else if(S.constructor===Ht)R="gradient",z=I;else{R="hue"in S?"lightness"in S?"hsl":"hsb":"gradient"in S||"stops"in S||"radial"in S?"gradient":"gray"in S?"gray":"rgb";var q=i[R],G=c[R];this._components=$=[];for(var T=0,M=q.length;T<M;T++){var J=S[q[T]];J==null&&!T&&R==="gradient"&&"stops"in S&&(J={stops:S.stops,radial:S.radial}),J=G[T].call(this,J),J!=null&&($[T]=J)}U=S.alpha}D&&R&&(O=1)}if(this._type=R||"rgb",!$){this._components=$=[];for(var G=c[this._type],T=0,M=G.length;T<M;T++){var J=G[T].call(this,z&&z[T]);J!=null&&($[T]=J)}}return this._components=$,this._properties=i[this._type],this._alpha=U,D&&(this.__read=O),this},set:"#initialize",_serialize:function(w,S){var I=this.getComponents();return s.serialize(/^(gray|rgb)$/.test(this._type)?I:[this._type].concat(I),w,!0,S)},_changed:function(){this._canvasStyle=null,this._owner&&(this._setter?this._owner[this._setter](this):this._owner._changed(129))},_convert:function(w){var S;return this._type===w?this._components.slice():(S=k[this._type+"-"+w])?S.apply(this,this._components):k["rgb-"+w].apply(this,k[this._type+"-rgb"].apply(this,this._components))},convert:function(w){return new Bt(w,this._convert(w),this._alpha)},getType:function(){return this._type},setType:function(w){this._components=this._convert(w),this._properties=i[w],this._type=w},getComponents:function(){var w=this._components.slice();return this._alpha!=null&&w.push(this._alpha),w},getAlpha:function(){return this._alpha!=null?this._alpha:1},setAlpha:function(w){this._alpha=w==null?null:Math.min(Math.max(w,0),1),this._changed()},hasAlpha:function(){return this._alpha!=null},equals:function(w){var S=s.isPlainValue(w,!0)?Bt.read(arguments):w;return S===this||S&&this._class===S._class&&this._type===S._type&&this.getAlpha()===S.getAlpha()&&s.equals(this._components,S._components)||!1},toString:function(){for(var w=this._properties,S=[],I=this._type==="gradient",D=p.instance,O=0,R=w.length;O<R;O++){var $=this._components[O];$!=null&&S.push(w[O]+": "+(I?$:D.number($)))}return this._alpha!=null&&S.push("alpha: "+D.number(this._alpha)),"{ "+S.join(", ")+" }"},toCSS:function(w){var S=this._convert("rgb"),I=w||this._alpha==null?1:this._alpha;function D(O){return Math.round((O<0?0:O>1?1:O)*255)}return S=[D(S[0]),D(S[1]),D(S[2])],I<1&&S.push(I<0?0:I),w?"#"+((1<<24)+(S[0]<<16)+(S[1]<<8)+S[2]).toString(16).slice(1):(S.length==4?"rgba(":"rgb(")+S.join(",")+")"},toCanvasStyle:function(w,S){if(this._canvasStyle)return this._canvasStyle;if(this._type!=="gradient")return this._canvasStyle=this.toCSS();var I=this._components,D=I[0],O=D._stops,R=I[1],$=I[2],U=I[3],z=S&&S.inverted(),j;if(z&&(R=z._transformPoint(R),$=z._transformPoint($),U&&(U=z._transformPoint(U))),D._radial){var F=$.getDistance(R);if(U){var V=U.subtract(R);V.getLength()>F&&(U=R.add(V.normalize(F-.1)))}var T=U||R;j=w.createRadialGradient(T.x,T.y,0,R.x,R.y,F)}else j=w.createLinearGradient(R.x,R.y,$.x,$.y);for(var M=0,W=O.length;M<W;M++){var q=O[M],G=q._offset;j.addColorStop(G??M/(W-1),q._color.toCanvasStyle())}return this._canvasStyle=j},transform:function(w){if(this._type==="gradient"){for(var S=this._components,I=1,D=S.length;I<D;I++){var O=S[I];w._transformPoint(O,O,!0)}this._changed()}},statics:{_types:i,random:function(){var w=Math.random;return new Bt(w(),w(),w())},_setOwner:function(w,S,I){return w&&(w._owner&&S&&w._owner!==S&&(w=w.clone()),!w._owner^!S&&(w._owner=S||null,w._setter=I||null)),w}}})},new function(){var i={add:function(c,h){return c+h},subtract:function(c,h){return c-h},multiply:function(c,h){return c*h},divide:function(c,h){return c/h}};return s.each(i,function(c,h){this[h]=function(g){g=Bt.read(arguments);for(var x=this._type,b=this._components,k=g._convert(x),w=0,S=b.length;w<S;w++)k[w]=c(b[w],k[w]);return new Bt(x,k,this._alpha!=null?c(this._alpha,g.getAlpha()):null)}},{})}),Ht=s.extend({_class:"Gradient",initialize:function(c,h){this._id=m.get(),c&&s.isPlainObject(c)&&(this.set(c),c=h=null),this._stops==null&&this.setStops(c||["white","black"]),this._radial==null&&this.setRadial(typeof h=="string"&&h==="radial"||h||!1)},_serialize:function(i,c){return c.add(this,function(){return s.serialize([this._stops,this._radial],i,!0,c)})},_changed:function(){for(var i=0,c=this._owners&&this._owners.length;i<c;i++)this._owners[i]._changed()},_addOwner:function(i){this._owners||(this._owners=[]),this._owners.push(i)},_removeOwner:function(i){var c=this._owners?this._owners.indexOf(i):-1;c!=-1&&(this._owners.splice(c,1),this._owners.length||(this._owners=t))},clone:function(){for(var i=[],c=0,h=this._stops.length;c<h;c++)i[c]=this._stops[c].clone();return new Ht(i,this._radial)},getStops:function(){return this._stops},setStops:function(i){if(i.length<2)throw new Error("Gradient stop list needs to contain at least two stops.");var c=this._stops;if(c)for(var h=0,g=c.length;h<g;h++)c[h]._owner=t;c=this._stops=Zt.readList(i,0,{clone:!0});for(var h=0,g=c.length;h<g;h++)c[h]._owner=this;this._changed()},getRadial:function(){return this._radial},setRadial:function(i){this._radial=i,this._changed()},equals:function(i){if(i===this)return!0;if(i&&this._class===i._class){var c=this._stops,h=i._stops,g=c.length;if(g===h.length){for(var x=0;x<g;x++)if(!c[x].equals(h[x]))return!1;return!0}}return!1}}),Zt=s.extend({_class:"GradientStop",initialize:function(c,h){var g=c,x=h;typeof c=="object"&&h===t&&(Array.isArray(c)&&typeof c[0]!="number"?(g=c[0],x=c[1]):("color"in c||"offset"in c||"rampPoint"in c)&&(g=c.color,x=c.offset||c.rampPoint||0)),this.setColor(g),this.setOffset(x)},clone:function(){return new Zt(this._color.clone(),this._offset)},_serialize:function(i,c){var h=this._color,g=this._offset;return s.serialize(g==null?[h]:[h,g],i,!0,c)},_changed:function(){this._owner&&this._owner._changed(129)},getOffset:function(){return this._offset},setOffset:function(i){this._offset=i,this._changed()},getRampPoint:"#getOffset",setRampPoint:"#setOffset",getColor:function(){return this._color},setColor:function(){Bt._setOwner(this._color,null),this._color=Bt._setOwner(Bt.read(arguments,0),this,"setColor"),this._changed()},equals:function(i){return i===this||i&&this._class===i._class&&this._color.equals(i._color)&&this._offset==i._offset||!1}}),ne=s.extend(new function(){var i={fillColor:null,fillRule:"nonzero",strokeColor:null,strokeWidth:1,strokeCap:"butt",strokeJoin:"miter",strokeScaling:!0,miterLimit:10,dashOffset:0,dashArray:[],shadowColor:null,shadowBlur:0,shadowOffset:new d,selectedColor:null},c=s.set({},i,{fontFamily:"sans-serif",fontWeight:"normal",fontSize:12,leading:null,justification:"left"}),h=s.set({},c,{fillColor:new Bt}),g={strokeWidth:193,strokeCap:193,strokeJoin:193,strokeScaling:201,miterLimit:193,fontFamily:9,fontWeight:9,fontSize:9,font:9,leading:9,justification:9},x={beans:!0},b={_class:"Style",beans:!0,initialize:function(w,S,I){this._values={},this._owner=S,this._project=S&&S._project||I||ye.project,this._defaults=!S||S instanceof Z?c:S instanceof jt?h:i,w&&this.set(w)}};return s.each(c,function(k,w){var S=/Color$/.test(w),I=w==="shadowOffset",D=s.capitalize(w),O=g[w],R="set"+D,$="get"+D;b[R]=function(U){var z=this._owner,j=z&&z._children,F=j&&j.length>0&&!(z instanceof Dt);if(F)for(var V=0,T=j.length;V<T;V++)j[V]._style[R](U);if((w==="selectedColor"||!F)&&w in this._defaults){var M=this._values[w];M!==U&&(S&&(M&&(Bt._setOwner(M,null),M._canvasStyle=null),U&&U.constructor===Bt&&(U=Bt._setOwner(U,z,F&&R))),this._values[w]=U,z&&z._changed(O||129))}},b[$]=function(U){var z=this._owner,j=z&&z._children,F=j&&j.length>0&&!(z instanceof Dt),V;if(F&&!U)for(var T=0,M=j.length;T<M;T++){var W=j[T]._style[$]();if(!T)V=W;else if(!s.equals(V,W))return t}else if(w in this._defaults){var V=this._values[w];if(V===t)V=this._defaults[w],V&&V.clone&&(V=V.clone());else{var q=S?Bt:I?d:null;q&&!(V&&V.constructor===q)&&(this._values[w]=V=q.read([V],0,{readNull:!0,clone:!0}))}}return V&&S&&(V=Bt._setOwner(V,z,F&&R)),V},x[$]=function(U){return this._style[$](U)},x[R]=function(U){this._style[R](U)}}),s.each({Font:"FontFamily",WindingRule:"FillRule"},function(k,w){var S="get"+w,I="set"+w;b[S]=x[S]="#get"+k,b[I]=x[I]="#set"+k}),L.inject(x),b},{set:function(i){var c=i instanceof ne,h=c?i._values:i;if(h){for(var g in h)if(g in this._defaults){var x=h[g];this[g]=x&&c&&x.clone?x.clone():x}}},equals:function(i){function c(h,g,x){var b=h._values,k=g._values,w=g._defaults;for(var S in b){var I=b[S],D=k[S];if(!(x&&S in k)&&!s.equals(I,D===t?w[S]:D))return!1}return!0}return i===this||i&&this._class===i._class&&c(this,i)&&c(i,this,!0)||!1},_dispose:function(){var i;i=this.getFillColor(),i&&(i._canvasStyle=null),i=this.getStrokeColor(),i&&(i._canvasStyle=null),i=this.getShadowColor(),i&&(i._canvasStyle=null)},hasFill:function(){var i=this.getFillColor();return!!i&&i.alpha>0},hasStroke:function(){var i=this.getStrokeColor();return!!i&&i.alpha>0&&this.getStrokeWidth()>0},hasShadow:function(){var i=this.getShadowColor();return!!i&&i.alpha>0&&(this.getShadowBlur()>0||!this.getShadowOffset().isZero())},getView:function(){return this._project._view},getFontStyle:function(){var i=this.getFontSize();return this.getFontWeight()+" "+i+(/[a-z]/i.test(i+"")?" ":"px ")+this.getFontFamily()},getFont:"#getFontFamily",setFont:"#setFontFamily",getLeading:function i(){var c=i.base.call(this),h=this.getFontSize();return/pt|em|%|px/.test(h)&&(h=this.getView().getPixelSize(h)),c??h*1.2}}),Qt=new function(){function i(c,h,g,x){for(var b=["","webkit","moz","Moz","ms","o"],k=h[0].toUpperCase()+h.substring(1),w=0;w<6;w++){var S=b[w],I=S?S+k:h;if(I in c){if(g)c[I]=x;else return c[I];break}}}return{getStyles:function(c){var h=c&&c.nodeType!==9?c.ownerDocument:c,g=h&&h.defaultView;return g&&g.getComputedStyle(c,"")},getBounds:function(c,h){var g=c.ownerDocument,x=g.body,b=g.documentElement,k;try{k=c.getBoundingClientRect()}catch(D){k={left:0,top:0,width:0,height:0}}var w=k.left-(b.clientLeft||x.clientLeft||0),S=k.top-(b.clientTop||x.clientTop||0);if(!h){var I=g.defaultView;w+=I.pageXOffset||b.scrollLeft||x.scrollLeft,S+=I.pageYOffset||b.scrollTop||x.scrollTop}return new C(w,S,k.width,k.height)},getViewportBounds:function(c){var h=c.ownerDocument,g=h.defaultView,x=h.documentElement;return new C(0,0,g.innerWidth||x.clientWidth,g.innerHeight||x.clientHeight)},getOffset:function(c,h){return Qt.getBounds(c,h).getPoint()},getSize:function(c){return Qt.getBounds(c,!0).getSize()},isInvisible:function(c){return Qt.getSize(c).equals(new _(0,0))},isInView:function(c){return!Qt.isInvisible(c)&&Qt.getViewportBounds(c).intersects(Qt.getBounds(c,!0))},isInserted:function(c){return n.body.contains(c)},getPrefixed:function(c,h){return c&&i(c,h)},setPrefixed:function(c,h,g){if(typeof h=="object")for(var x in h)i(c,x,!0,h[x]);else i(c,h,!0,g)}}},te={add:function(i,c){if(i)for(var h in c)for(var g=c[h],x=h.split(/[\s,]+/g),b=0,k=x.length;b<k;b++){var w=x[b],S=i===n&&(w==="touchstart"||w==="touchmove")?{passive:!1}:!1;i.addEventListener(w,g,S)}},remove:function(i,c){if(i)for(var h in c)for(var g=c[h],x=h.split(/[\s,]+/g),b=0,k=x.length;b<k;b++)i.removeEventListener(x[b],g,!1)},getPoint:function(i){var c=i.targetTouches?i.targetTouches.length?i.targetTouches[0]:i.changedTouches[0]:i;return new d(c.pageX||c.clientX+n.documentElement.scrollLeft,c.pageY||c.clientY+n.documentElement.scrollTop)},getTarget:function(i){return i.target||i.srcElement},getRelatedTarget:function(i){return i.relatedTarget||i.toElement},getOffset:function(i,c){return te.getPoint(i).subtract(Qt.getOffset(c||te.getTarget(i)))}};te.requestAnimationFrame=new function(){var i=Qt.getPrefixed(e,"requestAnimationFrame"),c=!1,h=[],g;function x(){var b=h;h=[];for(var k=0,w=b.length;k<w;k++)b[k]();c=i&&h.length,c&&i(x)}return function(b){h.push(b),i?c||(i(x),c=!0):g||(g=setInterval(x,1e3/60))}};var oe=s.extend(o,{_class:"View",initialize:function i(c,h){function g(O){return h[O]||parseInt(h.getAttribute(O),10)}function x(){var O=Qt.getSize(h);return O.isNaN()||O.isZero()?new _(g("width"),g("height")):O}var b;if(e&&h){this._id=h.getAttribute("id"),this._id==null&&h.setAttribute("id",this._id="paper-view-"+i._id++),te.add(h,this._viewEvents);var k="none";if(Qt.setPrefixed(h.style,{userDrag:k,userSelect:k,touchCallout:k,contentZooming:k,tapHighlightColor:"rgba(0,0,0,0)"}),a.hasAttribute(h,"resize")){var w=this;te.add(e,this._windowEvents={resize:function(){w.setViewSize(x())}})}if(b=x(),a.hasAttribute(h,"stats")&&typeof Stats!="undefined"){this._stats=new Stats;var S=this._stats.domElement,I=S.style,D=Qt.getOffset(h);I.position="absolute",I.left=D.x+"px",I.top=D.y+"px",n.body.appendChild(S)}}else b=new _(h),h=null;this._project=c,this._scope=c._scope,this._element=h,this._pixelRatio||(this._pixelRatio=e&&e.devicePixelRatio||1),this._setElementSize(b.width,b.height),this._viewSize=b,i._views.push(this),i._viewsById[this._id]=this,(this._matrix=new A)._owner=this,i._focused||(i._focused=this),this._frameItems={},this._frameItemCount=0,this._itemEvents={native:{},virtual:{}},this._autoUpdate=!ye.agent.node,this._needsUpdate=!1},remove:function(){if(!this._project)return!1;oe._focused===this&&(oe._focused=null),oe._views.splice(oe._views.indexOf(this),1),delete oe._viewsById[this._id];var i=this._project;return i._view===this&&(i._view=null),te.remove(this._element,this._viewEvents),te.remove(e,this._windowEvents),this._element=this._project=null,this.off("frame"),this._animate=!1,this._frameItems={},!0},_events:s.each(L._itemHandlers.concat(["onResize","onKeyDown","onKeyUp"]),function(i){this[i]={}},{onFrame:{install:function(){this.play()},uninstall:function(){this.pause()}}}),_animate:!1,_time:0,_count:0,getAutoUpdate:function(){return this._autoUpdate},setAutoUpdate:function(i){this._autoUpdate=i,i&&this.requestUpdate()},update:function(){},draw:function(){this.update()},requestUpdate:function(){if(!this._requested){var i=this;te.requestAnimationFrame(function(){if(i._requested=!1,i._animate){i.requestUpdate();var c=i._element;(!Qt.getPrefixed(n,"hidden")||a.getAttribute(c,"keepalive")==="true")&&Qt.isInView(c)&&i._handleFrame()}i._autoUpdate&&i.update()}),this._requested=!0}},play:function(){this._animate=!0,this.requestUpdate()},pause:function(){this._animate=!1},_handleFrame:function(){ye=this._scope;var i=Date.now()/1e3,c=this._last?i-this._last:0;this._last=i,this.emit("frame",new s({delta:c,time:this._time+=c,count:this._count++})),this._stats&&this._stats.update()},_animateItem:function(i,c){var h=this._frameItems;c?(h[i._id]={item:i,time:0,count:0},++this._frameItemCount==1&&this.on("frame",this._handleFrameItems)):(delete h[i._id],--this._frameItemCount==0&&this.off("frame",this._handleFrameItems))},_handleFrameItems:function(i){for(var c in this._frameItems){var h=this._frameItems[c];h.item.emit("frame",new s(i,{time:h.time+=i.delta,count:h.count++}))}},_changed:function(){this._project._changed(4097),this._bounds=this._decomposed=t},getElement:function(){return this._element},getPixelRatio:function(){return this._pixelRatio},getResolution:function(){return this._pixelRatio*72},getViewSize:function(){var i=this._viewSize;return new v(i.width,i.height,this,"setViewSize")},setViewSize:function(){var i=_.read(arguments),c=i.subtract(this._viewSize);c.isZero()||(this._setElementSize(i.width,i.height),this._viewSize.set(i),this._changed(),this.emit("resize",{size:i,delta:c}),this._autoUpdate&&this.update())},_setElementSize:function(i,c){var h=this._element;h&&(h.width!==i&&(h.width=i),h.height!==c&&(h.height=c))},getBounds:function(){return this._bounds||(this._bounds=this._matrix.inverted()._transformBounds(new C(new d,this._viewSize))),this._bounds},getSize:function(){return this.getBounds().getSize()},isVisible:function(){return Qt.isInView(this._element)},isInserted:function(){return Qt.isInserted(this._element)},getPixelSize:function(i){var c=this._element,h;if(c){var g=c.parentNode,x=n.createElement("div");x.style.fontSize=i,g.appendChild(x),h=parseFloat(Qt.getStyles(x).fontSize),g.removeChild(x)}else h=parseFloat(h);return h},getTextWidth:function(i,c){return 0}},s.each(["rotate","scale","shear","skew"],function(i){var c=i==="rotate";this[i]=function(){var h=arguments,g=(c?s:d).read(h),x=d.read(h,0,{readNull:!0});return this.transform(new A()[i](g,x||this.getCenter(!0)))}},{_decompose:function(){return this._decomposed||(this._decomposed=this._matrix.decompose())},translate:function(){var i=new A;return this.transform(i.translate.apply(i,arguments))},getCenter:function(){return this.getBounds().getCenter()},setCenter:function(){var i=d.read(arguments);this.translate(this.getCenter().subtract(i))},getZoom:function(){var i=this._decompose().scaling;return(i.x+i.y)/2},setZoom:function(i){this.transform(new A().scale(i/this.getZoom(),this.getCenter()))},getRotation:function(){return this._decompose().rotation},setRotation:function(i){var c=this.getRotation();c!=null&&i!=null&&this.rotate(i-c)},getScaling:function(){var i=this._decompose().scaling;return new y(i.x,i.y,this,"setScaling")},setScaling:function(){var i=this.getScaling(),c=d.read(arguments,0,{clone:!0,readNull:!0});i&&c&&this.scale(c.x/i.x,c.y/i.y)},getMatrix:function(){return this._matrix},setMatrix:function(){var i=this._matrix;i.set.apply(i,arguments)},transform:function(i){this._matrix.append(i)},scrollBy:function(){this.translate(d.read(arguments).negate())}}),{projectToView:function(){return this._matrix._transformPoint(d.read(arguments))},viewToProject:function(){return this._matrix._inverseTransform(d.read(arguments))},getEventPoint:function(i){return this.viewToProject(te.getOffset(i,this._element))}},{statics:{_views:[],_viewsById:{},_id:0,create:function(i,c){n&&typeof c=="string"&&(c=n.getElementById(c));var h=e?Re:oe;return new h(i,c)}}},new function(){if(!e)return;var i,c,h=!1,g=!1;function x(pt){var ut=te.getTarget(pt);return ut.getAttribute&&oe._viewsById[ut.getAttribute("id")]}function b(){var pt=oe._focused;if(!pt||!pt.isVisible()){for(var ut=0,gt=oe._views.length;ut<gt;ut++)if((pt=oe._views[ut]).isVisible()){oe._focused=c=pt;break}}}function k(pt,ut,gt){pt._handleMouseEvent("mousemove",ut,gt)}var w=e.navigator,S,I,D;w.pointerEnabled||w.msPointerEnabled?(S="pointerdown MSPointerDown",I="pointermove MSPointerMove",D="pointerup pointercancel MSPointerUp MSPointerCancel"):(S="touchstart",I="touchmove",D="touchend touchcancel","ontouchstart"in e&&w.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i)||(S+=" mousedown",I+=" mousemove",D+=" mouseup"));var O={},R={mouseout:function(pt){var ut=oe._focused,gt=te.getRelatedTarget(pt);if(ut&&(!gt||gt.nodeName==="HTML")){var bt=te.getOffset(pt,ut._element),kt=bt.x,Rt=Math.abs,Wt=Rt(kt),Kt=1<<25,Yt=Wt-Kt;bt.x=Rt(Yt)<Wt?Yt*(kt<0?-1:1):kt,k(ut,pt,ut.viewToProject(bt))}},scroll:b};O[S]=function(pt){var ut=oe._focused=x(pt);h||(h=!0,ut._handleMouseEvent("mousedown",pt))},R[I]=function(pt){var ut=oe._focused;if(!g){var gt=x(pt);gt?ut!==gt&&(ut&&k(ut,pt),i||(i=ut),ut=oe._focused=c=gt):c&&c===ut&&(i&&!i.isInserted()&&(i=null),ut=oe._focused=i,i=null,b())}ut&&k(ut,pt)},R[S]=function(){g=!0},R[D]=function(pt){var ut=oe._focused;ut&&h&&ut._handleMouseEvent("mouseup",pt),g=h=!1},te.add(n,R),te.add(e,{load:b});var $=!1,U=!1,z={doubleclick:"click",mousedrag:"mousemove"},j=!1,F,V,T,M,W,q,G,J,nt;function ot(pt,ut,gt,bt,kt,Rt,Wt){var Kt=!1,Yt;function Et(Pt,Ut){if(Pt.responds(Ut)){if(Yt||(Yt=new sr(Ut,bt,kt,ut||Pt,Rt?kt.subtract(Rt):null)),Pt.emit(Ut,Yt)&&($=!0,Yt.prevented&&(U=!0),Yt.stopped))return Kt=!0}else{var se=z[Ut];if(se)return Et(Pt,se)}}for(;pt&&pt!==Wt&&!Et(pt,gt);)pt=pt._parent;return Kt}function at(pt,ut,gt,bt,kt,Rt){return pt._project.removeOn(gt),U=$=!1,q&&ot(q,null,gt,bt,kt,Rt)||ut&&ut!==q&&!ut.isDescendant(q)&&ot(ut,null,gt==="mousedrag"?"mousemove":gt,bt,kt,Rt,q)||ot(pt,q||ut||pt,gt,bt,kt,Rt)}var lt={mousedown:{mousedown:1,mousedrag:1,click:1,doubleclick:1},mouseup:{mouseup:1,mousedrag:1,click:1,doubleclick:1},mousemove:{mousedrag:1,mousemove:1,mouseenter:1,mouseleave:1}};return{_viewEvents:O,_handleMouseEvent:function(pt,ut,gt){var bt=this._itemEvents,kt=bt.native[pt],Rt=pt==="mousemove",Wt=this._scope.tool,Kt=this;function Yt(me){return bt.virtual[me]||Kt.responds(me)||Wt&&Wt.responds(me)}Rt&&h&&Yt("mousedrag")&&(pt="mousedrag"),gt||(gt=this.getEventPoint(ut));var Et=this.getBounds().contains(gt),Pt=kt&&Et&&Kt._project.hitTest(gt,{tolerance:0,fill:!0,stroke:!0}),Ut=Pt&&Pt.item||null,se=!1,Jt={};if(Jt[pt.substr(5)]=!0,kt&&Ut!==W&&(W&&ot(W,null,"mouseleave",ut,gt),Ut&&ot(Ut,null,"mouseenter",ut,gt),W=Ut),j^Et&&(ot(this,null,Et?"mouseenter":"mouseleave",ut,gt),F=Et?this:null,se=!0),(Et||Jt.drag)&&!gt.equals(T)&&(at(this,Ut,Rt?pt:"mousemove",ut,gt,T),se=!0),j=Et,Jt.down&&Et||Jt.up&&V){if(at(this,Ut,pt,ut,gt,V),Jt.down){if(nt=Ut===G&&Date.now()-J<300,M=G=Ut,!U&&Ut){for(var de=Ut;de&&!de.responds("mousedrag");)de=de._parent;de&&(q=Ut)}V=gt}else Jt.up&&(!U&&Ut===M&&(J=Date.now(),at(this,Ut,nt?"doubleclick":"click",ut,gt,V),nt=!1),M=q=null);j=!1,se=!0}T=gt,se&&Wt&&($=Wt._handleMouseEvent(pt,ut,gt,Jt)||$),ut.cancelable!==!1&&($&&!Jt.move||Jt.down&&Yt("mouseup"))&&ut.preventDefault()},_handleKeyEvent:function(pt,ut,gt,bt){var kt=this._scope,Rt=kt.tool,Wt;function Kt(Yt){Yt.responds(pt)&&(ye=kt,Yt.emit(pt,Wt=Wt||new xr(pt,ut,gt,bt)))}this.isVisible()&&(Kt(this),Rt&&Rt.responds(pt)&&Kt(Rt))},_countItemEvent:function(pt,ut){var gt=this._itemEvents,bt=gt.native,kt=gt.virtual;for(var Rt in lt)bt[Rt]=(bt[Rt]||0)+(lt[Rt][pt]||0)*ut;kt[pt]=(kt[pt]||0)+ut},statics:{updateFocus:b,_resetState:function(){h=g=$=j=!1,i=c=F=V=T=M=W=q=G=J=nt=null}}}}),Re=oe.extend({_class:"CanvasView",initialize:function(c,h){if(!(h instanceof e.HTMLCanvasElement)){var g=_.read(arguments,1);if(g.isZero())throw new Error("Cannot create CanvasView with the provided argument: "+s.slice(arguments,1));h=Pe.getCanvas(g)}var x=this._context=h.getContext("2d");if(x.save(),this._pixelRatio=1,!/^off|false$/.test(a.getAttribute(h,"hidpi"))){var b=e.devicePixelRatio||1,k=Qt.getPrefixed(x,"backingStorePixelRatio")||1;this._pixelRatio=b/k}oe.call(this,c,h),this._needsUpdate=!0},remove:function i(){return this._context.restore(),i.base.call(this)},_setElementSize:function i(c,h){var g=this._pixelRatio;if(i.base.call(this,c*g,h*g),g!==1){var x=this._element,b=this._context;if(!a.hasAttribute(x,"resize")){var k=x.style;k.width=c+"px",k.height=h+"px"}b.restore(),b.save(),b.scale(g,g)}},getContext:function(){return this._context},getPixelSize:function i(c){var h=ye.agent,g;if(h&&h.firefox)g=i.base.call(this,c);else{var x=this._context,b=x.font;x.font=c+" serif",g=parseFloat(x.font),x.font=b}return g},getTextWidth:function(i,c){var h=this._context,g=h.font,x=0;h.font=i;for(var b=0,k=c.length;b<k;b++)x=Math.max(x,h.measureText(c[b]).width);return h.font=g,x},update:function(){if(!this._needsUpdate)return!1;var i=this._project,c=this._context,h=this._viewSize;return c.clearRect(0,0,h.width+1,h.height+1),i&&i.draw(c,this._matrix,this._pixelRatio),this._needsUpdate=!1,!0}}),We=s.extend({_class:"Event",initialize:function(c){this.event=c,this.type=c&&c.type},prevented:!1,stopped:!1,preventDefault:function(){this.prevented=!0,this.event.preventDefault()},stopPropagation:function(){this.stopped=!0,this.event.stopPropagation()},stop:function(){this.stopPropagation(),this.preventDefault()},getTimeStamp:function(){return this.event.timeStamp},getModifiers:function(){return nr.modifiers}}),xr=We.extend({_class:"KeyEvent",initialize:function(c,h,g,x){this.type=c,this.event=h,this.key=g,this.character=x},toString:function(){return"{ type: '"+this.type+"', key: '"+this.key+"', character: '"+this.character+"', modifiers: "+this.getModifiers()+" }"}}),nr=new function(){var i={"	":"tab"," ":"space","\b":"backspace","\x7F":"delete",Spacebar:"space",Del:"delete",Win:"meta",Esc:"escape"},c={tab:"	",space:" ",enter:"\r"},h={},g={},x,b,k=new s({shift:!1,control:!1,alt:!1,meta:!1,capsLock:!1,space:!1}).inject({option:{get:function(){return this.alt}},command:{get:function(){var I=ye&&ye.agent;return I&&I.mac?this.meta:this.control}}});function w(I){var D=I.key||I.keyIdentifier;return D=/^U\+/.test(D)?String.fromCharCode(parseInt(D.substr(2),16)):/^Arrow[A-Z]/.test(D)?D.substr(5):D==="Unidentified"||D===t?String.fromCharCode(I.keyCode):D,i[D]||(D.length>1?s.hyphenate(D):D.toLowerCase())}function S(I,D,O,R){var $=I?"keydown":"keyup",U=oe._focused,z;if(h[D]=I,I?g[D]=O:delete g[D],D.length>1&&(z=s.camelize(D))in k){k[z]=I;var j=ye&&ye.agent;if(z==="meta"&&j&&j.mac)if(I)x={};else{for(var F in x)F in g&&S(!1,F,x[F],R);x=null}}else I&&x&&(x[D]=O);U&&U._handleKeyEvent(I?"keydown":"keyup",R,D,O)}return te.add(n,{keydown:function(I){var D=w(I),O=ye&&ye.agent;D.length>1||O&&O.chrome&&(I.altKey||O.mac&&I.metaKey||!O.mac&&I.ctrlKey)?S(!0,D,c[D]||(D.length>1?"":D),I):b=D},keypress:function(I){if(b){var D=w(I),O=I.charCode,R=O>=32?String.fromCharCode(O):D.length>1?"":D;D!==b&&(D=R.toLowerCase()),S(!0,D,R,I),b=null}},keyup:function(I){var D=w(I);D in g&&S(!1,D,g[D],I)}}),te.add(e,{blur:function(I){for(var D in g)S(!1,D,g[D],I)}}),{modifiers:k,isDown:function(I){return!!h[I]}}},sr=We.extend({_class:"MouseEvent",initialize:function(c,h,g,x,b){this.type=c,this.event=h,this.point=g,this.target=x,this.delta=b},toString:function(){return"{ type: '"+this.type+"', point: "+this.point+", target: "+this.target+(this.delta?", delta: "+this.delta:"")+", modifiers: "+this.getModifiers()+" }"}}),or=We.extend({_class:"ToolEvent",_item:null,initialize:function(c,h,g){this.tool=c,this.type=h,this.event=g},_choosePoint:function(i,c){return i||(c?c.clone():null)},getPoint:function(){return this._choosePoint(this._point,this.tool._point)},setPoint:function(i){this._point=i},getLastPoint:function(){return this._choosePoint(this._lastPoint,this.tool._lastPoint)},setLastPoint:function(i){this._lastPoint=i},getDownPoint:function(){return this._choosePoint(this._downPoint,this.tool._downPoint)},setDownPoint:function(i){this._downPoint=i},getMiddlePoint:function(){return!this._middlePoint&&this.tool._lastPoint?this.tool._point.add(this.tool._lastPoint).divide(2):this._middlePoint},setMiddlePoint:function(i){this._middlePoint=i},getDelta:function(){return!this._delta&&this.tool._lastPoint?this.tool._point.subtract(this.tool._lastPoint):this._delta},setDelta:function(i){this._delta=i},getCount:function(){return this.tool[/^mouse(down|up)$/.test(this.type)?"_downCount":"_moveCount"]},setCount:function(i){this.tool[/^mouse(down|up)$/.test(this.type)?"downCount":"count"]=i},getItem:function(){if(!this._item){var i=this.tool._scope.project.hitTest(this.getPoint());if(i){for(var c=i.item,h=c._parent;/^(Group|CompoundPath)$/.test(h._class);)c=h,h=h._parent;this._item=c}}return this._item},setItem:function(i){this._item=i},toString:function(){return"{ type: "+this.type+", point: "+this.getPoint()+", count: "+this.getCount()+", modifiers: "+this.getModifiers()+" }"}}),pr=l.extend({_class:"Tool",_list:"tools",_reference:"tool",_events:["onMouseDown","onMouseUp","onMouseDrag","onMouseMove","onActivate","onDeactivate","onEditOptions","onKeyDown","onKeyUp"],initialize:function(c){l.call(this),this._moveCount=-1,this._downCount=-1,this.set(c)},getMinDistance:function(){return this._minDistance},setMinDistance:function(i){this._minDistance=i,i!=null&&this._maxDistance!=null&&i>this._maxDistance&&(this._maxDistance=i)},getMaxDistance:function(){return this._maxDistance},setMaxDistance:function(i){this._maxDistance=i,this._minDistance!=null&&i!=null&&i<this._minDistance&&(this._minDistance=i)},getFixedDistance:function(){return this._minDistance==this._maxDistance?this._minDistance:null},setFixedDistance:function(i){this._minDistance=this._maxDistance=i},_handleMouseEvent:function(i,c,h,g){ye=this._scope,g.drag&&!this.responds(i)&&(i="mousemove");var x=g.move||g.drag,b=this.responds(i),k=this.minDistance,w=this.maxDistance,S=!1,I=this;function D(R,$){var U=h,z=x?I._point:I._downPoint||U;if(x){if(I._moveCount>=0&&U.equals(z))return!1;if(z&&(R!=null||$!=null)){var j=U.subtract(z),F=j.getLength();if(F<(R||0))return!1;$&&(U=z.add(j.normalize(Math.min(F,$))))}I._moveCount++}return I._point=U,I._lastPoint=z||U,g.down&&(I._moveCount=-1,I._downPoint=U,I._downCount++),!0}function O(){b&&(S=I.emit(i,new or(I,i,c))||S)}if(g.down)D(),O();else if(g.up)D(null,w),O();else if(b)for(;D(k,w);)O();return S}}),wr=s.extend(o,{_class:"Tween",statics:{easings:{linear:function(i){return i},easeInQuad:function(i){return i*i},easeOutQuad:function(i){return i*(2-i)},easeInOutQuad:function(i){return i<.5?2*i*i:-1+2*(2-i)*i},easeInCubic:function(i){return i*i*i},easeOutCubic:function(i){return--i*i*i+1},easeInOutCubic:function(i){return i<.5?4*i*i*i:(i-1)*(2*i-2)*(2*i-2)+1},easeInQuart:function(i){return i*i*i*i},easeOutQuart:function(i){return 1- --i*i*i*i},easeInOutQuart:function(i){return i<.5?8*i*i*i*i:1-8*--i*i*i*i},easeInQuint:function(i){return i*i*i*i*i},easeOutQuint:function(i){return 1+--i*i*i*i*i},easeInOutQuint:function(i){return i<.5?16*i*i*i*i*i:1+16*--i*i*i*i*i}}},initialize:function i(c,h,g,x,b,k){this.object=c;var w=typeof b,S=w==="function";this.type=S?w:w==="string"?b:"linear",this.easing=S?b:i.easings[this.type],this.duration=x,this.running=!1,this._then=null,this._startTime=null;var I=h||g;this._keys=I?Object.keys(I):[],this._parsedKeys=this._parseKeys(this._keys),this._from=I&&this._getState(h),this._to=I&&this._getState(g),k!==!1&&this.start()},then:function(i){return this._then=i,this},start:function(){return this._startTime=null,this.running=!0,this},stop:function(){return this.running=!1,this},update:function(i){if(this.running){i>=1&&(i=1,this.running=!1);for(var c=this.easing(i),h=this._keys,g=function(D){return typeof D=="function"?D(c,i):D},x=0,b=h&&h.length;x<b;x++){var k=h[x],w=g(this._from[k]),S=g(this._to[k]),I=w&&S&&w.__add&&S.__add?S.__subtract(w).__multiply(c).__add(w):(S-w)*c+w;this._setProperty(this._parsedKeys[k],I)}this.responds("update")&&this.emit("update",new s({progress:i,factor:c})),!this.running&&this._then&&this._then(this.object)}return this},_events:{onUpdate:{}},_handleFrame:function(i){var c=this._startTime,h=c?(i-c)/this.duration:0;c||(this._startTime=i),this.update(h)},_getState:function(i){for(var c=this._keys,h={},g=0,x=c.length;g<x;g++){var b=c[g],k=this._parsedKeys[b],w=this._getProperty(k),S;if(i){var I=this._resolveValue(w,i[b]);this._setProperty(k,I),S=this._getProperty(k),S=S&&S.clone?S.clone():S,this._setProperty(k,w)}else S=w&&w.clone?w.clone():w;h[b]=S}return h},_resolveValue:function(i,c){if(c){if(Array.isArray(c)&&c.length===2){var h=c[0];return h&&h.match&&h.match(/^[+\-\*\/]=/)?this._calculate(i,h[0],c[1]):c}else if(typeof c=="string"){var g=c.match(/^[+\-*/]=(.*)/);if(g){var x=JSON.parse(g[1].replace(/(['"])?([a-zA-Z0-9_]+)(['"])?:/g,'"$2": '));return this._calculate(i,c[0],x)}}}return c},_calculate:function(i,c,h){return ye.PaperScript.calculateBinary(i,c,h)},_parseKeys:function(i){for(var c={},h=0,g=i.length;h<g;h++){var x=i[h],b=x.replace(/\.([^.]*)/g,"/$1").replace(/\[['"]?([^'"\]]*)['"]?\]/g,"/$1");c[x]=b.split("/")}return c},_getProperty:function(i,c){for(var h=this.object,g=0,x=i.length-(c||0);g<x&&h;g++)h=h[i[g]];return h},_setProperty:function(i,c){var h=this._getProperty(i,1);h&&(h[i[i.length-1]]=c)}}),Kn={request:function(i){var c=new r.XMLHttpRequest;return c.open((i.method||"get").toUpperCase(),i.url,s.pick(i.async,!0)),i.mimeType&&c.overrideMimeType(i.mimeType),c.onload=function(){var h=c.status;h===0||h===200?i.onLoad&&i.onLoad.call(c,c.responseText):c.onerror()},c.onerror=function(){var h=c.status,g='Could not load "'+i.url+'" (Status: '+h+")";if(i.onError)i.onError(g,h);else throw new Error(g)},c.send(null)}},Pe=s.exports.CanvasProvider={canvases:[],getCanvas:function(i,c){if(!e)return null;var h,g=!0;typeof i=="object"&&(c=i.height,i=i.width),this.canvases.length?h=this.canvases.pop():(h=n.createElement("canvas"),g=!1);var x=h.getContext("2d");if(!x)throw new Error("Canvas "+h+" is unable to provide a 2D context.");return h.width===i&&h.height===c?g&&x.clearRect(0,0,i+1,c+1):(h.width=i,h.height=c),x.save(),h},getContext:function(i,c){var h=this.getCanvas(i,c);return h?h.getContext("2d"):null},release:function(i){var c=i&&i.canvas?i.canvas:i;c&&c.getContext&&(c.getContext("2d").restore(),this.canvases.push(c))}},Tn=new function(){var i=Math.min,c=Math.max,h=Math.abs,g,x,b,k,w,S,I,D,O,R,$;function U(W,q,G){return .2989*W+.587*q+.114*G}function z(W,q,G,J){var nt=J-U(W,q,G);O=W+nt,R=q+nt,$=G+nt;var J=U(O,R,$),ot=i(O,R,$),at=c(O,R,$);if(ot<0){var lt=J-ot;O=J+(O-J)*J/lt,R=J+(R-J)*J/lt,$=J+($-J)*J/lt}if(at>255){var pt=255-J,ut=at-J;O=J+(O-J)*pt/ut,R=J+(R-J)*pt/ut,$=J+($-J)*pt/ut}}function j(W,q,G){return c(W,q,G)-i(W,q,G)}function F(W,q,G,J){var nt=[W,q,G],ot=c(W,q,G),at=i(W,q,G),lt;at=at===W?0:at===q?1:2,ot=ot===W?0:ot===q?1:2,lt=i(at,ot)===0?c(at,ot)===1?2:1:0,nt[ot]>nt[at]?(nt[lt]=(nt[lt]-nt[at])*J/(nt[ot]-nt[at]),nt[ot]=J):nt[lt]=nt[ot]=0,nt[at]=0,O=nt[0],R=nt[1],$=nt[2]}var V={multiply:function(){O=w*g/255,R=S*x/255,$=I*b/255},screen:function(){O=w+g-w*g/255,R=S+x-S*x/255,$=I+b-I*b/255},overlay:function(){O=w<128?2*w*g/255:255-2*(255-w)*(255-g)/255,R=S<128?2*S*x/255:255-2*(255-S)*(255-x)/255,$=I<128?2*I*b/255:255-2*(255-I)*(255-b)/255},"soft-light":function(){var W=g*w/255;O=W+w*(255-(255-w)*(255-g)/255-W)/255,W=x*S/255,R=W+S*(255-(255-S)*(255-x)/255-W)/255,W=b*I/255,$=W+I*(255-(255-I)*(255-b)/255-W)/255},"hard-light":function(){O=g<128?2*g*w/255:255-2*(255-g)*(255-w)/255,R=x<128?2*x*S/255:255-2*(255-x)*(255-S)/255,$=b<128?2*b*I/255:255-2*(255-b)*(255-I)/255},"color-dodge":function(){O=w===0?0:g===255?255:i(255,255*w/(255-g)),R=S===0?0:x===255?255:i(255,255*S/(255-x)),$=I===0?0:b===255?255:i(255,255*I/(255-b))},"color-burn":function(){O=w===255?255:g===0?0:c(0,255-(255-w)*255/g),R=S===255?255:x===0?0:c(0,255-(255-S)*255/x),$=I===255?255:b===0?0:c(0,255-(255-I)*255/b)},darken:function(){O=w<g?w:g,R=S<x?S:x,$=I<b?I:b},lighten:function(){O=w>g?w:g,R=S>x?S:x,$=I>b?I:b},difference:function(){O=w-g,O<0&&(O=-O),R=S-x,R<0&&(R=-R),$=I-b,$<0&&($=-$)},exclusion:function(){O=w+g*(255-w-w)/255,R=S+x*(255-S-S)/255,$=I+b*(255-I-I)/255},hue:function(){F(g,x,b,j(w,S,I)),z(O,R,$,U(w,S,I))},saturation:function(){F(w,S,I,j(g,x,b)),z(O,R,$,U(w,S,I))},luminosity:function(){z(w,S,I,U(g,x,b))},color:function(){z(g,x,b,U(w,S,I))},add:function(){O=i(w+g,255),R=i(S+x,255),$=i(I+b,255)},subtract:function(){O=c(w-g,0),R=c(S-x,0),$=c(I-b,0)},average:function(){O=(w+g)/2,R=(S+x)/2,$=(I+b)/2},negation:function(){O=255-h(255-g-w),R=255-h(255-x-S),$=255-h(255-b-I)}},T=this.nativeModes=s.each(["source-over","source-in","source-out","source-atop","destination-over","destination-in","destination-out","destination-atop","lighter","darker","copy","xor"],function(W){this[W]=!0},{}),M=Pe.getContext(1,1);M&&(s.each(V,function(W,q){var G=q==="darken",J=!1;M.save();try{M.fillStyle=G?"#300":"#a00",M.fillRect(0,0,1,1),M.globalCompositeOperation=q,M.globalCompositeOperation===q&&(M.fillStyle=G?"#a00":"#300",M.fillRect(0,0,1,1),J=M.getImageData(0,0,1,1).data[0]!==G?170:51)}catch(nt){}M.restore(),T[q]=J}),Pe.release(M)),this.process=function(W,q,G,J,nt){var ot=q.canvas,at=W==="normal";if(at||T[W])G.save(),G.setTransform(1,0,0,1,0,0),G.globalAlpha=J,at||(G.globalCompositeOperation=W),G.drawImage(ot,nt.x,nt.y),G.restore();else{var lt=V[W];if(!lt)return;for(var pt=G.getImageData(nt.x,nt.y,ot.width,ot.height),ut=pt.data,gt=q.getImageData(0,0,ot.width,ot.height).data,bt=0,kt=ut.length;bt<kt;bt+=4){g=gt[bt],w=ut[bt],x=gt[bt+1],S=ut[bt+1],b=gt[bt+2],I=ut[bt+2],k=gt[bt+3],D=ut[bt+3],lt();var Rt=k*J/255,Wt=1-Rt;ut[bt]=Rt*O+Wt*w,ut[bt+1]=Rt*R+Wt*S,ut[bt+2]=Rt*$+Wt*I,ut[bt+3]=k*J+Wt*D}G.putImageData(pt,nt.x,nt.y)}}},Ue=new function(){var i="http://www.w3.org/2000/svg",c="http://www.w3.org/2000/xmlns",h="http://www.w3.org/1999/xlink",g={href:h,xlink:c,xmlns:c+"/","xmlns:xlink":c+"/"};function x(w,S,I){return k(n.createElementNS(i,w),S,I)}function b(w,S){var I=g[S],D=I?w.getAttributeNS(I,S):w.getAttribute(S);return D==="null"?null:D}function k(w,S,I){for(var D in S){var O=S[D],R=g[D];typeof O=="number"&&I&&(O=I.number(O)),R?w.setAttributeNS(R,D,O):w.setAttribute(D,O)}return w}return{svg:i,xmlns:c,xlink:h,create:x,get:b,set:k}},Ls=s.each({fillColor:["fill","color"],fillRule:["fill-rule","string"],strokeColor:["stroke","color"],strokeWidth:["stroke-width","number"],strokeCap:["stroke-linecap","string"],strokeJoin:["stroke-linejoin","string"],strokeScaling:["vector-effect","lookup",{true:"none",false:"non-scaling-stroke"},function(i,c){return!c&&(i instanceof Ft||i instanceof et||i instanceof jt)}],miterLimit:["stroke-miterlimit","number"],dashArray:["stroke-dasharray","array"],dashOffset:["stroke-dashoffset","number"],fontFamily:["font-family","string"],fontWeight:["font-weight","string"],fontSize:["font-size","number"],justification:["text-anchor","lookup",{left:"start",center:"middle",right:"end"}],opacity:["opacity","number"],blendMode:["mix-blend-mode","style"]},function(i,c){var h=s.capitalize(c),g=i[2];this[c]={type:i[1],property:c,attribute:i[0],toSVG:g,fromSVG:g&&s.each(g,function(x,b){this[x]=b},{}),exportFilter:i[3],get:"get"+h,set:"set"+h}},{});new function(){var i;function c(V,T,M){var W=new s,q=V.getTranslation();if(T){var G;V.isInvertible()?(V=V._shiftless(),G=V._inverseTransform(q),q=null):G=new d,W[M?"cx":"x"]=G.x,W[M?"cy":"y"]=G.y}if(!V.isIdentity()){var J=V.decompose();if(J){var nt=[],ot=J.rotation,at=J.scaling,lt=J.skewing;q&&!q.isZero()&&nt.push("translate("+i.point(q)+")"),ot&&nt.push("rotate("+i.number(ot)+")"),(!f.isZero(at.x-1)||!f.isZero(at.y-1))&&nt.push("scale("+i.point(at)+")"),lt.x&&nt.push("skewX("+i.number(lt.x)+")"),lt.y&&nt.push("skewY("+i.number(lt.y)+")"),W.transform=nt.join(" ")}else W.transform="matrix("+V.getValues().join(",")+")"}return W}function h(V,T){for(var M=c(V._matrix),W=V._children,q=Ue.create("g",M,i),G=0,J=W.length;G<J;G++){var nt=W[G],ot=j(nt,T);if(ot)if(nt.isClipMask()){var at=Ue.create("clipPath");at.appendChild(ot),U(nt,at,"clip"),Ue.set(q,{"clip-path":"url(#"+at.id+")"})}else q.appendChild(ot)}return q}function g(V,T){var M=c(V._matrix,!0),W=V.getSize(),q=V.getImage();return M.x-=W.width/2,M.y-=W.height/2,M.width=W.width,M.height=W.height,M.href=T.embedImages==!1&&q&&q.src||V.toDataURL(),Ue.create("image",M,i)}function x(V,T){var M=T.matchShapes;if(M){var W=V.toShape(!1);if(W)return b(W,T)}var q=V._segments,G=q.length,J,nt=c(V._matrix);if(M&&G>=2&&!V.hasHandles())if(G>2){J=V._closed?"polygon":"polyline";for(var ot=[],at=0;at<G;at++)ot.push(i.point(q[at]._point));nt.points=ot.join(" ")}else{J="line";var lt=q[0]._point,pt=q[1]._point;nt.set({x1:lt.x,y1:lt.y,x2:pt.x,y2:pt.y})}else J="path",nt.d=V.getPathData(null,T.precision);return Ue.create(J,nt,i)}function b(V){var T=V._type,M=V._radius,W=c(V._matrix,!0,T!=="rectangle");if(T==="rectangle"){T="rect";var q=V._size,G=q.width,J=q.height;W.x-=G/2,W.y-=J/2,W.width=G,W.height=J,M.isZero()&&(M=null)}return M&&(T==="circle"?W.r=M:(W.rx=M.width,W.ry=M.height)),Ue.create(T,W,i)}function k(V,T){var M=c(V._matrix),W=V.getPathData(null,T.precision);return W&&(M.d=W),Ue.create("path",M,i)}function w(V,T){var M=c(V._matrix,!0),W=V._definition,q=$(W,"symbol"),G=W._item,J=G.getStrokeBounds();return q||(q=Ue.create("symbol",{viewBox:i.rectangle(J)}),q.appendChild(j(G,T)),U(W,q,"symbol")),M.href="#"+q.id,M.x+=J.x,M.y+=J.y,M.width=J.width,M.height=J.height,M.overflow="visible",Ue.create("use",M,i)}function S(V){var T=$(V,"color");if(!T){var M=V.getGradient(),W=M._radial,q=V.getOrigin(),G=V.getDestination(),J;if(W){J={cx:q.x,cy:q.y,r:q.getDistance(G)};var nt=V.getHighlight();nt&&(J.fx=nt.x,J.fy=nt.y)}else J={x1:q.x,y1:q.y,x2:G.x,y2:G.y};J.gradientUnits="userSpaceOnUse",T=Ue.create((W?"radial":"linear")+"Gradient",J,i);for(var ot=M._stops,at=0,lt=ot.length;at<lt;at++){var pt=ot[at],ut=pt._color,gt=ut.getAlpha(),bt=pt._offset;J={offset:bt??at/(lt-1)},ut&&(J["stop-color"]=ut.toCSS(!0)),gt<1&&(J["stop-opacity"]=gt),T.appendChild(Ue.create("stop",J,i))}U(V,T,"color")}return"url(#"+T.id+")"}function I(V){var T=Ue.create("text",c(V._matrix,!0),i);return T.textContent=V._content,T}var D={Group:h,Layer:h,Raster:g,Path:x,Shape:b,CompoundPath:k,SymbolItem:w,PointText:I};function O(V,T,M){var W={},q=!M&&V.getParent(),G=[];return V._name!=null&&(W.id=V._name),s.each(Ls,function(J){var nt=J.get,ot=J.type,at=V[nt]();if(J.exportFilter?J.exportFilter(V,at):!q||!s.equals(q[nt](),at)){if(ot==="color"&&at!=null){var lt=at.getAlpha();lt<1&&(W[J.attribute+"-opacity"]=lt)}ot==="style"?G.push(J.attribute+": "+at):W[J.attribute]=at==null?"none":ot==="color"?at.gradient?S(at,V):at.toCSS(!0):ot==="array"?at.join(","):ot==="lookup"?J.toSVG[at]:at}}),G.length&&(W.style=G.join(";")),W.opacity===1&&delete W.opacity,V._visible||(W.visibility="hidden"),Ue.set(T,W,i)}var R;function $(V,T){return R||(R={ids:{},svgs:{}}),V&&R.svgs[T+"-"+(V._id||V.__id||(V.__id=m.get("svg")))]}function U(V,T,M){R||$();var W=R.ids[M]=(R.ids[M]||0)+1;T.id=M+"-"+W,R.svgs[M+"-"+(V._id||V.__id)]=T}function z(V,T){var M=V,W=null;if(R){M=V.nodeName.toLowerCase()==="svg"&&V;for(var q in R.svgs)W||(M||(M=Ue.create("svg"),M.appendChild(V)),W=M.insertBefore(Ue.create("defs"),M.firstChild)),W.appendChild(R.svgs[q]);R=null}return T.asString?new r.XMLSerializer().serializeToString(M):M}function j(V,T,M){var W=D[V._class],q=W&&W(V,T);if(q){var G=T.onExport;G&&(q=G(V,q,T)||q);var J=JSON.stringify(V._data);J&&J!=="{}"&&J!=="null"&&q.setAttribute("data-paper-data",J)}return q&&O(V,q,M)}function F(V){return V||(V={}),i=new p(V.precision),V}L.inject({exportSVG:function(V){return V=F(V),z(j(this,V,!0),V)}}),P.inject({exportSVG:function(V){V=F(V);var T=this._children,M=this.getView(),W=s.pick(V.bounds,"view"),q=V.matrix||W==="view"&&M._matrix,G=q&&A.read([q]),J=W==="view"?new C([0,0],M.getViewSize()):W==="content"?L._getBounds(T,G,{stroke:!0}).rect:C.read([W],0,{readNull:!0}),nt={version:"1.1",xmlns:Ue.svg,"xmlns:xlink":Ue.xlink};J&&(nt.width=J.width,nt.height=J.height,(J.x||J.x===0||J.y||J.y===0)&&(nt.viewBox=i.rectangle(J)));var ot=Ue.create("svg",nt,i),at=ot;G&&!G.isIdentity()&&(at=ot.appendChild(Ue.create("g",c(G),i)));for(var lt=0,pt=T.length;lt<pt;lt++)at.appendChild(j(T[lt],V,!0));return z(ot,V)}})},new function(){var i={},c;function h(T,M,W,q,G,J){var nt=Ue.get(T,M)||J,ot=nt==null?q?null:W?"":0:W?nt:parseFloat(nt);return/%\s*$/.test(nt)?ot/100*(G?1:c[/x|^width/.test(M)?"width":"height"]):ot}function g(T,M,W,q,G,J,nt){return M=h(T,M||"x",!1,q,G,J),W=h(T,W||"y",!1,q,G,nt),q&&(M==null||W==null)?null:new d(M,W)}function x(T,M,W,q,G){return M=h(T,M||"width",!1,q,G),W=h(T,W||"height",!1,q,G),q&&(M==null||W==null)?null:new _(M,W)}function b(T,M,W){return T==="none"?null:M==="number"?parseFloat(T):M==="array"?T?T.split(/[\s,]+/g).map(parseFloat):[]:M==="color"?j(T)||T:M==="lookup"?W[T]:T}function k(T,M,W,q){var G=T.childNodes,J=M==="clippath",nt=M==="defs",ot=new Z,at=ot._project,lt=at._currentStyle,pt=[];if(!J&&!nt&&(ot=z(ot,T,q),at._currentStyle=ot._style.clone()),q)for(var ut=T.querySelectorAll("defs"),gt=0,bt=ut.length;gt<bt;gt++)F(ut[gt],W,!1);for(var gt=0,bt=G.length;gt<bt;gt++){var kt=G[gt],Rt;kt.nodeType===1&&!/^defs$/i.test(kt.nodeName)&&(Rt=F(kt,W,!1))&&!(Rt instanceof wt)&&pt.push(Rt)}return ot.addChildren(pt),J&&(ot=z(ot.reduce(),T,q)),at._currentStyle=lt,(J||nt)&&(ot.remove(),ot=null),ot}function w(T,M){for(var W=T.getAttribute("points").match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),q=[],G=0,J=W.length;G<J;G+=2)q.push(new d(parseFloat(W[G]),parseFloat(W[G+1])));var nt=new Ct(q);return M==="polygon"&&nt.closePath(),nt}function S(T){return Ft.create(T.getAttribute("d"))}function I(T,M){var W=(h(T,"href",!0)||"").substring(1),q=M==="radialgradient",G;if(W)G=i[W].getGradient(),G._radial^q&&(G=G.clone(),G._radial=q);else{for(var J=T.childNodes,nt=[],ot=0,at=J.length;ot<at;ot++){var lt=J[ot];lt.nodeType===1&&nt.push(z(new Zt,lt))}G=new Ht(nt,q)}var pt,ut,gt,bt=h(T,"gradientUnits",!0)!=="userSpaceOnUse";q?(pt=g(T,"cx","cy",!1,bt,"50%","50%"),ut=pt.add(h(T,"r",!1,!1,bt,"50%"),0),gt=g(T,"fx","fy",!0,bt)):(pt=g(T,"x1","y1",!1,bt,"0%","0%"),ut=g(T,"x2","y2",!1,bt,"100%","0%"));var kt=z(new Bt(G,pt,ut,gt),T);return kt._scaleToBounds=bt,null}var D={"#document":function(T,M,W,q){for(var G=T.childNodes,J=0,nt=G.length;J<nt;J++){var ot=G[J];if(ot.nodeType===1)return F(ot,W,q)}},g:k,svg:k,clippath:k,polygon:w,polyline:w,path:S,lineargradient:I,radialgradient:I,image:function(T){var M=new it(h(T,"href",!0));return M.on("load",function(){var W=x(T);this.setSize(W);var q=g(T).add(W.divide(2));this._matrix.append(new A().translate(q))}),M},symbol:function(T,M,W,q){return new wt(k(T,M,W,q),!0)},defs:k,use:function(T){var M=(h(T,"href",!0)||"").substring(1),W=i[M],q=g(T);return W?W instanceof wt?W.place(q):W.clone().translate(q):null},circle:function(T){return new et.Circle(g(T,"cx","cy"),h(T,"r"))},ellipse:function(T){return new et.Ellipse({center:g(T,"cx","cy"),radius:x(T,"rx","ry")})},rect:function(T){return new et.Rectangle(new C(g(T),x(T)),x(T,"rx","ry"))},line:function(T){return new Ct.Line(g(T,"x1","y1"),g(T,"x2","y2"))},text:function(T){var M=new qt(g(T).add(g(T,"dx","dy")));return M.setContent(T.textContent.trim()||""),M},switch:k};function O(T,M,W,q){if(T.transform){for(var G=(q.getAttribute(W)||"").split(/\)\s*/g),J=new A,nt=0,ot=G.length;nt<ot;nt++){var at=G[nt];if(!at)break;for(var lt=at.split(/\(\s*/),pt=lt[0],ut=lt[1].split(/[\s,]+/g),gt=0,bt=ut.length;gt<bt;gt++)ut[gt]=parseFloat(ut[gt]);switch(pt){case"matrix":J.append(new A(ut[0],ut[1],ut[2],ut[3],ut[4],ut[5]));break;case"rotate":J.rotate(ut[0],ut[1]||0,ut[2]||0);break;case"translate":J.translate(ut[0],ut[1]||0);break;case"scale":J.scale(ut);break;case"skewX":J.skew(ut[0],0);break;case"skewY":J.skew(0,ut[0]);break}}T.transform(J)}}function R(T,M,W){var q=W==="fill-opacity"?"getFillColor":"getStrokeColor",G=T[q]&&T[q]();G&&G.setAlpha(parseFloat(M))}var $=s.set(s.each(Ls,function(T){this[T.attribute]=function(M,W){if(M[T.set]&&(M[T.set](b(W,T.type,T.fromSVG)),T.type==="color")){var q=M[T.get]();if(q&&q._scaleToBounds){var G=M.getBounds();q.transform(new A().translate(G.getPoint()).scale(G.getSize()))}}}},{}),{id:function(T,M){i[M]=T,T.setName&&T.setName(M)},"clip-path":function(T,M){var W=j(M);if(W)if(W=W.clone(),W.setClipMask(!0),T instanceof Z)T.insertChild(0,W);else return new Z(W,T)},gradientTransform:O,transform:O,"fill-opacity":R,"stroke-opacity":R,visibility:function(T,M){T.setVisible&&T.setVisible(M==="visible")},display:function(T,M){T.setVisible&&T.setVisible(M!==null)},"stop-color":function(T,M){T.setColor&&T.setColor(M)},"stop-opacity":function(T,M){T._color&&T._color.setAlpha(parseFloat(M))},offset:function(T,M){if(T.setOffset){var W=M.match(/(.*)%$/);T.setOffset(W?W[1]/100:parseFloat(M))}},viewBox:function(T,M,W,q,G){var J=new C(b(M,"array")),nt=x(q,null,null,!0),ot,at;if(T instanceof Z){var lt=nt?nt.divide(J.getSize()):1,at=new A().scale(lt).translate(J.getPoint().negate());ot=T}else T instanceof wt&&(nt&&J.setSize(nt),ot=T._item);if(ot){if(U(q,"overflow",G)!=="visible"){var pt=new et.Rectangle(J);pt.setClipMask(!0),ot.addChild(pt)}at&&ot.transform(at)}}});function U(T,M,W){var q=T.attributes[M],G=q&&q.value;if(!G&&T.style){var J=s.camelize(M);G=T.style[J],!G&&W.node[J]!==W.parent[J]&&(G=W.node[J])}return G?G==="none"?null:G:t}function z(T,M,W){var q=M.parentNode,G={node:Qt.getStyles(M)||{},parent:!W&&!/^defs$/i.test(q.tagName)&&Qt.getStyles(q)||{}};return s.each($,function(J,nt){var ot=U(M,nt,G);T=ot!==t&&J(T,ot,nt,M,G)||T}),T}function j(T){var M=T&&T.match(/\((?:["'#]*)([^"')]+)/),W=M&&M[1],q=W&&i[e?W.replace(e.location.href.split("#")[0]+"#",""):W];return q&&q._scaleToBounds&&(q=q.clone(),q._scaleToBounds=!0),q}function F(T,M,W){var q=T.nodeName.toLowerCase(),G=q!=="#document",J=n.body,nt,ot,at;W&&G&&(c=ye.getView().getSize(),c=x(T,null,null,!0)||c,nt=Ue.create("svg",{style:"stroke-width: 1px; stroke-miterlimit: 10"}),ot=T.parentNode,at=T.nextSibling,nt.appendChild(T),J.appendChild(nt));var lt=ye.settings,pt=lt.applyMatrix,ut=lt.insertItems;lt.applyMatrix=!1,lt.insertItems=!1;var gt=D[q],bt=gt&&gt(T,q,M,W)||null;if(lt.insertItems=ut,lt.applyMatrix=pt,bt){G&&!(bt instanceof Z)&&(bt=z(bt,T,W));var kt=M.onImport,Rt=G&&T.getAttribute("data-paper-data");kt&&(bt=kt(T,bt,M)||bt),M.expandShapes&&bt instanceof et&&(bt.remove(),bt=bt.toPath()),Rt&&(bt._data=JSON.parse(Rt))}return nt&&(J.removeChild(nt),ot&&(at?ot.insertBefore(T,at):ot.appendChild(T))),W&&(i={},bt&&s.pick(M.applyMatrix,pt)&&bt.matrix.apply(!0,!0)),bt}function V(T,M,W){if(!T)return null;M=typeof M=="function"?{onLoad:M}:M||{};var q=ye,G=null;function J(lt){try{var pt=typeof lt=="object"?lt:new r.DOMParser().parseFromString(lt.trim(),"image/svg+xml");if(!pt.nodeName)throw pt=null,new Error("Unsupported SVG source: "+T);ye=q,G=F(pt,M,!0),(!M||M.insert!==!1)&&W._insertItem(t,G);var ut=M.onLoad;ut&&ut(G,lt)}catch(gt){nt(gt)}}function nt(lt,pt){var ut=M.onError;if(ut)ut(lt,pt);else throw new Error(lt)}if(typeof T=="string"&&!/^[\s\S]*</.test(T)){var ot=n.getElementById(T);ot?J(ot):Kn.request({url:T,async:!0,onLoad:J,onError:nt})}else if(typeof File!="undefined"&&T instanceof File){var at=new FileReader;return at.onload=function(){J(at.result)},at.onerror=function(){nt(at.error)},at.readAsText(T)}else J(T);return G}L.inject({importSVG:function(T,M){return V(T,M,this)}}),P.inject({importSVG:function(T,M){return this.activate(),V(T,M,this)}})},s.exports.PaperScript=function(){var i=this,c=i.acorn;if(!c&&!0)try{c=require("acorn")}catch(z){}if(!c){var h,g;c=h=g={},function(z,j){if(typeof h=="object"&&typeof g=="object")return j(h);if(typeof define=="function"&&define.amd)return define(["exports"],j);j(z.acorn||(z.acorn={}))}(this,function(z){"use strict";z.version="0.5.0";var j,F,V,T;z.parse=function(st,mt){return F=String(st),V=F.length,W(mt),$0(),sF(j.program)};var M=z.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,allowReturnOutsideFunction:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null,directSourceFile:null};function W(st){j=st||{};for(var mt in M)Object.prototype.hasOwnProperty.call(j,mt)||(j[mt]=M[mt]);T=j.sourceFile||null}var q=z.getLineInfo=function(st,mt){for(var Tt=1,Lt=0;;){Ul.lastIndex=Lt;var ge=Ul.exec(st);if(ge&&ge.index<mt)++Tt,Lt=ge.index+ge[0].length;else break}return{line:Tt,column:mt-Lt}};z.tokenize=function(st,mt){F=String(st),V=F.length,W(mt),$0();var Tt={};function Lt(ge){return Rt=nt,Ua(ge),Tt.start=J,Tt.end=nt,Tt.startLoc=ot,Tt.endLoc=at,Tt.type=lt,Tt.value=pt,Tt}return Lt.jumpTo=function(ge,Ce){if(G=ge,j.locations){gt=1,bt=Ul.lastIndex=0;for(var Ie;(Ie=Ul.exec(F))&&Ie.index<ge;)++gt,bt=Ie.index+Ie[0].length}ut=Ce,jl()},Lt};var G,J,nt,ot,at,lt,pt,ut,gt,bt,kt,Rt,Wt,Kt,Yt,Et;function Pt(st,mt){var Tt=q(F,st);mt+=" ("+Tt.line+":"+Tt.column+")";var Lt=new SyntaxError(mt);throw Lt.pos=st,Lt.loc=Tt,Lt.raisedAt=G,Lt}var Ut=[],se={type:"num"},Jt={type:"regexp"},de={type:"string"},me={type:"name"},Se={type:"eof"},Ee={keyword:"break"},ke={keyword:"case",beforeExpr:!0},Lr={keyword:"catch"},zr={keyword:"continue"},en={keyword:"debugger"},Tr={keyword:"default"},ir={keyword:"do",isLoop:!0},Er={keyword:"else",beforeExpr:!0},En={keyword:"finally"},Mr={keyword:"for",isLoop:!0},Xn={keyword:"function"},_i={keyword:"if"},hs={keyword:"return",beforeExpr:!0},ms={keyword:"switch"},An={keyword:"throw",beforeExpr:!0},Ln={keyword:"try"},bi={keyword:"var"},ds={keyword:"while",isLoop:!0},If={keyword:"with"},y0={keyword:"new",beforeExpr:!0},_0={keyword:"this"},b0={keyword:"null",atomValue:null},v0={keyword:"true",atomValue:!0},w0={keyword:"false",atomValue:!1},Nf={keyword:"in",binop:7,beforeExpr:!0},hg={break:Ee,case:ke,catch:Lr,continue:zr,debugger:en,default:Tr,do:ir,else:Er,finally:En,for:Mr,function:Xn,if:_i,return:hs,switch:ms,throw:An,try:Ln,var:bi,while:ds,with:If,null:b0,true:v0,false:w0,new:y0,in:Nf,instanceof:{keyword:"instanceof",binop:7,beforeExpr:!0},this:_0,typeof:{keyword:"typeof",prefix:!0,beforeExpr:!0},void:{keyword:"void",prefix:!0,beforeExpr:!0},delete:{keyword:"delete",prefix:!0,beforeExpr:!0}},Tf={type:"[",beforeExpr:!0},Ef={type:"]"},Gl={type:"{",beforeExpr:!0},Va={type:"}"},zs={type:"(",beforeExpr:!0},gs={type:")"},oo={type:",",beforeExpr:!0},Ms={type:";",beforeExpr:!0},Wl={type:":",beforeExpr:!0},mg={type:"."},dg={type:"?",beforeExpr:!0},gg={binop:10,beforeExpr:!0},xg={isAssign:!0,beforeExpr:!0},Ga={isAssign:!0,beforeExpr:!0},$R={postfix:!0,prefix:!0,isUpdate:!0},C0={prefix:!0,beforeExpr:!0},k0={binop:1,beforeExpr:!0},S0={binop:2,beforeExpr:!0},DR={binop:3,beforeExpr:!0},RR={binop:4,beforeExpr:!0},FR={binop:5,beforeExpr:!0},OR={binop:6,beforeExpr:!0},PR={binop:7,beforeExpr:!0},LR={binop:8,beforeExpr:!0},zR={binop:9,prefix:!0,beforeExpr:!0},MR={binop:10,beforeExpr:!0};z.tokTypes={bracketL:Tf,bracketR:Ef,braceL:Gl,braceR:Va,parenL:zs,parenR:gs,comma:oo,semi:Ms,colon:Wl,dot:mg,question:dg,slash:gg,eq:xg,name:me,eof:Se,num:se,regexp:Jt,string:de};for(var I0 in hg)z.tokTypes["_"+I0]=hg[I0];function zc(st){st=st.split(" ");var mt="",Tt=[];t:for(var Lt=0;Lt<st.length;++Lt){for(var ge=0;ge<Tt.length;++ge)if(Tt[ge][0].length==st[Lt].length){Tt[ge].push(st[Lt]);continue t}Tt.push([st[Lt]])}function Ce(Ze){if(Ze.length==1)return mt+="return str === "+JSON.stringify(Ze[0])+";";mt+="switch(str){";for(var ys=0;ys<Ze.length;++ys)mt+="case "+JSON.stringify(Ze[ys])+":";mt+="return true}return false;"}if(Tt.length>3){Tt.sort(function(Ze,ys){return ys.length-Ze.length}),mt+="switch(str.length){";for(var Lt=0;Lt<Tt.length;++Lt){var Ie=Tt[Lt];mt+="case "+Ie[0].length+":",Ce(Ie)}mt+="}"}else Ce(st);return new Function("str",mt)}var BR=zc("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),VR=zc("class enum extends super const export import"),N0=zc("implements interface let package private protected public static yield"),Af=zc("eval arguments"),GR=zc("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),WR=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/,T0="\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F0\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC",UR="\u0300-\u036F\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u0620-\u0649\u0672-\u06D3\u06E7-\u06E8\u06FB-\u06FC\u0730-\u074A\u0800-\u0814\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0840-\u0857\u08E4-\u08FE\u0900-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962-\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09D7\u09DF-\u09E0\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2-\u0AE3\u0AE6-\u0AEF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5F-\u0B60\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C01-\u0C03\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62-\u0C63\u0C66-\u0C6F\u0C82\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2-\u0CE3\u0CE6-\u0CEF\u0D02\u0D03\u0D46-\u0D48\u0D57\u0D62-\u0D63\u0D66-\u0D6F\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E34-\u0E3A\u0E40-\u0E45\u0E50-\u0E59\u0EB4-\u0EB9\u0EC8-\u0ECD\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F41-\u0F47\u0F71-\u0F84\u0F86-\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1029\u1040-\u1049\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u170E-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17B2\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1920-\u192B\u1930-\u193B\u1951-\u196D\u19B0-\u19C0\u19C8-\u19C9\u19D0-\u19D9\u1A00-\u1A15\u1A20-\u1A53\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1B46-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C00-\u1C22\u1C40-\u1C49\u1C5B-\u1C7D\u1CD0-\u1CD2\u1D00-\u1DBE\u1E01-\u1F15\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2D81-\u2D96\u2DE0-\u2DFF\u3021-\u3028\u3099\u309A\uA640-\uA66D\uA674-\uA67D\uA69F\uA6F0-\uA6F1\uA7F8-\uA800\uA806\uA80B\uA823-\uA827\uA880-\uA881\uA8B4-\uA8C4\uA8D0-\uA8D9\uA8F3-\uA8F7\uA900-\uA909\uA926-\uA92D\uA930-\uA945\uA980-\uA983\uA9B3-\uA9C0\uAA00-\uAA27\uAA40-\uAA41\uAA4C-\uAA4D\uAA50-\uAA59\uAA7B\uAAE0-\uAAE9\uAAF2-\uAAF3\uABC0-\uABE1\uABEC\uABED\uABF0-\uABF9\uFB20-\uFB28\uFE00-\uFE0F\uFE20-\uFE26\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F",E0=new RegExp("["+T0+"]"),jR=new RegExp("["+T0+UR+"]"),$f=/[\n\r\u2028\u2029]/,Ul=/\r\n|[\n\r\u2028\u2029]/g,Df=z.isIdentifierStart=function(st){return st<65?st===36:st<91?!0:st<97?st===95:st<123?!0:st>=170&&E0.test(String.fromCharCode(st))},A0=z.isIdentifierChar=function(st){return st<48?st===36:st<58?!0:st<65?!1:st<91?!0:st<97?st===95:st<123?!0:st>=170&&jR.test(String.fromCharCode(st))};function Wa(){this.line=gt,this.column=G-bt}function $0(){gt=1,G=bt=0,ut=!0,jl()}function Ur(st,mt){nt=G,j.locations&&(at=new Wa),lt=st,jl(),pt=mt,ut=st.beforeExpr}function qR(){var st=j.onComment&&j.locations&&new Wa,mt=G,Tt=F.indexOf("*/",G+=2);if(Tt===-1&&Pt(G-2,"Unterminated comment"),G=Tt+2,j.locations){Ul.lastIndex=mt;for(var Lt;(Lt=Ul.exec(F))&&Lt.index<G;)++gt,bt=Lt.index+Lt[0].length}j.onComment&&j.onComment(!0,F.slice(mt+2,Tt),mt,G,st,j.locations&&new Wa)}function yg(){for(var st=G,mt=j.onComment&&j.locations&&new Wa,Tt=F.charCodeAt(G+=2);G<V&&Tt!==10&&Tt!==13&&Tt!==8232&&Tt!==8233;)++G,Tt=F.charCodeAt(G);j.onComment&&j.onComment(!1,F.slice(st+2,G),st,G,mt,j.locations&&new Wa)}function jl(){for(;G<V;){var st=F.charCodeAt(G);if(st===32)++G;else if(st===13){++G;var mt=F.charCodeAt(G);mt===10&&++G,j.locations&&(++gt,bt=G)}else if(st===10||st===8232||st===8233)++G,j.locations&&(++gt,bt=G);else if(st>8&&st<14)++G;else if(st===47){var mt=F.charCodeAt(G+1);if(mt===42)qR();else if(mt===47)yg();else break}else if(st===160)++G;else if(st>=5760&&WR.test(String.fromCharCode(st)))++G;else break}}function HR(){var st=F.charCodeAt(G+1);return st>=48&&st<=57?R0(!0):(++G,Ur(mg))}function KR(){var st=F.charCodeAt(G+1);return ut?(++G,D0()):st===61?jr(Ga,2):jr(gg,1)}function XR(){var st=F.charCodeAt(G+1);return st===61?jr(Ga,2):jr(MR,1)}function YR(st){var mt=F.charCodeAt(G+1);return mt===st?jr(st===124?k0:S0,2):mt===61?jr(Ga,2):jr(st===124?DR:FR,1)}function ZR(){var st=F.charCodeAt(G+1);return st===61?jr(Ga,2):jr(RR,1)}function JR(st){var mt=F.charCodeAt(G+1);return mt===st?mt==45&&F.charCodeAt(G+2)==62&&$f.test(F.slice(Rt,G))?(G+=3,yg(),jl(),Ua()):jr($R,2):mt===61?jr(Ga,2):jr(zR,1)}function QR(st){var mt=F.charCodeAt(G+1),Tt=1;return mt===st?(Tt=st===62&&F.charCodeAt(G+2)===62?3:2,F.charCodeAt(G+Tt)===61?jr(Ga,Tt+1):jr(LR,Tt)):mt==33&&st==60&&F.charCodeAt(G+2)==45&&F.charCodeAt(G+3)==45?(G+=4,yg(),jl(),Ua()):(mt===61&&(Tt=F.charCodeAt(G+2)===61?3:2),jr(PR,Tt))}function tF(st){var mt=F.charCodeAt(G+1);return mt===61?jr(OR,F.charCodeAt(G+2)===61?3:2):jr(st===61?xg:C0,1)}function eF(st){switch(st){case 46:return HR();case 40:return++G,Ur(zs);case 41:return++G,Ur(gs);case 59:return++G,Ur(Ms);case 44:return++G,Ur(oo);case 91:return++G,Ur(Tf);case 93:return++G,Ur(Ef);case 123:return++G,Ur(Gl);case 125:return++G,Ur(Va);case 58:return++G,Ur(Wl);case 63:return++G,Ur(dg);case 48:var mt=F.charCodeAt(G+1);if(mt===120||mt===88)return rF();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return R0(!1);case 34:case 39:return nF(st);case 47:return KR(st);case 37:case 42:return XR();case 124:case 38:return YR(st);case 94:return ZR();case 43:case 45:return JR(st);case 60:case 62:return QR(st);case 61:case 33:return tF(st);case 126:return jr(C0,1)}return!1}function Ua(st){if(st?G=J+1:J=G,j.locations&&(ot=new Wa),st)return D0();if(G>=V)return Ur(Se);var mt=F.charCodeAt(G);if(Df(mt)||mt===92)return O0();var Tt=eF(mt);if(Tt===!1){var Lt=String.fromCharCode(mt);if(Lt==="\\"||E0.test(Lt))return O0();Pt(G,"Unexpected character '"+Lt+"'")}return Tt}function jr(st,mt){var Tt=F.slice(G,G+mt);G+=mt,Ur(st,Tt)}function D0(){for(var st="",mt,Tt,Lt=G;;){G>=V&&Pt(Lt,"Unterminated regular expression");var ge=F.charAt(G);if($f.test(ge)&&Pt(Lt,"Unterminated regular expression"),mt)mt=!1;else{if(ge==="[")Tt=!0;else if(ge==="]"&&Tt)Tt=!1;else if(ge==="/"&&!Tt)break;mt=ge==="\\"}++G}var st=F.slice(Lt,G);++G;var Ce=F0();Ce&&!/^[gmsiy]*$/.test(Ce)&&Pt(Lt,"Invalid regexp flag");try{var Ie=new RegExp(st,Ce)}catch(Ze){Ze instanceof SyntaxError&&Pt(Lt,Ze.message),Pt(Ze)}return Ur(Jt,Ie)}function Mc(st,mt){for(var Tt=G,Lt=0,ge=0,Ce=mt??Infinity;ge<Ce;++ge){var Ie=F.charCodeAt(G),Ze;if(Ie>=97?Ze=Ie-97+10:Ie>=65?Ze=Ie-65+10:Ie>=48&&Ie<=57?Ze=Ie-48:Ze=Infinity,Ze>=st)break;++G,Lt=Lt*st+Ze}return G===Tt||mt!=null&&G-Tt!==mt?null:Lt}function rF(){G+=2;var st=Mc(16);return st==null&&Pt(J+2,"Expected hexadecimal number"),Df(F.charCodeAt(G))&&Pt(G,"Identifier directly after number"),Ur(se,st)}function R0(st){var mt=G,Tt=!1,Lt=F.charCodeAt(G)===48;!st&&Mc(10)===null&&Pt(mt,"Invalid number"),F.charCodeAt(G)===46&&(++G,Mc(10),Tt=!0);var ge=F.charCodeAt(G);(ge===69||ge===101)&&(ge=F.charCodeAt(++G),(ge===43||ge===45)&&++G,Mc(10)===null&&Pt(mt,"Invalid number"),Tt=!0),Df(F.charCodeAt(G))&&Pt(G,"Identifier directly after number");var Ce=F.slice(mt,G),Ie;return Tt?Ie=parseFloat(Ce):!Lt||Ce.length===1?Ie=parseInt(Ce,10):/[89]/.test(Ce)||Et?Pt(mt,"Invalid number"):Ie=parseInt(Ce,8),Ur(se,Ie)}function nF(st){G++;for(var mt="";;){G>=V&&Pt(J,"Unterminated string constant");var Tt=F.charCodeAt(G);if(Tt===st)return++G,Ur(de,mt);if(Tt===92){Tt=F.charCodeAt(++G);var Lt=/^[0-7]+/.exec(F.slice(G,G+3));for(Lt&&(Lt=Lt[0]);Lt&&parseInt(Lt,8)>255;)Lt=Lt.slice(0,-1);if(Lt==="0"&&(Lt=null),++G,Lt)Et&&Pt(G-2,"Octal literal in strict mode"),mt+=String.fromCharCode(parseInt(Lt,8)),G+=Lt.length-1;else switch(Tt){case 110:mt+=`
`;break;case 114:mt+="\r";break;case 120:mt+=String.fromCharCode(Rf(2));break;case 117:mt+=String.fromCharCode(Rf(4));break;case 85:mt+=String.fromCharCode(Rf(8));break;case 116:mt+="	";break;case 98:mt+="\b";break;case 118:mt+="\v";break;case 102:mt+="\f";break;case 48:mt+="\0";break;case 13:F.charCodeAt(G)===10&&++G;case 10:j.locations&&(bt=G,++gt);break;default:mt+=String.fromCharCode(Tt);break}}else(Tt===13||Tt===10||Tt===8232||Tt===8233)&&Pt(J,"Unterminated string constant"),mt+=String.fromCharCode(Tt),++G}}function Rf(st){var mt=Mc(16,st);return mt===null&&Pt(J,"Bad character escape sequence"),mt}var ql;function F0(){ql=!1;for(var st,mt=!0,Tt=G;;){var Lt=F.charCodeAt(G);if(A0(Lt))ql&&(st+=F.charAt(G)),++G;else if(Lt===92){ql||(st=F.slice(Tt,G)),ql=!0,F.charCodeAt(++G)!=117&&Pt(G,"Expecting Unicode escape sequence \\uXXXX"),++G;var ge=Rf(4),Ce=String.fromCharCode(ge);Ce||Pt(G-1,"Invalid Unicode escape"),(mt?Df(ge):A0(ge))||Pt(G-4,"Invalid Unicode escape"),st+=Ce}else break;mt=!1}return ql?st:F.slice(Tt,G)}function O0(){var st=F0(),mt=me;return!ql&&GR(st)&&(mt=hg[st]),Ur(mt,st)}function He(){kt=J,Rt=nt,Wt=at,Ua()}function _g(st){if(Et=st,G=J,j.locations)for(;G<bt;)bt=F.lastIndexOf(`
`,bt-2)+1,--gt;jl(),Ua()}function P0(){this.type=null,this.start=J,this.end=null}function L0(){this.start=ot,this.end=null,T!==null&&(this.source=T)}function rn(){var st=new P0;return j.locations&&(st.loc=new L0),j.directSourceFile&&(st.sourceFile=j.directSourceFile),j.ranges&&(st.range=[J,0]),st}function vi(st){var mt=new P0;return mt.start=st.start,j.locations&&(mt.loc=new L0,mt.loc.start=st.loc.start),j.ranges&&(mt.range=[st.range[0],0]),mt}function Fe(st,mt){return st.type=mt,st.end=Rt,j.locations&&(st.loc.end=Wt),j.ranges&&(st.range[1]=Rt),st}function bg(st){return j.ecmaVersion>=5&&st.type==="ExpressionStatement"&&st.expression.type==="Literal"&&st.expression.value==="use strict"}function kr(st){if(lt===st)return He(),!0}function Ff(){return!j.strictSemicolons&&(lt===Se||lt===Va||$f.test(F.slice(Rt,J)))}function ja(){!kr(Ms)&&!Ff()&&io()}function Dr(st){lt===st?He():io()}function io(){Pt(J,"Unexpected token")}function Of(st){st.type!=="Identifier"&&st.type!=="MemberExpression"&&Pt(st.start,"Assigning to rvalue"),Et&&st.type==="Identifier"&&Af(st.name)&&Pt(st.start,"Assigning to "+st.name+" in strict mode")}function sF(st){kt=Rt=G,j.locations&&(Wt=new Wa),Kt=Et=null,Yt=[],Ua();var mt=st||rn(),Tt=!0;for(st||(mt.body=[]);lt!==Se;){var Lt=xs();mt.body.push(Lt),Tt&&bg(Lt)&&_g(!0),Tt=!1}return Fe(mt,"Program")}var vg={kind:"loop"},oF={kind:"switch"};function xs(){(lt===gg||lt===Ga&&pt=="/=")&&Ua(!0);var st=lt,mt=rn();switch(st){case Ee:case zr:He();var Tt=st===Ee;kr(Ms)||Ff()?mt.label=null:lt!==me?io():(mt.label=wi(),ja());for(var Lt=0;Lt<Yt.length;++Lt){var ge=Yt[Lt];if((mt.label==null||ge.name===mt.label.name)&&(ge.kind!=null&&(Tt||ge.kind==="loop")||mt.label&&Tt))break}return Lt===Yt.length&&Pt(mt.start,"Unsyntactic "+st.keyword),Fe(mt,Tt?"BreakStatement":"ContinueStatement");case en:return He(),ja(),Fe(mt,"DebuggerStatement");case ir:return He(),Yt.push(vg),mt.body=xs(),Yt.pop(),Dr(ds),mt.test=Bc(),ja(),Fe(mt,"DoWhileStatement");case Mr:if(He(),Yt.push(vg),Dr(zs),lt===Ms)return wg(mt,null);if(lt===bi){var Ce=rn();return He(),M0(Ce,!0),Fe(Ce,"VariableDeclaration"),Ce.declarations.length===1&&kr(Nf)?z0(mt,Ce):wg(mt,Ce)}var Ce=un(!1,!0);return kr(Nf)?(Of(Ce),z0(mt,Ce)):wg(mt,Ce);case Xn:return He(),Ng(mt,!0);case _i:return He(),mt.test=Bc(),mt.consequent=xs(),mt.alternate=kr(Er)?xs():null,Fe(mt,"IfStatement");case hs:return!Kt&&!j.allowReturnOutsideFunction&&Pt(J,"'return' outside of function"),He(),kr(Ms)||Ff()?mt.argument=null:(mt.argument=un(),ja()),Fe(mt,"ReturnStatement");case ms:He(),mt.discriminant=Bc(),mt.cases=[],Dr(Gl),Yt.push(oF);for(var Ie,Ze;lt!=Va;)if(lt===ke||lt===Tr){var ys=lt===ke;Ie&&Fe(Ie,"SwitchCase"),mt.cases.push(Ie=rn()),Ie.consequent=[],He(),ys?Ie.test=un():(Ze&&Pt(kt,"Multiple default clauses"),Ze=!0,Ie.test=null),Dr(Wl)}else Ie||io(),Ie.consequent.push(xs());return Ie&&Fe(Ie,"SwitchCase"),He(),Yt.pop(),Fe(mt,"SwitchStatement");case An:return He(),$f.test(F.slice(Rt,J))&&Pt(Rt,"Illegal newline after throw"),mt.argument=un(),ja(),Fe(mt,"ThrowStatement");case Ln:if(He(),mt.block=Vc(),mt.handler=null,lt===Lr){var qa=rn();He(),Dr(zs),qa.param=wi(),Et&&Af(qa.param.name)&&Pt(qa.param.start,"Binding "+qa.param.name+" in strict mode"),Dr(gs),qa.guard=null,qa.body=Vc(),mt.handler=Fe(qa,"CatchClause")}return mt.guardedHandlers=Ut,mt.finalizer=kr(En)?Vc():null,!mt.handler&&!mt.finalizer&&Pt(mt.start,"Missing catch or finally clause"),Fe(mt,"TryStatement");case bi:return He(),M0(mt),ja(),Fe(mt,"VariableDeclaration");case ds:return He(),mt.test=Bc(),Yt.push(vg),mt.body=xs(),Yt.pop(),Fe(mt,"WhileStatement");case If:return Et&&Pt(J,"'with' in strict mode"),He(),mt.object=Bc(),mt.body=xs(),Fe(mt,"WithStatement");case Gl:return Vc();case Ms:return He(),Fe(mt,"EmptyStatement");default:var Eg=pt,Pf=un();if(st===me&&Pf.type==="Identifier"&&kr(Wl)){for(var Lt=0;Lt<Yt.length;++Lt)Yt[Lt].name===Eg&&Pt(Pf.start,"Label '"+Eg+"' is already declared");var pF=lt.isLoop?"loop":lt===ms?"switch":null;return Yt.push({name:Eg,kind:pF}),mt.body=xs(),Yt.pop(),mt.label=Pf,Fe(mt,"LabeledStatement")}else return mt.expression=Pf,ja(),Fe(mt,"ExpressionStatement")}}function Bc(){Dr(zs);var st=un();return Dr(gs),st}function Vc(st){var mt=rn(),Tt=!0,Lt=!1,ge;for(mt.body=[],Dr(Gl);!kr(Va);){var Ce=xs();mt.body.push(Ce),Tt&&st&&bg(Ce)&&(ge=Lt,_g(Lt=!0)),Tt=!1}return Lt&&!ge&&_g(!1),Fe(mt,"BlockStatement")}function wg(st,mt){return st.init=mt,Dr(Ms),st.test=lt===Ms?null:un(),Dr(Ms),st.update=lt===gs?null:un(),Dr(gs),st.body=xs(),Yt.pop(),Fe(st,"ForStatement")}function z0(st,mt){return st.left=mt,st.right=un(),Dr(gs),st.body=xs(),Yt.pop(),Fe(st,"ForInStatement")}function M0(st,mt){for(st.declarations=[],st.kind="var";;){var Tt=rn();if(Tt.id=wi(),Et&&Af(Tt.id.name)&&Pt(Tt.id.start,"Binding "+Tt.id.name+" in strict mode"),Tt.init=kr(xg)?un(!0,mt):null,st.declarations.push(Fe(Tt,"VariableDeclarator")),!kr(oo))break}return st}function un(st,mt){var Tt=Cg(mt);if(!st&&lt===oo){var Lt=vi(Tt);for(Lt.expressions=[Tt];kr(oo);)Lt.expressions.push(Cg(mt));return Fe(Lt,"SequenceExpression")}return Tt}function Cg(st){var mt=iF(st);if(lt.isAssign){var Tt=vi(mt);return Tt.operator=pt,Tt.left=mt,He(),Tt.right=Cg(st),Of(mt),Fe(Tt,"AssignmentExpression")}return mt}function iF(st){var mt=aF(st);if(kr(dg)){var Tt=vi(mt);return Tt.test=mt,Tt.consequent=un(!0),Dr(Wl),Tt.alternate=un(!0,st),Fe(Tt,"ConditionalExpression")}return mt}function aF(st){return kg(Sg(),-1,st)}function kg(st,mt,Tt){var Lt=lt.binop;if(Lt!=null&&(!Tt||lt!==Nf)&&Lt>mt){var ge=vi(st);ge.left=st,ge.operator=pt;var Ce=lt;He(),ge.right=kg(Sg(),Lt,Tt);var Ie=Fe(ge,Ce===k0||Ce===S0?"LogicalExpression":"BinaryExpression");return kg(Ie,mt,Tt)}return st}function Sg(){if(lt.prefix){var st=rn(),mt=lt.isUpdate;return st.operator=pt,st.prefix=!0,ut=!0,He(),st.argument=Sg(),mt?Of(st.argument):Et&&st.operator==="delete"&&st.argument.type==="Identifier"&&Pt(st.start,"Deleting local variable in strict mode"),Fe(st,mt?"UpdateExpression":"UnaryExpression")}for(var Tt=lF();lt.postfix&&!Ff();){var st=vi(Tt);st.operator=pt,st.prefix=!1,st.argument=Tt,Of(Tt),He(),Tt=Fe(st,"UpdateExpression")}return Tt}function lF(){return Gc(Ig())}function Gc(st,mt){if(kr(mg)){var Tt=vi(st);return Tt.object=st,Tt.property=wi(!0),Tt.computed=!1,Gc(Fe(Tt,"MemberExpression"),mt)}else if(kr(Tf)){var Tt=vi(st);return Tt.object=st,Tt.property=un(),Tt.computed=!0,Dr(Ef),Gc(Fe(Tt,"MemberExpression"),mt)}else if(!mt&&kr(zs)){var Tt=vi(st);return Tt.callee=st,Tt.arguments=Tg(gs,!1),Gc(Fe(Tt,"CallExpression"),mt)}else return st}function Ig(){switch(lt){case _0:var st=rn();return He(),Fe(st,"ThisExpression");case me:return wi();case se:case de:case Jt:var st=rn();return st.value=pt,st.raw=F.slice(J,nt),He(),Fe(st,"Literal");case b0:case v0:case w0:var st=rn();return st.value=lt.atomValue,st.raw=lt.keyword,He(),Fe(st,"Literal");case zs:var mt=ot,Tt=J;He();var Lt=un();return Lt.start=Tt,Lt.end=nt,j.locations&&(Lt.loc.start=mt,Lt.loc.end=at),j.ranges&&(Lt.range=[Tt,nt]),Dr(gs),Lt;case Tf:var st=rn();return He(),st.elements=Tg(Ef,!0,!0),Fe(st,"ArrayExpression");case Gl:return cF();case Xn:var st=rn();return He(),Ng(st,!1);case y0:return uF();default:io()}}function uF(){var st=rn();return He(),st.callee=Gc(Ig(),!0),kr(zs)?st.arguments=Tg(gs,!1):st.arguments=Ut,Fe(st,"NewExpression")}function cF(){var st=rn(),mt=!0,Tt=!1;for(st.properties=[],He();!kr(Va);){if(mt)mt=!1;else if(Dr(oo),j.allowTrailingCommas&&kr(Va))break;var Lt={key:B0()},ge=!1,Ce;if(kr(Wl)?(Lt.value=un(!0),Ce=Lt.kind="init"):j.ecmaVersion>=5&&Lt.key.type==="Identifier"&&(Lt.key.name==="get"||Lt.key.name==="set")?(ge=Tt=!0,Ce=Lt.kind=Lt.key.name,Lt.key=B0(),lt!==zs&&io(),Lt.value=Ng(rn(),!1)):io(),Lt.key.type==="Identifier"&&(Et||Tt))for(var Ie=0;Ie<st.properties.length;++Ie){var Ze=st.properties[Ie];if(Ze.key.name===Lt.key.name){var ys=Ce==Ze.kind||ge&&Ze.kind==="init"||Ce==="init"&&(Ze.kind==="get"||Ze.kind==="set");ys&&!Et&&Ce==="init"&&Ze.kind==="init"&&(ys=!1),ys&&Pt(Lt.key.start,"Redefinition of property")}}st.properties.push(Lt)}return Fe(st,"ObjectExpression")}function B0(){return lt===se||lt===de?Ig():wi(!0)}function Ng(st,mt){lt===me?st.id=wi():mt?io():st.id=null,st.params=[];var Tt=!0;for(Dr(zs);!kr(gs);)Tt?Tt=!1:Dr(oo),st.params.push(wi());var Lt=Kt,ge=Yt;if(Kt=!0,Yt=[],st.body=Vc(!0),Kt=Lt,Yt=ge,Et||st.body.body.length&&bg(st.body.body[0]))for(var Ce=st.id?-1:0;Ce<st.params.length;++Ce){var Ie=Ce<0?st.id:st.params[Ce];if((N0(Ie.name)||Af(Ie.name))&&Pt(Ie.start,"Defining '"+Ie.name+"' in strict mode"),Ce>=0)for(var Ze=0;Ze<Ce;++Ze)Ie.name===st.params[Ze].name&&Pt(Ie.start,"Argument name clash in strict mode")}return Fe(st,mt?"FunctionDeclaration":"FunctionExpression")}function Tg(st,mt,Tt){for(var Lt=[],ge=!0;!kr(st);){if(ge)ge=!1;else if(Dr(oo),mt&&j.allowTrailingCommas&&kr(st))break;Tt&&lt===oo?Lt.push(null):Lt.push(un(!0))}return Lt}function wi(st){var mt=rn();return st&&j.forbidReserved=="everywhere"&&(st=!1),lt===me?(!st&&(j.forbidReserved&&(j.ecmaVersion===3?BR:VR)(pt)||Et&&N0(pt))&&F.slice(J,nt).indexOf("\\")==-1&&Pt(J,"The keyword '"+pt+"' is reserved"),mt.name=pt):st&&lt.keyword?mt.name=lt.keyword:io(),ut=!1,He(),Fe(mt,"Identifier")}}),c.version||(c=null)}function x(z,j){return(i.acorn||c).parse(z,j)}var b={"+":"__add","-":"__subtract","*":"__multiply","/":"__divide","%":"__modulo","==":"__equals","!=":"__equals"},k={"-":"__negate","+":"__self"},w=s.each(["add","subtract","multiply","divide","modulo","equals","negate"],function(z){this["__"+z]="#"+z},{__self:function(){return this}});d.inject(w),_.inject(w),Bt.inject(w);function S(z,j,F){var V=b[j];if(z&&z[V]){var T=z[V](F);return j==="!="?!T:T}switch(j){case"+":return z+F;case"-":return z-F;case"*":return z*F;case"/":return z/F;case"%":return z%F;case"==":return z==F;case"!=":return z!=F}}function I(z,j){var F=k[z];if(j&&j[F])return j[F]();switch(z){case"+":return+j;case"-":return-j}}function D(z,j){if(!z)return"";j=j||{};var F=[];function V(Et){for(var Pt=0,Ut=F.length;Pt<Ut;Pt++){var se=F[Pt];if(se[0]>=Et)break;Et+=se[1]}return Et}function T(Et){return z.substring(V(Et.range[0]),V(Et.range[1]))}function M(Et,Pt){return z.substring(V(Et.range[1]),V(Pt.range[0]))}function W(Et,Pt){for(var Ut=V(Et.range[0]),se=V(Et.range[1]),Jt=0,de=F.length-1;de>=0;de--)if(Ut>F[de][0]){Jt=de+1;break}F.splice(Jt,0,[Ut,Pt.length-se+Ut]),z=z.substring(0,Ut)+Pt+z.substring(se)}function q(Et,Pt){switch(Et.type){case"UnaryExpression":if(Et.operator in k&&Et.argument.type!=="Literal"){var Ut=T(Et.argument);W(Et,'$__("'+Et.operator+'", '+Ut+")")}break;case"BinaryExpression":if(Et.operator in b&&Et.left.type!=="Literal"){var se=T(Et.left),Jt=T(Et.right),de=M(Et.left,Et.right),me=Et.operator;W(Et,"__$__("+se+","+de.replace(new RegExp("\\"+me),'"'+me+'"')+", "+Jt+")")}break;case"UpdateExpression":case"AssignmentExpression":var Se=Pt&&Pt.type;if(!(Se==="ForStatement"||Se==="BinaryExpression"&&/^[=!<>]/.test(Pt.operator)||Se==="MemberExpression"&&Pt.computed)){if(Et.type==="UpdateExpression"){var Ut=T(Et.argument),Ee="__$__("+Ut+', "'+Et.operator[0]+'", 1)',ke=Ut+" = "+Ee;Et.prefix?ke="("+ke+")":(Se==="AssignmentExpression"||Se==="VariableDeclarator"||Se==="BinaryExpression")&&(T(Pt.left||Pt.id)===Ut&&(ke=Ee),ke=Ut+"; "+ke),W(Et,ke)}else if(/^.=$/.test(Et.operator)&&Et.left.type!=="Literal"){var se=T(Et.left),Jt=T(Et.right),Ee=se+" = __$__("+se+', "'+Et.operator[0]+'", '+Jt+")";W(Et,/^\(.*\)$/.test(T(Et))?"("+Ee+")":Ee)}}break}}function G(Et){switch(Et.type){case"ExportDefaultDeclaration":W({range:[Et.start,Et.declaration.start]},"module.exports = ");break;case"ExportNamedDeclaration":var Pt=Et.declaration,Ut=Et.specifiers;if(Pt){var se=Pt.declarations;se&&(se.forEach(function(de){W(de,"module.exports."+T(de))}),W({range:[Et.start,Pt.start+Pt.kind.length]},""))}else if(Ut){var Jt=Ut.map(function(de){var me=T(de);return"module.exports."+me+" = "+me+"; "}).join("");Jt&&W(Et,Jt)}break}}function J(Et,Pt,Ut){if(Et){for(var se in Et)if(se!=="range"&&se!=="loc"){var Jt=Et[se];if(Array.isArray(Jt))for(var de=0,me=Jt.length;de<me;de++)J(Jt[de],Et,Ut);else Jt&&typeof Jt=="object"&&J(Jt,Et,Ut)}Ut.operatorOverloading!==!1&&q(Et,Pt),Ut.moduleExports!==!1&&G(Et)}}function nt(Et){var Pt="",Ut="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(Et=(Math.abs(Et)<<1)+(Et<0?1:0);Et||!Pt;){var se=Et&32-1;Et>>=5,Et&&(se|=32),Pt+=Ut[se]}return Pt}var ot=j.url||"",at=j.sourceMaps,lt=j.paperFeatures||{},pt=j.source||z,ut=j.offset||0,gt=ye.agent,bt=gt.versionNumber,kt=!1,Rt=/\r\n|\n|\r/mg,Wt;if(at&&(gt.chrome&&bt>=30||gt.webkit&&bt>=537.76||gt.firefox&&bt>=23||gt.node)){if(gt.node)ut-=2;else if(e&&ot&&!e.location.href.indexOf(ot)){var Kt=n.getElementsByTagName("html")[0].innerHTML;ut=Kt.substr(0,Kt.indexOf(z)+1).match(Rt).length+1}kt=ut>0&&!(gt.chrome&&bt>=36||gt.safari&&bt>=600||gt.firefox&&bt>=40||gt.node);var Yt=["AA"+nt(kt?0:ut)+"A"];Yt.length=(z.match(Rt)||[]).length+1+(kt?ut:0),Wt={version:3,file:ot,names:[],mappings:Yt.join(";AACA"),sourceRoot:"",sources:[ot],sourcesContent:[pt]}}return(lt.operatorOverloading!==!1||lt.moduleExports!==!1)&&J(x(z,{ranges:!0,preserveParens:!0,sourceType:"module"}),null,lt),Wt&&(kt&&(z=new Array(ut+1).join(`
`)+z),/^(inline|both)$/.test(at)&&(z+=`
//# sourceMappingURL=data:application/json;base64,`+r.btoa(unescape(encodeURIComponent(JSON.stringify(Wt))))),z+=`
//# sourceURL=`+(ot||"paperscript")),{url:ot,source:pt,code:z,map:Wt}}function O(z,j,F){ye=j;var V=j.getView(),T=/\btool\.\w+|\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(z)&&!/\bnew\s+Tool\b/.test(z)?new pr:null,M=T?T._events:[],W=["onFrame","onResize"].concat(M),q=[],G=[],J,nt=typeof z=="object"?z:D(z,F);z=nt.code;function ot(bt,kt){for(var Rt in bt)(kt||!/^_/.test(Rt))&&new RegExp("([\\b\\s\\W]|^)"+Rt.replace(/\$/g,"\\$")+"\\b").test(z)&&(q.push(Rt),G.push(bt[Rt]))}ot({__$__:S,$__:I,paper:j,tool:T},!0),ot(j),z="var module = { exports: {} }; "+z;var at=s.each(W,function(bt){new RegExp("\\s+"+bt+"\\b").test(z)&&(q.push(bt),this.push("module.exports."+bt+" = "+bt+";"))},[]).join(`
`);at&&(z+=`
`+at),z+=`
return module.exports;`;var lt=ye.agent;if(n&&(lt.chrome||lt.firefox&&lt.versionNumber<40)){var pt=n.createElement("script"),ut=n.head||n.getElementsByTagName("head")[0];lt.firefox&&(z=`
`+z),pt.appendChild(n.createTextNode("document.__paperscript__ = function("+q+") {"+z+`
}`)),ut.appendChild(pt),J=n.__paperscript__,delete n.__paperscript__,ut.removeChild(pt)}else J=Function(q,z);var at=J&&J.apply(j,G),gt=at||{};return s.each(M,function(bt){var kt=gt[bt];kt&&(T[bt]=kt)}),V&&(gt.onResize&&V.setOnResize(gt.onResize),V.emit("resize",{size:V.size,delta:new d}),gt.onFrame&&V.setOnFrame(gt.onFrame),V.requestUpdate()),at}function R(z){if(/^text\/(?:x-|)paperscript$/.test(z.type)&&a.getAttribute(z,"ignore")!=="true"){var j=a.getAttribute(z,"canvas"),F=n.getElementById(j),V=z.src||z.getAttribute("data-src"),T=a.hasAttribute(z,"async"),M="data-paper-scope";if(!F)throw new Error('Unable to find canvas with id "'+j+'"');var W=a.get(F.getAttribute(M))||new a().setup(F);return F.setAttribute(M,W._id),V?Kn.request({url:V,async:T,mimeType:"text/plain",onLoad:function(q){O(q,W,V)}}):O(z.innerHTML,W,z.baseURI),z.setAttribute("data-paper-ignore","true"),W}}function $(){s.each(n&&n.getElementsByTagName("script"),R)}function U(z){return z?R(z):$()}return e&&(n.readyState==="complete"?setTimeout($):te.add(e,{load:$})),{compile:D,execute:O,load:U,parse:x,calculateBinary:S,calculateUnary:I}}.call(this);var ye=new(a.inject(s.exports,{Base:s,Numerical:f,Key:nr,DomEvent:te,DomElement:Qt,document:n,window:e,Symbol:wt,PlacedSymbol:xt}));return ye.agent.node&&gv()(ye),typeof define=="function"&&define.amd?define("paper",ye):typeof Yl=="object"&&Yl&&(Yl.exports=ye),ye}.call(xv,typeof self=="object"?self:null)});var lw=$n(()=>{});var uw=$n(()=>{});var CC=$n((wC,Ex)=>{(function(r,t,e){function n(l){var u=this,p=a();u.next=function(){var f=2091639*u.s0+u.c*23283064365386963e-26;return u.s0=u.s1,u.s1=u.s2,u.s2=f-(u.c=f|0)},u.c=1,u.s0=p(" "),u.s1=p(" "),u.s2=p(" "),u.s0-=p(l),u.s0<0&&(u.s0+=1),u.s1-=p(l),u.s1<0&&(u.s1+=1),u.s2-=p(l),u.s2<0&&(u.s2+=1),p=null}function s(l,u){return u.c=l.c,u.s0=l.s0,u.s1=l.s1,u.s2=l.s2,u}function o(l,u){var p=new n(l),f=u&&u.state,m=p.next;return m.int32=function(){return p.next()*4294967296|0},m.double=function(){return m()+(m()*2097152|0)*11102230246251565e-32},m.quick=m,f&&(typeof f=="object"&&s(f,p),m.state=function(){return s(p,{})}),m}function a(){var l=4022871197,u=function(p){p=p.toString();for(var f=0;f<p.length;f++){l+=p.charCodeAt(f);var m=.02519603282416938*l;l=m>>>0,m-=l,m*=l,l=m>>>0,m-=l,l+=m*4294967296}return(l>>>0)*23283064365386963e-26};return u}t&&t.exports?t.exports=o:e&&e.amd?e(function(){return o}):this.alea=o})(wC,typeof Ex=="object"&&Ex,typeof define=="function"&&define)});var SC=$n((kC,Ax)=>{(function(r,t,e){function n(a){var l=this,u="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var f=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^f^f>>>8},a===(a|0)?l.x=a:u+=a;for(var p=0;p<u.length+64;p++)l.x^=u.charCodeAt(p)|0,l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var u=new n(a),p=l&&l.state,f=function(){return(u.next()>>>0)/4294967296};return f.double=function(){do var m=u.next()>>>11,d=(u.next()>>>0)/4294967296,y=(m+d)/(1<<21);while(y===0);return y},f.int32=u.next,f.quick=f,p&&(typeof p=="object"&&s(p,u),f.state=function(){return s(u,{})}),f}t&&t.exports?t.exports=o:e&&e.amd?e(function(){return o}):this.xor128=o})(kC,typeof Ax=="object"&&Ax,typeof define=="function"&&define)});var NC=$n((IC,$x)=>{(function(r,t,e){function n(a){var l=this,u="";l.next=function(){var f=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(f^f<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:u+=a;for(var p=0;p<u.length+64;p++)l.x^=u.charCodeAt(p)|0,p==u.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var u=new n(a),p=l&&l.state,f=function(){return(u.next()>>>0)/4294967296};return f.double=function(){do var m=u.next()>>>11,d=(u.next()>>>0)/4294967296,y=(m+d)/(1<<21);while(y===0);return y},f.int32=u.next,f.quick=f,p&&(typeof p=="object"&&s(p,u),f.state=function(){return s(u,{})}),f}t&&t.exports?t.exports=o:e&&e.amd?e(function(){return o}):this.xorwow=o})(IC,typeof $x=="object"&&$x,typeof define=="function"&&define)});var EC=$n((TC,Dx)=>{(function(r,t,e){function n(a){var l=this;l.next=function(){var p=l.x,f=l.i,m,d,y;return m=p[f],m^=m>>>7,d=m^m<<24,m=p[f+1&7],d^=m^m>>>10,m=p[f+3&7],d^=m^m>>>3,m=p[f+4&7],d^=m^m<<7,m=p[f+7&7],m=m^m<<13,d^=m^m<<9,p[f]=d,l.i=f+1&7,d};function u(p,f){var m,d,y=[];if(f===(f|0))d=y[0]=f;else for(f=""+f,m=0;m<f.length;++m)y[m&7]=y[m&7]<<15^f.charCodeAt(m)+y[m+1&7]<<13;for(;y.length<8;)y.push(0);for(m=0;m<8&&y[m]===0;++m);for(m==8?d=y[7]=-1:d=y[m],p.x=y,p.i=0,m=256;m>0;--m)p.next()}u(l,a)}function s(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var u=new n(a),p=l&&l.state,f=function(){return(u.next()>>>0)/4294967296};return f.double=function(){do var m=u.next()>>>11,d=(u.next()>>>0)/4294967296,y=(m+d)/(1<<21);while(y===0);return y},f.int32=u.next,f.quick=f,p&&(p.x&&s(p,u),f.state=function(){return s(u,{})}),f}t&&t.exports?t.exports=o:e&&e.amd?e(function(){return o}):this.xorshift7=o})(TC,typeof Dx=="object"&&Dx,typeof define=="function"&&define)});var $C=$n((AC,Rx)=>{(function(r,t,e){function n(a){var l=this;l.next=function(){var p=l.w,f=l.X,m=l.i,d,y;return l.w=p=p+1640531527|0,y=f[m+34&127],d=f[m=m+1&127],y^=y<<13,d^=d<<17,y^=y>>>15,d^=d>>>12,y=f[m]=y^d,l.i=m,y+(p^p>>>16)|0};function u(p,f){var m,d,y,_,v,C=[],N=128;for(f===(f|0)?(d=f,f=null):(f=f+"\0",d=0,N=Math.max(N,f.length)),y=0,_=-32;_<N;++_)f&&(d^=f.charCodeAt((_+32)%f.length)),_===0&&(v=d),d^=d<<10,d^=d>>>15,d^=d<<4,d^=d>>>13,_>=0&&(v=v+1640531527|0,m=C[_&127]^=d+v,y=m==0?y+1:0);for(y>=128&&(C[(f&&f.length||0)&127]=-1),y=127,_=4*128;_>0;--_)d=C[y+34&127],m=C[y=y+1&127],d^=d<<13,m^=m<<17,d^=d>>>15,m^=m>>>12,C[y]=d^m;p.w=v,p.X=C,p.i=y}u(l,a)}function s(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var u=new n(a),p=l&&l.state,f=function(){return(u.next()>>>0)/4294967296};return f.double=function(){do var m=u.next()>>>11,d=(u.next()>>>0)/4294967296,y=(m+d)/(1<<21);while(y===0);return y},f.int32=u.next,f.quick=f,p&&(p.X&&s(p,u),f.state=function(){return s(u,{})}),f}t&&t.exports?t.exports=o:e&&e.amd?e(function(){return o}):this.xor4096=o})(AC,typeof Rx=="object"&&Rx,typeof define=="function"&&define)});var RC=$n((DC,Fx)=>{(function(r,t,e){function n(a){var l=this,u="";l.next=function(){var f=l.b,m=l.c,d=l.d,y=l.a;return f=f<<25^f>>>7^m,m=m-d|0,d=d<<24^d>>>8^y,y=y-f|0,l.b=f=f<<20^f>>>12^m,l.c=m=m-d|0,l.d=d<<16^m>>>16^y,l.a=y-f|0},l.a=0,l.b=0,l.c=2654435769|0,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):u+=a;for(var p=0;p<u.length+20;p++)l.b^=u.charCodeAt(p)|0,l.next()}function s(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var u=new n(a),p=l&&l.state,f=function(){return(u.next()>>>0)/4294967296};return f.double=function(){do var m=u.next()>>>11,d=(u.next()>>>0)/4294967296,y=(m+d)/(1<<21);while(y===0);return y},f.int32=u.next,f.quick=f,p&&(typeof p=="object"&&s(p,u),f.state=function(){return s(u,{})}),f}t&&t.exports?t.exports=o:e&&e.amd?e(function(){return o}):this.tychei=o})(DC,typeof Fx=="object"&&Fx,typeof define=="function"&&define)});var FC=$n(()=>{});var OC=$n((aot,Mh)=>{(function(r,t){var e=this,n=256,s=6,o=52,a="random",l=t.pow(n,s),u=t.pow(2,o),p=u*2,f=n-1,m;function d(B,P,L){var Z=[];P=P==!0?{entropy:!0}:P||{};var K=C(v(P.entropy?[B,A(r)]:B??N(),3),Z),et=new y(Z),it=function(){for(var xt=et.g(s),wt=l,St=0;xt<u;)xt=(xt+St)*n,wt*=n,St=et.g(1);for(;xt>=p;)xt/=2,wt/=2,St>>>=1;return(xt+St)/wt};return it.int32=function(){return et.g(4)|0},it.quick=function(){return et.g(4)/4294967296},it.double=it,C(A(et.S),r),(P.pass||L||function(xt,wt,St,yt){return yt&&(yt.S&&_(yt,et),xt.state=function(){return _(et,{})}),St?(t[a]=xt,wt):xt})(it,K,"global"in P?P.global:this==t,P.state)}t["seed"+a]=d;function y(B){var P,L=B.length,Z=this,K=0,et=Z.i=Z.j=0,it=Z.S=[];for(L||(B=[L++]);K<n;)it[K]=K++;for(K=0;K<n;K++)it[K]=it[et=f&et+B[K%L]+(P=it[K])],it[et]=P;(Z.g=function(xt){for(var wt,St=0,yt=Z.i,Nt=Z.j,ht=Z.S;xt--;)wt=ht[yt=f&yt+1],St=St*n+ht[f&(ht[yt]=ht[Nt=f&Nt+wt])+(ht[Nt]=wt)];return Z.i=yt,Z.j=Nt,St})(n)}function _(B,P){return P.i=B.i,P.j=B.j,P.S=B.S.slice(),P}function v(B,P){var L=[],Z=typeof B,K;if(P&&Z=="object")for(K in B)try{L.push(v(B[K],P-1))}catch(et){}return L.length?L:Z=="string"?B:B+"\0"}function C(B,P){for(var L=B+"",Z,K=0;K<L.length;)P[f&K]=f&(Z^=P[f&K]*19)+L.charCodeAt(K++);return A(P)}function N(){try{var B;return m&&(B=m.randomBytes)?B=B(n):(B=new Uint8Array(n),(e.crypto||e.msCrypto).getRandomValues(B)),A(B)}catch(Z){var P=e.navigator,L=P&&P.plugins;return[+new Date,e,L,e.screen,A(r)]}}function A(B){return String.fromCharCode.apply(0,B)}if(C(t.random(),r),typeof Mh=="object"&&Mh.exports){Mh.exports=d;try{m=FC()}catch(B){}}else typeof define=="function"&&define.amd&&define(function(){return d})})([],Math)});var xp=$n((lot,PC)=>{var dz=CC(),gz=SC(),xz=NC(),yz=EC(),_z=$C(),bz=RC(),gl=OC();gl.alea=dz;gl.xor128=gz;gl.xorwow=xz;gl.xorshift7=yz;gl.xor4096=_z;gl.tychei=bz;PC.exports=gl});var Y6=Symbol.for("#type"),zf=Symbol.for("#__listeners__");function Mf(r){let t=typeof r;if(t=="number")return r;if(t=="string"){if(/^\d+fps$/.test(r))return 1e3/parseFloat(r);if(/^([-+]?[\d\.]+)s$/.test(r))return parseFloat(r)*1e3;if(/^([-+]?[\d\.]+)ms$/.test(r))return parseFloat(r)}return null}var G0=function(r,t,e){let n,s,o;for(;(n=e)&&(e=e.next);)(s=e.listener)&&(e.path&&s[e.path]?o=t?s[e.path].apply(s,t):s[e.path]():o=t?s.apply(e,t):s.call(e)),e.times&&--e.times<=0&&(n.next=e.next,e.listener=null)};function Ag(r,t,e,n){var s;let o,a,l;return o=r[zf]||(r[zf]={}),a=o[t]||(o[t]={}),l=a.tail||(a.tail=a.next={}),l.listener=e,l.path=n,a.tail=l.next={},l}function Bf(r,t,e){let n=Ag(r,t,e);return n.times=1,n}function W0(r,t,e,n){let s,o,a=r[zf];if(!!a&&(s=a[t])){for(;(o=s)&&(s=s.next);)if(s==e||s.listener==e){o.next=s.next,s.listener=null;break}}}function $g(r,t,e){let n;(n=r[zf])&&(n[t]&&G0(t,e,n[t]),n.all&&G0(t,[t,e],n.all))}function yF(r){let t;return r?(t=r.toIterable)?t.call(r):r:[]}var U0=Symbol.for("#init"),j0=Symbol.for("#schedule"),Dg=Symbol.for("#frames"),Vf=Symbol.for("#interval"),Uc=Symbol.for("#stage"),Hl=Symbol.for("#scheduled"),_F=Symbol.for("#fps"),q0=Symbol.for("#ticker"),bF=globalThis.requestAnimationFrame||function(r){return setTimeout1(r,1e3/60)};var J6=1/60,H0=class{constructor(t=null){this[U0](t)}[U0](t=null){var e;this.owner=t&&(e=t.owner)!==void 0?e:null,this.target=t&&(e=t.target)!==void 0?e:null,this.active=t&&(e=t.active)!==void 0?e:!1,this.value=t&&(e=t.value)!==void 0?e:void 0,this.skip=t&&(e=t.skip)!==void 0?e:0,this.last=t&&(e=t.last)!==void 0?e:0}tick(t){return this.last=this.owner[Dg],this.target.tick(this.owner),1}update(t,e){let n=this.active,s=t.value;return this.value!=s&&(this.deactivate(),this.value=s),(this.value||n||e)&&this.activate(),this}queue(){this.owner.add(this)}activate(){return this.value===!0?this.owner.on("commit",this):this.value===!1||typeof this.value=="number"&&(this.value/(1e3/60)<=2?this.owner.on("raf",this):this[Vf]=globalThis.setInterval(this.queue.bind(this),this.value)),this.active=!0,this}deactivate(){return this.value===!0&&this.owner.un("commit",this),this.owner.un("raf",this),this[Vf]&&(globalThis.clearInterval(this[Vf]),this[Vf]=null),this.active=!1,this}},K0=class{constructor(){var t=this;this.id=Symbol(),this.queue=[],this.stage=-1,this[Uc]=-1,this[Dg]=0,this[Hl]=!1,this.listeners={},this.intervals={},this.commit=function(){return t.add("commit"),t},this[_F]=0,this.$promise=null,this.$resolve=null,this[q0]=function(e){return t[Hl]=!1,t.tick(e)}}add(t,e){return(e||this.queue.indexOf(t)==-1)&&this.queue.push(t),this[Hl]||this[j0](),this}listen(t,e){let n=this.listeners[t],s=!n;return n||(n=this.listeners[t]=new Set),n.add(e),t=="raf"&&s&&this.add("raf"),this}unlisten(t,e){var n;let s=this.listeners[t];return s&&s.delete(e),t=="raf"&&s&&s.size==0&&(n=this.listeners.raf,delete this.listeners.raf),this}on(t,e){return this.listen(t,e)}un(t,e){return this.unlisten(t,e)}get promise(){var t=this;return this.$promise||(this.$promise=new Promise(function(e){return t.$resolve=e}))}tick(t){var e=this;let n=this.queue,s=this[Dg]++;if(this.ts||(this.ts=t),this.dt=t-this.ts,this.ts=t,this.queue=[],this[Uc]=1,n.length)for(let o=0,a=yF(n),l=a.length;o<l;o++){let u=a[o];typeof u=="string"&&this.listeners[u]?this.listeners[u].forEach(function(p){if(p.tick instanceof Function)return p.tick(e);if(p instanceof Function)return p(e)}):u instanceof Function?u(this.dt,this):u.tick&&u.tick(this.dt,this)}return this[Uc]=this[Hl]?0:-1,this.$promise&&(this.$resolve(this),this.$promise=this.$resolve=null),this.listeners.raf&&!0&&this.add("raf"),this}[j0](){return this[Hl]||(this[Hl]=!0,this[Uc]==-1&&(this[Uc]=0),bF(this[q0])),this}schedule(t,e){var n,s;return e||(e=t[n=this.id]||(t[n]={value:!0})),(e[s=this.id]||(e[s]=new H0({owner:this,target:t}))).update(e,!0)}unschedule(t,e={}){e||(e=t[this.id]);let n=e&&e[this.id];return n&&n.active&&n.deactivate(),this}},zn=new K0;var Q6=globalThis.clearInterval,tq=globalThis.clearTimeout;var Rg=class{constructor(t){this.dom=t,this.string=""}contains(t){return this.dom.classList.contains(t)}add(t){return this.contains(t)?this:(this.string+=(this.string?" ":"")+t,this.dom.classList.add(t),this)}remove(t){if(!this.contains(t))return this;var e=new RegExp("(^|\\s)*"+t+"(\\s|$)*","g");return this.string=this.string.replace(e,""),this.dom.classList.remove(t),this}toggle(t,e){return e===void 0&&(e=!this.contains(t)),e?this.add(t):this.remove(t)}incr(t){let e=this.stacks||(this.stacks={}),n=e[t]||0;return n<1&&this.add(t),e[t]=Math.max(n,0)+1}decr(t){let e=this.stacks||(this.stacks={}),n=e[t]||0;return n==1&&this.remove(t),e[t]=Math.max(n,1)-1}valueOf(){return this.string}toString(){return this.string}sync(){return this.dom.flagSync$()}};function jc(r,t){var e=Object.getOwnPropertyDescriptors(t);return Object.defineProperties(r.prototype,e),r}function vF(r){let t;return r?(t=r.toIterable)?t.call(r):r:[]}var X0=Symbol.for("#parent"),wF=Symbol.for("#context"),Y0=Symbol.for("#init"),Gf=Symbol.for("#placeholder__"),CF=Symbol.for("#attachToParent"),kF=Symbol.for("#detachFromParent"),Z0=Symbol.for("##parent"),SF=Symbol.for("##up"),J0=Symbol.for("##context"),Wf=Symbol.for("##placeholder__"),Q0=Symbol.for("#src"),Uf=Symbol.for("#htmlNodeName"),sq=Symbol.for("#ImbaElement"),{Event:qr,UIEvent:oq,MouseEvent:iq,PointerEvent:aq,KeyboardEvent:lq,CustomEvent:IF,Node:Kl,Comment:NF,Text:Fg,Element:Rr,HTMLElement:jf,HTMLHtmlElement:uq,HTMLSelectElement:cq,HTMLInputElement:pq,HTMLTextAreaElement:fq,HTMLButtonElement:hq,HTMLOptionElement:mq,HTMLScriptElement:dq,SVGElement:tv,DocumentFragment:ev,ShadowRoot:gq,Document:TF,Window:xq,customElements:yq}=globalThis.window,Og={},Pg={},EF={},Lg={};var AF={get(r,t){let e=r,n;for(;e&&n==null;)(e=e[X0])&&(n=e[t]);return n}};jc(TF,{get flags(){return this.documentElement.flags}});jc(Kl,{get[X0](){return this[Z0]||this.parentNode||this[SF]},get[wF](){return this[J0]||(this[J0]=new Proxy(this,AF))},[Y0](){return this},replaceWith$(r){return!(r instanceof Kl)&&r.replace$?r.replace$(this):this.parentNode.replaceChild(r,this),r},insertInto$(r){return r.appendChild$(this),this},insertBefore$(r,t){return this.insertBefore(r,t)},insertBeforeBegin$(r){return this.parentNode.insertBefore(r,this)},insertAfterEnd$(r){return this.nextSibling?this.nextSibling.insertBeforeBegin$(r):this.parentNode.appendChild(r)},insertAfterBegin$(r){return this.childNodes[0]?this.childNodes[0].insertBeforeBegin$(r):this.appendChild(r)},get[Gf](){return this[Wf]||(this[Wf]=globalThis.document.createComment(""))},set[Gf](r){let t=this[Wf];this[Wf]=r,t&&t!=r&&t.parentNode&&t.replaceWith$(r)},[CF](){let r=this[Gf];return r.parentNode&&r!=this&&r.replaceWith$(this),this},[kF](r){let t=this[Gf];return this.parentNode&&t!=this&&this.replaceWith$(t),this}});jc(Rr,{log(...r){return console.log(...r),this},emit(r,t,e={bubbles:!0,cancelable:!0}){t!=null&&(e.detail=t);let n=new IF(r,e),s=this.dispatchEvent(n);return n},slot$(r,t){return this},text$(r){return this.textContent=r,this},insert$(r,t,e){let n=typeof r;if(n==="undefined"||r===null){if(e&&e instanceof NF)return e;let s=globalThis.document.createComment("");return e?e.replaceWith$(s):s.insertInto$(this),s}if(r===e)return r;if(n!=="object"){let s,o=r;if(t&128&&t&256){this.textContent=o;return}return e?e instanceof Fg?(e.textContent=o,e):(s=globalThis.document.createTextNode(o),e.replaceWith$(s,this),s):(this.appendChild$(s=globalThis.document.createTextNode(o)),s)}else return e?e.replaceWith$(r,this):r.insertInto$(this),r},open$(){return this},close$(){return this},end$(){this.render&&this.render()},get flags(){return this.$flags||(this.$flags=new Rg(this),this.flag$==Rr.prototype.flag$&&(this.flags$ext=this.className),this.flagDeopt$()),this.$flags},flag$(r){let t=this.flags$ns;this.className=t?t+(this.flags$ext=r):this.flags$ext=r},flagDeopt$(){var r=this;this.flag$=this.flagExt$,this.flagSelf$=function(t){return r.flagSync$(r.flags$own=t)}},flagExt$(r){return this.flagSync$(this.flags$ext=r)},flagSelf$(r){return this.flagDeopt$(),this.flagSelf$(r)},flagSync$(){return this.className=(this.flags$ns||"")+(this.flags$ext||"")+" "+(this.flags$own||"")+" "+(this.$flags||"")}});Rr.prototype.appendChild$=Rr.prototype.appendChild;Rr.prototype.removeChild$=Rr.prototype.removeChild;Rr.prototype.insertBefore$=Rr.prototype.insertBefore;Rr.prototype.replaceChild$=Rr.prototype.replaceChild;Rr.prototype.set$=Rr.prototype.setAttribute;Rr.prototype.setns$=Rr.prototype.setAttributeNS;function Ha(r,t,e,n){let s=globalThis.document.createElement(r);return e&&(s.className=e),n!==null&&s.text$(n),t&&t instanceof Kl&&s.insertInto$(t),s}var rv={};function nv(r,t,e){if(!r)return e[t]=null;if(e[t]!==void 0)return e[t];let n=Object.getOwnPropertyDescriptor(r,t);return n!==void 0||r==tv?e[t]=n||null:nv(Reflect.getPrototypeOf(r),t,e)}jc(tv,{set$(r,t){var e;let n=rv[e=this.nodeName]||(rv[e]={}),s=nv(this,r,n);!s||!s.set?this.setAttribute(r,t):this[r]=t},flag$(r){let t=this.flags$ns;this.className.baseVal=t?t+(this.flags$ext=r):this.flags$ext=r},flagSelf$(r){var t=this;return this.flag$=function(e){return t.flagSync$(t.flags$ext=e)},this.flagSelf$=function(e){return t.flagSync$(t.flags$own=e)},this.flagSelf$(r)},flagSync$(){return this.className.baseVal=(this.flags$ns||"")+(this.flags$ext||"")+" "+(this.flags$own||"")+" "+(this.$flags||"")}});jc(SVGSVGElement,{set src(r){if(this[Q0]!=r?(this[Q0]=r,!0):!1){if(r?.adoptNode)r.adoptNode(this);else if(r?.content){for(let t=r.attributes,e=0,n=Object.keys(t),s=n.length,o,a;e<s;e++)o=n[e],a=t[o],this.setAttribute(o,a);this.innerHTML=r.content}}}});function zg(r){return globalThis.document.createComment(r)}function sv(){return globalThis.document.createDocumentFragment()}var $F=globalThis.navigator?.vendor||"",ov=globalThis.navigator?.userAgent||"",DF=$F.indexOf("Apple")>-1||ov.indexOf("CriOS")>=0||ov.indexOf("FxiOS")>=0,qf=!DF,iv=new Map,av=class extends jf{connectedCallback(){return qf?this.parentNode.removeChild(this):this.parentNode.connectedCallback()}disconnectedCallback(){if(!qf)return this.parentNode.disconnectedCallback()}};window.customElements.define("i-hook",av);function RF(r,t){let e=iv.get(t);if(!e){e={};let n=t.prototype,s=[n];for(;(n=n&&Object.getPrototypeOf(n))&&n.constructor!=r.constructor;)s.unshift(n);for(let o=0,a=vF(s),l=a.length;o<l;o++){let u=a[o],p=Object.getOwnPropertyDescriptors(u);Object.assign(e,p)}iv.set(t,e)}return e}function Mg(r,t,e,n,s){let o;typeof r!="string"&&r&&r.nodeName&&(r=r.nodeName);let a=Pg[r]||r;if(Og[r]){let l=Og[r],u=l.prototype[Uf];if(u&&qf)o=globalThis.document.createElement(u,{is:r});else if(l.create$&&u){o=globalThis.document.createElement(u),o.setAttribute("is",a);let p=RF(o,l);Object.defineProperties(o,p),o.__slots={},o.appendChild(globalThis.document.createElement("i-hook"))}else l.create$?(o=l.create$(o),o.__slots={}):console.warn("could not create tag "+r)}else o=globalThis.document.createElement(Pg[r]||r);return o[Z0]=t,o[Y0](),n!==null&&o.slot$("__").text$(n),(e||o.flags$ns)&&o.flag$(e||""),o}function Bg(r,t,e={}){EF[r]=Lg[r]=t,t.nodeName=r;let n=r,s=t.prototype;r.indexOf("-")==-1&&(n=""+r+"-tag",Pg[r]=n);let o=s._ns_;if(e.ns){let a=e.ns,l=a+" "+a+"_ ";o&&(l+=s.flags$ns,a+=" "+o),s._ns_=a,s.flags$ns=l}return s[Uf]&&(e.extends=s[Uf]),e.extends?(s[Uf]=e.extends,Og[r]=t,qf&&window.customElements.define(n,t,{extends:e.extends})):window.customElements.define(n,t),t}function FF(r,t){var e=Object.getOwnPropertyDescriptors(t);return Object.defineProperties(r.prototype,e),r}var OF=Symbol.for("#parent"),lv=Symbol.for("##up"),qc=Symbol.for("##parent");FF(ev,{get[OF](){return this[lv]||this[qc]},setup$(r,t){return this.$start=zg("start"),this.$end=zg("end"),this.$end.replaceWith$=function(e){return this.parentNode.insertBefore(e,this),e},this.appendChild(this.$start),this.appendChild(this.$end)},text$(r){this.$text?this.$text.textContent=r:this.$text=this.insert$(r)},insert$(r,t,e){return this[qc]?this[qc].insert$(r,t,e||this.$end):Rr.prototype.insert$.call(this,r,t,e||this.$end)},insertInto$(r,t){return this[qc]||(this[qc]=r,r.appendChild$(this)),this},replaceWith$(r,t){this.$start.insertBeforeBegin$(r);for(var e=this.$start;e;){let n=e.nextSibling;if(this.appendChild(e),e==this.$end)break;e=n}return r},appendChild$(r){return this.$end?this.$end.insertBeforeBegin$(r):this.appendChild(r),r},removeChild$(r){return r.parentNode&&r.parentNode.removeChild(r),this},isEmpty$(){let r=this.$start,t=this.$end;for(;(r=r.nextSibling)&&r!=t;)if(r instanceof Rr||r instanceof Fg)return!1;return!0}});function uv(r,t,e){let n=sv();return n.setup$(r,t),e&&(n[lv]=e),n}function PF(r){let t;return r?(t=r.toIterable)?t.call(r):r:[]}var Hf=Symbol.for("#init"),Vg=Symbol.for("#count"),Xl=Symbol.for("#autorender"),LF=new class{constructor(r=null){this[Hf](r)}[Hf](r=null){var t;this.items=r&&(t=r.items)!==void 0?t:[],this.current=r&&(t=r.current)!==void 0?t:null,this.lastQueued=r&&(t=r.lastQueued)!==void 0?t:null,this.tests=r&&(t=r.tests)!==void 0?t:0}flush(){let r=null;for(;r=this.items.shift();){if(!r.parentNode||r.isHydrated)continue;let t=this.current;this.current=r,r.__F|=1024,r.connectedCallback(),this.current=t}}queue(r){var t=this;let e=this.items.length,n=0,s=this.lastQueued;this.lastQueued=r;let o=Kl.DOCUMENT_POSITION_PRECEDING,a=Kl.DOCUMENT_POSITION_FOLLOWING;if(e){let l=this.items.indexOf(s),u=l,p=function(m,d){return t.tests++,m.compareDocumentPosition(d)};(l==-1||s.nodeName!=r.nodeName)&&(u=l=0);let f=this.items[u];for(;f&&p(f,r)&a;)f=this.items[++u];if(u!=l)f?this.items.splice(u,0,r):this.items.push(r);else{for(;f&&p(f,r)&o;)f=this.items[--u];u!=l&&(f?this.items.splice(u+1,0,r):this.items.unshift(r))}}else this.items.push(r),this.current||globalThis.queueMicrotask(this.flush.bind(this))}run(r){var t,e;if(this.active)return;this.active=!0;let n=globalThis.document.querySelectorAll(".__ssr");console.log("running hydrator",r,n.length,Array.from(n));for(let s=0,o=PF(n),a=o.length;s<a;s++){let l=o[s];l[Vg]||(l[Vg]=1),l[Vg]++;let u=l.nodeName,p=(e=this.map)[u]||(e[u]=globalThis.window.customElements.get(u.toLowerCase())||jf);console.log("item type",u,p,!!Lg[u.toLowerCase()]),!(!l.connectedCallback||!l.parentNode||l.isHydrated)&&console.log("hydrate",l)}return this.active=!1}};var Kf=class extends jf{constructor(){super();this.flags$ns&&(this.flag$=this.flagExt$),this.setup$(),this.build()}setup$(){return this.__slots={},this.__F=0}[Hf](){return this.__F|=1|2,this}flag$(t){this.className=this.flags$ext=t}slot$(t,e){var n;return t=="__"&&!this.render?this:(n=this.__slots)[t]||(n[t]=uv(0,null,this))}build(){return this}awaken(){return this}mount(){return this}unmount(){return this}rendered(){return this}dehydrate(){return this}hydrate(){return this.autoschedule=!0,this}tick(){return this.commit()}visit(){return this.commit()}commit(){return this.isRender?(this.__F|=256,this.render&&this.render(),this.rendered(),this.__F=(this.__F|512)&~256&~8192):(this.__F|=8192,this)}get autoschedule(){return(this.__F&64)!=0}set autoschedule(t){t?this.__F|=64:this.__F&=~64}set autorender(t){let e=this[Xl]||(this[Xl]={});e.value=t,this.isMounted&&zn.schedule(this,e)}get isRender(){return!this.isSuspended}get isMounting(){return(this.__F&16)!=0}get isMounted(){return(this.__F&32)!=0}get isAwakened(){return(this.__F&8)!=0}get isRendered(){return(this.__F&512)!=0}get isSuspended(){return(this.__F&4096)!=0}get isRendering(){return(this.__F&256)!=0}get isScheduled(){return(this.__F&128)!=0}get isHydrated(){return(this.__F&2)!=0}get isSsr(){return(this.__F&1024)!=0}schedule(){return zn.on("commit",this),this.__F|=128,this}unschedule(){return zn.un("commit",this),this.__F&=~128,this}async suspend(t=null){let e=this.flags.incr("_suspended_");return this.__F|=4096,t instanceof Function&&(await t(),this.unsuspend()),this}unsuspend(){return this.flags.decr("_suspended_")==0&&(this.__F&=~4096,this.commit()),this}end$(){return this.visit()}open$(){return this.__F&1024&&(this.__F=this.__F&~1024,this.classList.remove("_ssr_"),this.flags$ext&&this.flags$ext.indexOf("_ssr_")==0&&(this.flags$ext=this.flags$ext.slice(5)),this.innerHTML=""),this}connectedCallback(){let t=this.__F,e=t&1,n=t&8;if(!e&&!(t&1024)){LF.queue(this);return}if(t&(16|32))return;this.__F|=16,e||this[Hf](),t&2||(this.flags$ext=this.className,this.__F|=2,this.hydrate(),this.commit()),n||(this.awaken(),this.__F|=8);let s=this.mount();return s&&s.then instanceof Function&&s.then(zn.commit),t=this.__F=(this.__F|32)&~16,t&64&&this.schedule(),this[Xl]&&zn.schedule(this,this[Xl]),this}disconnectedCallback(){if(this.__F=this.__F&(~32&~16),this.__F&128&&this.unschedule(),this.unmount(),this[Xl])return zn.unschedule(this,this[Xl])}};var Hc={context:null};function cv(r,t){let e=t||globalThis.document.body,n=r;if(r instanceof Function){let s={_:e},o=function(){let a=Hc.context;Hc.context=s;let l=r(s);return Hc.context==s&&(Hc.context=a),l};n=o(),zn.listen("commit",o)}else n.__F|=64;return e.appendChild(n)}function pv(r){let t;return r?(t=r.toIterable)?t.call(r):r:[]}function zF(r,t){var e=Object.getOwnPropertyDescriptors(t);return Object.defineProperties(r.prototype,e),r}var fv={esc:[27],tab:[9],enter:[13],space:[32],up:[38],down:[40],left:[37],right:[39],del:[8,46]};function hv(){return!0}qr.log$mod=function(...r){return console.log(...r),!0};qr.sel$mod=function(r){return!!this.event.target.matches(String(r))};qr.if$mod=function(r){return!!r};qr.wait$mod=function(r=250){return new Promise(function(t){return setTimeout(t,Mf(r))})};qr.self$mod=function(){return this.event.target==this.element};qr.throttle$mod=function(r=250){var t=this;return this.handler.throttled?!1:(this.handler.throttled=!0,this.element.flags.incr("throttled"),Bf(this.current,"end",function(){return setTimeout(function(){return t.element.flags.decr("throttled"),t.handler.throttled=!1},Mf(r))}),!0)};qr.debounce$mod=function(r=250){var t=this,e;let n=(e=this.state).debounced||(e.debounced=[]);return n.push(n.last=this.event),new Promise(function(s){return setTimeout(function(){return n.last==t.event?(t.event.debounced=n,t.handler.state={},s(!0)):s(!1)},Mf(r))})};qr.flag$mod=function(r,t){let e=t instanceof Rr?t:t?this.element.closest(t):this.element;if(!e)return!0;let n=this.step;this.state[n]=this.id,e.flags.incr(r);let s=Date.now();return Bf(this.current,"end",function(){let o=Date.now()-s,a=Math.max(250-o,0);return setTimeout(function(){return e.flags.decr(r)},a)}),!0};qr.busy$mod=function(r){return qr.flag$mod.call(this,"busy",250,r)};qr.mod$mod=function(r){return qr.flag$mod.call(this,"mod-"+r,globalThis.document.documentElement)};var mv=class{constructor(t,e){this.params=t,this.closure=e}getHandlerForMethod(t,e){return t?t[e]?t:this.getHandlerForMethod(t.parentNode,e):null}emit(t,...e){return $g(this,t,e)}on(t,...e){return Ag(this,t,...e)}once(t,...e){return Bf(this,t,...e)}un(t,...e){return W0(this,t,...e)}async handleEvent(t){let e=t.target,n=t.currentTarget,s=this.params,o=0,a=!1,l;this.count||(this.count=0),this.state||(this.state={});let u={element:n,event:t,modifiers:s,handler:this,id:++this.count,step:-1,state:this.state,commit:null,current:null};if(u.current=u,t.handle$mod&&t.handle$mod.apply(u,s.options||[])==!1)return;let p=qr[this.type+"$handle"]||qr[t.type+"$handle"]||t.handle$mod;if(!(p&&p.apply(u,s.options||[])==!1)){this.currentEvents||(this.currentEvents=new Set),this.currentEvents.add(t);for(let f=0,m=Object.keys(s),d=m.length,y,_;f<d;f++){if(y=m[f],_=s[y],u.step++,y[0]=="_")continue;y.indexOf("~")>0&&(y=y.split("~")[0]);let v=null,C=!1,N=[t,u],A,B=null,P,L=typeof y=="string";if(y[0]=="$"&&y[1]=="_"&&_[0]instanceof Function)y=_[0],N=[t,u].concat(_.slice(1)),B=n;else if(_ instanceof Array){N=_.slice(),v=N;for(let Z=0,K=pv(N),et=K.length;Z<et;Z++){let it=K[Z];if(typeof it=="string"&&it[0]=="~"&&it[1]=="$"){let wt=it.slice(2).split("."),St=u[wt.shift()]||t;for(let yt=0,Nt=pv(wt),ht=Nt.length;yt<ht;yt++){let It=Nt[yt];St=St?St[It]:void 0}N[Z]=St}}}if(typeof y=="string"&&(P=y.match(/^(emit|flag|mod|moved|pin|fit|refit|map|remap|css)-(.+)$/))&&(v||(v=N=[]),N.unshift(P[2]),y=P[1]),y=="stop")t.stopImmediatePropagation();else if(y=="prevent")t.preventDefault();else if(y=="commit")u.commit=!0;else if(y=="silence"||y=="silent")u.commit=!1;else if(y=="ctrl"){if(!t.ctrlKey)break}else if(y=="alt"){if(!t.altKey)break}else if(y=="shift"){if(!t.shiftKey)break}else if(y=="meta"){if(!t.metaKey)break}else if(y=="once")n.removeEventListener(t.type,this);else{if(y=="options")continue;if(fv[y]){if(fv[y].indexOf(t.keyCode)<0)break}else if(y=="emit"){let Z=N[0],K=N[1],et=new CustomEvent(Z,{bubbles:!0,detail:K});et.originalEvent=t;let it=n.dispatchEvent(et)}else if(typeof y=="string"){let Z=this.type&&qr[this.type+"$"+y+"$mod"];Z||(Z=t[y+"$mod"]||qr[t.type+"$"+y]||qr[y+"$mod"]),Z instanceof Function?(y=Z,B=u,N=v||[],C=!0):y[0]=="_"?(y=y.slice(1),B=this.closure):B=this.getHandlerForMethod(n,y)}}if(y instanceof Function?A=y.apply(B||n,N):B&&(A=B[y].apply(B,N)),u.commit===null&&!C&&(u.commit=!0),A&&A.then instanceof Function&&A!=zn.$promise&&(u.commit&&zn.commit(),a=!0,A=await A),A===!1)break;u.value=A}$g(u,"end",u),u.commit&&zn.commit(),this.currentEvents.delete(t),this.currentEvents.size==0&&this.emit("idle")}}};zF(Rr,{on$(r,t,e){let n="on$"+r,s;s=new mv(t,e);let o=t.capture,a=t.passive,l=o;return a&&(l={passive:a,capture:o}),this[n]instanceof Function?s=this[n](t,e,s):this.addEventListener(r,s,l),s}});var SR=Wc(yv());var MF=1e-7,BF=1e-4,Kc=class{constructor(t,e){this.backend=t,this.dataMover=e,this.data=new WeakMap,this.dataIdsCount=0}get(t){return this.data.has(t)||this.dataMover.moveData(this.backend,t),this.data.get(t)}set(t,e){this.dataIdsCount++,this.data.set(t,e)}has(t){return this.data.has(t)}delete(t){return this.dataIdsCount--,this.data.delete(t)}numDataIds(){return this.dataIdsCount}},Ka=class{decComplexRef(t){}time(t){return Bs("time")}read(t){return Bs("read")}readSync(t){return Bs("readSync")}numDataIds(){return Bs("numDataIds")}disposeData(t){return Bs("disposeData")}write(t,e,n){return Bs("write")}move(t,e,n,s){return Bs("move")}memory(){return Bs("memory")}floatPrecision(){return Bs("floatPrecision")}epsilon(){return this.floatPrecision()===32?MF:BF}dispose(){return Bs("dispose")}};function Bs(r){throw new Error(`'${r}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function _v(r){let t=r.length,e=0,n=0;for(;t>0;)n=Math.random()*t|0,t--,e=r[t],r[t]=r[n],r[n]=e}function VF(r,t){if(r.length!==t.length)throw Error(`Array sizes must match to be shuffled together First array length was ${r.length}Second array length was ${t.length}`);let e=r.length,n,s,o=0;for(;e>0;)o=Math.random()*e|0,e--,n=r[e],s=t[e],r[e]=r[o],t[e]=t[o],r[o]=n,t[o]=s}function Zl(r,t,e){return Math.max(r,Math.min(t,e))}function GF(r){return r%2==0?r:r+1}function WF(r){let t=0;for(let e=0;e<r.length;e++)t+=r[e];return t}function UF(r,t){let e=Math.random();return t*e+(1-e)*r}function jF(r,t){let e=0;for(let n=0;n<r.length;n++){let s=Number(r[n])-Number(t[n]);e+=s*s}return e}function tt(r,t){if(!r)throw new Error(typeof t=="string"?t:t())}function Jl(r,t,e=""){tt(Vs(r,t),()=>e+` Shapes ${r} and ${t} must match`)}function Xa(r){tt(r!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Ci(r,t=[],e=!1){if(t==null&&(t=[]),Array.isArray(r)||Dn(r)&&!e)for(let n=0;n<r.length;++n)Ci(r[n],t,e);else t.push(r);return t}function Je(r){if(r.length===0)return 1;let t=r[0];for(let e=1;e<r.length;e++)t*=r[e];return t}function qF(r){return r.length===0}function Vs(r,t){if(r===t)return!0;if(r==null||t==null||r.length!==t.length)return!1;for(let e=0;e<r.length;e++)if(r[e]!==t[e])return!1;return!0}function Be(r){return r%1==0}function HF(r){if(Math.tanh!=null)return Math.tanh(r);if(r===Infinity)return 1;if(r===-Infinity)return-1;{let t=Math.exp(2*r);return(t-1)/(t+1)}}function KF(r){let t=Math.ceil(Math.sqrt(r));return[t,Math.ceil(r/t)]}function XF(r){let t=new Uint32Array(r);for(let e=0;e<r;++e)t[e]=e;return _v(t),t}function Ya(r,t){return t<=r.length?r:r+" ".repeat(t-r.length)}function YF(r,t=n=>0,e){return new Promise((n,s)=>{let o=0,a=()=>{if(r()){n();return}o++;let l=t(o);if(e!=null&&o>=e){s();return}setTimeout(a,l)};a()})}function ZF(r,t){let e=1,n=-1;for(let o=0;o<r.length;++o)if(r[o]>=0)e*=r[o];else if(r[o]===-1){if(n!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${n} and dim ${o}`);n=o}else if(r[o]<0)throw Error(`Shapes can not be < 0. Found ${r[o]} at dim ${o}`);if(n===-1){if(t>0&&t!==e)throw Error(`Size(${t}) must match the product of shape ${r}`);return r}if(e===0)throw Error(`Cannot infer the missing size in [${r}] when there are 0 elements`);if(t%e!=0)throw Error(`The implicit shape can't be a fractional number. Got ${t} / ${e}`);let s=r.slice();return s[n]=t/e,s}function Ir(r,t){let e=t.length;return r=r==null?t.map((n,s)=>s):[].concat(r),tt(r.every(n=>n>=-e&&n<e),()=>`All values in axis param must be in range [-${e}, ${e}) but got axis ${r}`),tt(r.every(n=>Be(n)),()=>`All values in axis param must be integers but got axis ${r}`),r.map(n=>n<0?e+n:n)}function Gg(r,t){let e=[],n=[],s=t!=null&&Array.isArray(t)&&t.length===0,o=t==null||s?null:Ir(t,r).sort(),a=0;for(let l=0;l<r.length;++l){if(o!=null){if(o[a]===l&&r[l]!==1)throw new Error(`Can't squeeze axis ${l} since its dim '${r[l]}' is not 1`);(o[a]==null||o[a]>l)&&r[l]===1&&(e.push(r[l]),n.push(l)),o[a]<=l&&a++}r[l]!==1&&(e.push(r[l]),n.push(l))}return{newShape:e,keptDims:n}}function JF(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else throw new Error(`Unknown data type ${r}`);return e}function Wg(r,t){let e=null;if(r==null||r==="float32")e=new Float32Array(t);else if(r==="int32")e=new Int32Array(t);else if(r==="bool")e=new Uint8Array(t);else if(r==="string")e=new Array(t);else throw new Error(`Unknown data type ${r}`);return e}function Ug(r,t){for(let e=0;e<r.length;e++){let n=r[e];if(isNaN(n)||!isFinite(n))throw Error(`A tensor of type ${t} being uploaded contains ${n}.`)}}function jg(r){return r==="bool"||r==="complex64"||r==="float32"||r==="int32"||r==="string"}function QF(r,t){return!(t==="complex64"||t==="float32"&&r!=="complex64"||t==="int32"&&r!=="float32"&&r!=="complex64"||t==="bool"&&r==="bool")}function Dn(r){return r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array}function qg(r){if(r==="float32"||r==="int32")return 4;if(r==="complex64")return 8;if(r==="bool")return 1;throw new Error(`Unknown dtype ${r}`)}function Hg(r){if(r==null)return 0;let t=0;return r.forEach(e=>t+=e.length),t}function Ql(r){return typeof r=="string"||r instanceof String}function bv(r){return typeof r=="boolean"}function vv(r){return typeof r=="number"}function tu(r){return Array.isArray(r)?tu(r[0]):r instanceof Float32Array?"float32":r instanceof Int32Array||r instanceof Uint8Array?"int32":vv(r)?"float32":Ql(r)?"string":bv(r)?"bool":"float32"}function eu(r){return!!(r&&r.constructor&&r.call&&r.apply)}function ru(r,t){for(let e=t;e<r;++e)if(r%e==0)return e;return r}function Gs(r){let t=r.length;if(t<2)return[];let e=new Array(t-1);e[t-2]=r[t-1];for(let n=t-3;n>=0;--n)e[n]=e[n+1]*r[n+1];return e}function wv(r,t,e){let n=new Array;if(t.length===1){let s=t[0];for(let o=0;o<s;o++)n[o]=e[r+o]}else{let s=t[0],o=t.slice(1),a=o.reduce((l,u)=>l*u);for(let l=0;l<s;l++)n[l]=wv(r+l*a,o,e)}return n}function Za(r,t){if(r.length===0)return t[0];let e=r.reduce((n,s)=>n*s);if(e===0)return[];if(e!==t.length)throw new Error(`[${r}] does not match the input size ${t.length}.`);return wv(0,r,t)}function Xc(r,t){let e=nu(r,t);for(let n=0;n<e.length;n++)e[n]=1;return e}function nu(r,t){if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool")return new Uint8Array(r);throw new Error(`Unknown data type ${t}`)}function tO(r,t){let e=r.reduce((n,s)=>n*s,1);if(t==null||t==="float32")return Za(r,new Float32Array(e));if(t==="int32")return Za(r,new Int32Array(e));if(t==="bool")return Za(r,new Uint8Array(e));throw new Error(`Unknown data type ${t}`)}function Yc(r){r.forEach(t=>{tt(Number.isInteger(t)&&t>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${r}].`)})}function eO(r,t,e){if(t===0)return 0;if(t===1)return r[0];let n=r[r.length-1];for(let s=0;s<r.length-1;++s)n+=e[s]*r[s];return n}function rO(r,t,e){if(t===0)return[];if(t===1)return[r];let n=new Array(t);for(let s=0;s<n.length-1;++s)n[s]=Math.floor(r/e[s]),r-=n[s]*e[s];return n[n.length-1]=r,n}function Zc(r){return r&&r.then&&typeof r.then=="function"}var Cv="tfjsflags",Kg=class{constructor(t){this.global=t,this.flags={},this.flagRegistry={},this.urlFlags={},this.populateURLFlags()}setPlatform(t,e){this.platform!=null&&console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`),this.platformName=t,this.platform=e}registerFlag(t,e,n){if(this.flagRegistry[t]={evaluationFn:e,setHook:n},this.urlFlags[t]!=null){let s=this.urlFlags[t];console.warn(`Setting feature override from URL ${t}: ${s}.`),this.set(t,s)}}async getAsync(t){return t in this.flags?this.flags[t]:(this.flags[t]=await this.evaluateFlag(t),this.flags[t])}get(t){if(t in this.flags)return this.flags[t];let e=this.evaluateFlag(t);if(Zc(e))throw new Error(`Flag ${t} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[t]=e,this.flags[t]}getNumber(t){return this.get(t)}getBool(t){return this.get(t)}getFlags(){return this.flags}get features(){return this.flags}set(t,e){if(this.flagRegistry[t]==null)throw new Error(`Cannot set flag ${t} as it has not been registered.`);this.flags[t]=e,this.flagRegistry[t].setHook!=null&&this.flagRegistry[t].setHook(e)}evaluateFlag(t){if(this.flagRegistry[t]==null)throw new Error(`Cannot evaluate flag '${t}': no evaluation function found.`);return this.flagRegistry[t].evaluationFn()}setFlags(t){this.flags=Object.assign({},t)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;let t=nO(this.global.location.search);Cv in t&&t[Cv].split(",").forEach(n=>{let[s,o]=n.split(":");this.urlFlags[s]=sO(s,o)})}};function nO(r){let t={};return r.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(e,...n)=>(oO(t,n[0],n[1]),n.join("="))),t}function oO(r,t,e){r[decodeURIComponent(t)]=decodeURIComponent(e||"")}function sO(r,t){if(t=t.toLowerCase(),t==="true"||t==="false")return t==="true";if(`${+t}`===t)return+t;throw new Error(`Could not parse value flag value ${t} for flag ${r}.`)}function vt(){return kv}var kv=null;function Sv(r){kv=r}var Xg;function Yg(){if(Xg==null){let r;if(typeof window!="undefined")r=window;else if(typeof global!="undefined")r=global;else if(typeof process!="undefined")r=process;else if(typeof self!="undefined")r=self;else throw new Error("Could not find a global object");Xg=r}return Xg}function iO(){let r=Yg();return r._tfGlobals==null&&(r._tfGlobals=new Map),r._tfGlobals}function Jc(r,t){let e=iO();if(e.has(r))return e.get(r);{let n=t();return e.set(r,n),e.get(r)}}var ki="Abs",ao="Acos",lo="Acosh",_s="Add",su="AddN",ou="All",iu="Any",Si="ArgMax",Ii="ArgMin",uo="Asin",co="Asinh",po="Atan",fo="Atanh",ho="Atan2",Ni="AvgPool",au="AvgPoolGrad",Ti="AvgPool3D",lu="AvgPool3DGrad",Ei="BatchMatMul",Ai="BatchToSpaceND",Xf="Bincount",Iv="BroadcastTo",Ws="Cast",mo="Ceil",go="ClipByValue",uu="Complex",$i="ComplexAbs",Di="Concat",Ri="Conv2D",cu="Conv2DBackpropFilter",Fi="Conv2DBackpropInput",Oi="Conv3D",pu="Conv3DBackpropFilterV2",fu="Conv3DBackpropInputV2",xo="Cos",yo="Cosh",Pi="Cumsum",Yf="CropAndResize",Zf="DenseBincount",hu="DepthToSpace",Li="DepthwiseConv2dNative",mu="DepthwiseConv2dNativeBackpropFilter",du="DepthwiseConv2dNativeBackpropInput",Jf="Diag",zi="Dilation2D",Qc="Dilation2DBackpropInput",tp="Dilation2DBackpropFilter",_o="RealDiv",bo="Elu",gu="EluGrad",vo="Erf",Ja="Equal",wo="Exp",Mi="ExpandDims",Co="Expm1",xu="FFT",yu="Fill",Qf="FlipLeftRight",ko="Floor",So="FloorDiv",Bi="FusedBatchNorm",Vi="GatherV2",th="GatherNd",Qa="Greater",Io="GreaterEqual",Gi="Identity",_u="IFFT",bu="Imag",No="IsFinite",To="IsInf",Eo="IsNan",Wi="LeakyRelu",tl="Less",el="LessEqual",eh="LinSpace",Ao="Log",$o="Log1p",rl="LogicalAnd",nl="LogicalNot",sl="LogicalOr",Nv="LogSoftmax",Ui="LRN",vu="LRNGrad",ji="Max",Do="Maximum",qi="MaxPool",wu="MaxPoolGrad",Hi="MaxPool3D",Cu="MaxPool3DGrad",rh="MaxPoolWithArgmax",Ki="Mean",Xi="Min",Ro="Minimum",Yi="MirrorPad",Fo="Mod",nh="Multinomial",Oo="Multiply",Zi="Neg",ol="NotEqual",sh="NonMaxSuppressionV3",oh="NonMaxSuppressionV4",ih="NonMaxSuppressionV5",Ji="OnesLike",Qi="OneHot",ta="Pack",ea="PadV2";var Po="Pow",ra="Prelu",ku="Prod",Su="Range",Iu="Real",Lo="Reciprocal",zo="Relu",na="Reshape",sa="ResizeNearestNeighbor",Nu="ResizeNearestNeighborGrad",oa="ResizeBilinear",Tu="ResizeBilinearGrad",Mo="Relu6",ia="Reverse",Bo="Round",Vo="Rsqrt",ah="ScatterNd",aa="Select",Go="Selu",la="Slice",Wo="Sin",Uo="Sinh",jo="Sign",qo="Sigmoid",Ho="Softplus",Ko="Sqrt",ua="Sum",ca="SpaceToBatchND",pa="SplitV",fa="Softmax",Xo="SquaredDifference",Eu="Square",Yo="Sub",lh="SparseToDense",Au="StridedSlice",Zo="Tan",Jo="Tanh",Us="Tile",$u="TopK",ha="Transpose",Du="Unique",ma="Unpack",da="UnsortedSegmentSum",ga="ZerosLike",Qo="Step",ep="FromPixels",uh="RotateWithOffset",il="_FusedMatMul",al="FusedConv2D",ll="FusedDepthwiseConv2D";var ch=Jc("kernelRegistry",()=>new Map),Zg=Jc("gradRegistry",()=>new Map);function rp(r,t){let e=Tv(r,t);return ch.get(e)}function Jg(r){return Zg.get(r)}function Qg(r){let t=ch.entries(),e=[];for(;;){let{done:n,value:s}=t.next();if(n)break;let[o,a]=s,[l]=o.split("_");l===r&&e.push(a)}return e}function ph(r){let{kernelName:t,backendName:e}=r,n=Tv(t,e);ch.has(n)&&console.warn(`The kernel '${t}' for backend '${e}' is already registered`),ch.set(n,r)}function Ev(r){let{kernelName:t}=r;Zg.has(t)&&vt().getBool("DEBUG")&&console.warn(`Overriding the gradient for '${t}'`),Zg.set(t,r)}function Tv(r,t){return`${t}_${r}`}var E={};Yn(E,{arraysEqual:()=>Vs,assert:()=>tt,assertNonNegativeIntegerDimensions:()=>Yc,assertNonNull:()=>Xa,assertShapesMatch:()=>Jl,bytesFromStringArray:()=>Hg,bytesPerElement:()=>qg,checkConversionForErrors:()=>Ug,clamp:()=>Zl,computeStrides:()=>Gs,createScalarValue:()=>aO,createShuffledIndices:()=>XF,decodeString:()=>Ou,distSquared:()=>jF,encodeString:()=>Fu,fetch:()=>uO,flatten:()=>Ci,getArrayFromDType:()=>Wg,getTypedArrayFromDType:()=>JF,hasEncodingLoss:()=>QF,indexToLoc:()=>rO,inferDtype:()=>tu,inferFromImplicitShape:()=>ZF,isBoolean:()=>bv,isFunction:()=>eu,isInt:()=>Be,isNumber:()=>vv,isPromise:()=>Zc,isScalarShape:()=>qF,isString:()=>Ql,isTypedArray:()=>Dn,isValidDtype:()=>jg,locToIndex:()=>eO,makeOnesTypedArray:()=>Xc,makeZerosNestedTypedArray:()=>tO,makeZerosTypedArray:()=>nu,nearestDivisor:()=>ru,nearestLargerEven:()=>GF,now:()=>fh,parseAxisParam:()=>Ir,randUniform:()=>UF,repeatedTry:()=>YF,rightPad:()=>Ya,shuffle:()=>_v,shuffleCombo:()=>VF,sizeFromShape:()=>Je,sizeToSquarishShape:()=>KF,squeezeShape:()=>Gg,sum:()=>WF,tanh:()=>HF,toNestedArray:()=>Za,toTypedArray:()=>Ru});function aO(r,t){return t==="string"?Fu(r):Ru([r],t)}function lO(r,t){return r instanceof Float32Array&&t==="float32"||r instanceof Int32Array&&t==="int32"||r instanceof Uint8Array&&t==="bool"}function Ru(r,t){if(t==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(r)&&(r=Ci(r)),vt().getBool("DEBUG")&&Ug(r,t),lO(r,t))return r;if(t==null||t==="float32"||t==="complex64")return new Float32Array(r);if(t==="int32")return new Int32Array(r);if(t==="bool"){let e=new Uint8Array(r.length);for(let n=0;n<e.length;++n)Math.round(r[n])!==0&&(e[n]=1);return e}else throw new Error(`Unknown data type ${t}`)}function fh(){return vt().platform.now()}function uO(r,t){return vt().platform.fetch(r,t)}function Fu(r,t="utf-8"){return t=t||"utf-8",vt().platform.encode(r,t)}function Ou(r,t="utf-8"){return t=t||"utf-8",vt().platform.decode(r,t)}var tx=class{constructor(t,e){this.backendTimer=t,this.logger=e,e==null&&(this.logger=new Av)}profileKernel(t,e,n){let s,o=()=>{s=n()},a=this.backendTimer.time(o);if(vt().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let u=0;u<s.length;u++){let p=s[u];p.data().then(f=>{cO(f,p.dtype,t)})}return{kernelName:t,outputs:s,inputs:e,timeMs:a.then(u=>u.kernelMs),extraInfo:a.then(u=>u.getExtraProfileInfo!=null?u.getExtraProfileInfo():"")}}logKernelProfile(t){let{kernelName:e,outputs:n,timeMs:s,inputs:o,extraInfo:a}=t;n.forEach(l=>{Promise.all([l.data(),s,a]).then(u=>{this.logger.logKernelProfile(e,l,u[0],u[1],o,u[2])})})}};function cO(r,t,e){if(t!=="float32")return!1;for(let n=0;n<r.length;n++){let s=r[n];if(isNaN(s)||!isFinite(s))return console.warn(`Found ${s} in the result of '${e}'`),!0}return!1}var Av=class{logKernelProfile(t,e,n,s,o,a){let l=typeof s=="number"?Ya(`${s}ms`,9):s.error,u=Ya(t,25),p=e.rank,f=e.size,m=Ya(e.shape.toString(),14),d="";for(let y in o){let _=o[y];if(_!=null){let v=_.shape||e.shape,C=v.length;d+=`${y}: ${C}D ${C>0?v:""} `}}console.log(`%c${u}	%c${l}	%c${p}D ${m}	%c${f}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}};function $v(r,t,e){let n={},s={};for(let u=0;u<t.length;u++)n[t[u].id]=!0;for(let u=0;u<r.length;u++){let p=r[u],f=p.inputs;for(let m in f){let d=f[m],y=!1;for(let _=0;_<t.length;_++)if(n[d.id]){p.outputs.forEach(v=>n[v.id]=!0),y=!0,s[p.id]=!0;break}if(y)break}}let o={};o[e.id]=!0;let a={};for(let u=r.length-1;u>=0;u--){let p=r[u],f=p.inputs;for(let m=0;m<p.outputs.length;m++)if(o[p.outputs[m].id]){for(let d in f)o[f[d].id]=!0,a[p.id]=!0;break}}let l=[];for(let u=0;u<r.length;u++){let p=r[u];if(s[p.id]&&a[p.id]){let f={};for(let d in p.inputs){let y=p.inputs[d];n[y.id]&&(f[d]=y)}let m=Object.assign({},p);m.inputs=f,m.outputs=p.outputs,l.push(m)}}return l}function Dv(r,t,e,n){for(let s=t.length-1;s>=0;s--){let o=t[s],a=[];if(o.outputs.forEach(u=>{let p=r[u.id];p!=null?a.push(p):a.push(null)}),o.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${o.kernelName}.`);let l=o.gradient(a);for(let u in o.inputs){if(!(u in l))throw new Error(`Cannot backprop through input ${u}. Available gradients found: ${Object.keys(l)}.`);let p=e(()=>l[u]());if(p.dtype!=="float32")throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input ${u} must have 'float32' dtype, but has '${p.dtype}'`);let f=o.inputs[u];if(!Vs(p.shape,f.shape))throw new Error(`Error in gradient for op ${o.kernelName}. The gradient of input '${u}' has shape '${p.shape}', which does not match the shape of the input '${f.shape}'`);if(r[f.id]==null)r[f.id]=p;else{let m=r[f.id];r[f.id]=n(m,p),m.dispose()}}}}var Rv=20,np=3,ex=7;function Fv(r,t,e,n){let s=Gs(t),o=pO(r,t,e,s),a=t.length,l=hh(r,t,e,s,o),u=["Tensor"];return n&&(u.push(`  dtype: ${e}`),u.push(`  rank: ${a}`),u.push(`  shape: [${t}]`),u.push("  values:")),u.push(l.map(p=>"    "+p).join(`
`)),u.join(`
`)}function pO(r,t,e,n){let s=Je(t),o=n[n.length-1],a=new Array(o).fill(0),l=t.length,u=e==="complex64"?op(r):r;if(l>1)for(let p=0;p<s/o;p++){let f=p*o;for(let m=0;m<o;m++)a[m]=Math.max(a[m],sp(u[f+m],0,e).length)}return a}function sp(r,t,e){let n;return Array.isArray(r)?n=`${parseFloat(r[0].toFixed(ex))} + ${parseFloat(r[1].toFixed(ex))}j`:Ql(r)?n=`'${r}'`:e==="bool"?n=Ov(r):n=parseFloat(r.toFixed(ex)).toString(),Ya(n,t)}function Ov(r){return r===0?"false":"true"}function hh(r,t,e,n,s,o=!0){let a=e==="complex64"?2:1,l=t[0],u=t.length;if(u===0){if(e==="complex64"){let v=op(r);return[sp(v[0],0,e)]}return e==="bool"?[Ov(r[0])]:[r[0].toString()]}if(u===1){if(l>Rv){let C=np*a,N=Array.from(r.slice(0,C)),A=Array.from(r.slice((l-np)*a,l*a));return e==="complex64"&&(N=op(N),A=op(A)),["["+N.map((B,P)=>sp(B,s[P],e)).join(", ")+", ..., "+A.map((B,P)=>sp(B,s[l-np+P],e)).join(", ")+"]"]}let v=e==="complex64"?op(r):Array.from(r);return["["+v.map((C,N)=>sp(C,s[N],e)).join(", ")+"]"]}let p=t.slice(1),f=n.slice(1),m=n[0]*a,d=[];if(l>Rv){for(let v=0;v<np;v++){let C=v*m,N=C+m;d.push(...hh(r.slice(C,N),p,e,f,s,!1))}d.push("...");for(let v=l-np;v<l;v++){let C=v*m,N=C+m;d.push(...hh(r.slice(C,N),p,e,f,s,v===l-1))}}else for(let v=0;v<l;v++){let C=v*m,N=C+m;d.push(...hh(r.slice(C,N),p,e,f,s,v===l-1))}let y=u===2?",":"";d[0]="["+d[0]+y;for(let v=1;v<d.length-1;v++)d[v]=" "+d[v]+y;let _=`,
`;for(let v=2;v<u;v++)_+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(o?"":_),d}function op(r){let t=[];for(let e=0;e<r.length;e+=2)t.push([r[e],r[e+1]]);return t}var er=class{constructor(t,e,n){if(this.dtype=e,this.shape=t.slice(),this.size=Je(t),n!=null){let s=n.length;tt(s===this.size,()=>`Length of values '${s}' does not match the size inferred by the shape '${this.size}'.`)}if(e==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Wg(e,this.size),this.strides=Gs(t)}set(t,...e){e.length===0&&(e=[0]),tt(e.length===this.rank,()=>`The number of provided coordinates (${e.length}) must match the rank (${this.rank})`);let n=this.locToIndex(e);this.values[n]=t}get(...t){t.length===0&&(t=[0]);let e=0;for(let s of t){if(s<0||s>=this.shape[e]){let o=`Requested out of range element at ${t}.   Buffer shape=${this.shape}`;throw new Error(o)}e++}let n=t[t.length-1];for(let s=0;s<t.length-1;++s)n+=this.strides[s]*t[s];return this.values[n]}locToIndex(t){if(this.rank===0)return 0;if(this.rank===1)return t[0];let e=t[t.length-1];for(let n=0;n<t.length-1;++n)e+=this.strides[n]*t[n];return e}indexToLoc(t){if(this.rank===0)return[];if(this.rank===1)return[t];let e=new Array(this.shape.length);for(let n=0;n<e.length-1;++n)e[n]=Math.floor(t/this.strides[n]),t-=e[n]*this.strides[n];return e[e.length-1]=t,e}get rank(){return this.shape.length}toTensor(){return js().makeTensor(this.values,this.shape,this.dtype)}},js=null,Pu=null,fO=null;function Pv(r){js=r}function Lv(r){Pu=r}function zv(r){fO=r}var Ae=class{constructor(t,e,n,s){this.kept=!1,this.isDisposedInternal=!1,this.shape=t.slice(),this.dtype=e||"float32",this.size=Je(t),this.strides=Gs(t),this.dataId=n,this.id=s,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){let t=await this.data();return Pu.buffer(this.shape,this.dtype,t)}bufferSync(){return Pu.buffer(this.shape,this.dtype,this.dataSync())}async array(){let t=await this.data();return Za(this.shape,t)}arraySync(){return Za(this.shape,this.dataSync())}async data(){this.throwIfDisposed();let t=js().read(this.dataId);if(this.dtype==="string"){let e=await t;try{return e.map(n=>Ou(n))}catch(n){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return t}dataSync(){this.throwIfDisposed();let t=js().readSync(this.dataId);if(this.dtype==="string")try{return t.map(e=>Ou(e))}catch(e){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return t}async bytes(){this.throwIfDisposed();let t=await js().read(this.dataId);return this.dtype==="string"?t:new Uint8Array(t.buffer)}dispose(){this.isDisposed||(js().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(t=!1){return Pu.print(this,t)}clone(){return this.throwIfDisposed(),Pu.clone(this)}toString(t=!1){let e=this.dataSync();return Fv(e,this.shape,this.dtype,t)}cast(t){return this.throwIfDisposed(),Pu.cast(this,t)}variable(t=!0,e,n){return this.throwIfDisposed(),js().makeVariable(this,t,e,n)}};Object.defineProperty(Ae,Symbol.hasInstance,{value:r=>!!r&&r.data!=null&&r.dataSync!=null&&r.throwIfDisposed!=null});function rt(){return Jc("Tensor",()=>Ae)}rt();var ul=class extends Ae{constructor(t,e,n,s){super(t.shape,t.dtype,t.dataId,s);this.trainable=e,this.name=n}assign(t){if(t.dtype!==this.dtype)throw new Error(`dtype of the new value (${t.dtype}) and previous value (${this.dtype}) must match`);if(!Vs(t.shape,this.shape))throw new Error(`shape of the new value (${t.shape}) and previous value (${this.shape}) must match`);js().disposeTensor(this),this.dataId=t.dataId,js().incRef(this,null)}dispose(){js().disposeVariable(this),this.isDisposedInternal=!0}};Object.defineProperty(ul,Symbol.hasInstance,{value:r=>r instanceof Ae&&r.assign!=null&&r.assign instanceof Function});var bs={};Yn(bs,{assertTypesMatch:()=>mO,getTensorsInContainer:()=>ip,isTensorInList:()=>dO,makeTypesMatch:()=>Ne});var Mv;(function(r){r.R0="R0",r.R1="R1",r.R2="R2",r.R3="R3",r.R4="R4",r.R5="R5",r.R6="R6"})(Mv||(Mv={}));var rx;(function(r){r.float32="float32",r.int32="int32",r.bool="int32",r.complex64="complex64"})(rx||(rx={}));var nx;(function(r){r.float32="float32",r.int32="int32",r.bool="bool",r.complex64="complex64"})(nx||(nx={}));var sx;(function(r){r.float32="float32",r.int32="float32",r.bool="float32",r.complex64="complex64"})(sx||(sx={}));var ox;(function(r){r.float32="complex64",r.int32="complex64",r.bool="complex64",r.complex64="complex64"})(ox||(ox={}));var hO={float32:sx,int32:rx,bool:nx,complex64:ox};function Br(r,t){if(r==="string"||t==="string"){if(r==="string"&&t==="string")return"string";throw new Error(`Can not upcast ${r} with ${t}`)}return hO[r][t]}function Lu(r){return Br(r,"int32")}function Ne(r,t){if(r.dtype===t.dtype)return[r,t];let e=Br(r.dtype,t.dtype);return[r.cast(e),t.cast(e)]}function mO(r,t){tt(r.dtype===t.dtype,()=>`The dtypes of the first(${r.dtype}) and second(${t.dtype}) input must match`)}function dO(r,t){return t.some(e=>e.id===r.id)}function ip(r){let t=[],e=new Set;return Bv(r,t,e),t}function Bv(r,t,e){if(r==null)return;if(r instanceof Ae){t.push(r);return}if(!gO(r))return;let n=r;for(let s in n){let o=n[s];e.has(o)||(e.add(o),Bv(o,t,e))}}function gO(r){return Array.isArray(r)||typeof r=="object"}function ix(r){return r.kernelName!=null}var ax=class{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(t=>t.name)))}}}dispose(){for(let t in this.registeredVariables)this.registeredVariables[t].dispose()}},cl=class{constructor(t){this.ENV=t,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new ax}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e];if(await this.initializeBackend(n).success){await this.setBackend(n);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){let{name:t,asyncInit:e}=this.initializeBackendsAndReturnBest();if(e)throw new Error(`The highest priority backend '${t}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(t)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(t){if(!(t in this.registry))if(t in this.registryFactory){let{asyncInit:e}=this.initializeBackend(t);if(e)return null}else return null;return this.registry[t]}findBackendFactory(t){return t in this.registryFactory?this.registryFactory[t].factory:null}registerBackend(t,e,n=1){return t in this.registryFactory?(console.warn(`${t} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[t]={factory:e,priority:n},!0)}async setBackend(t){if(this.registryFactory[t]==null)throw new Error(`Backend name '${t}' not found in registry`);if(this.backendName=t,this.registry[t]==null){this.backendInstance=null;let{success:e,asyncInit:n}=this.initializeBackend(t);if(!(n?await e:e))return!1}return this.backendInstance=this.registry[t],this.setupRegisteredKernels(),this.profiler=new tx(this.backendInstance),!0}setupRegisteredKernels(){Qg(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(t){Qg(t).forEach(n=>{n.disposeFunc!=null&&n.disposeFunc(this.registry[t])})}initializeBackend(t){let e=this.registryFactory[t];if(e==null)throw new Error(`Cannot initialize backend ${t}, no registration found.`);try{let n=e.factory();if(n&&!(n instanceof Ka)&&typeof n.then=="function"){let s=++this.pendingBackendInitId,o=n.then(a=>s<this.pendingBackendInitId?!1:(this.registry[t]=a,this.pendingBackendInit=null,!0)).catch(a=>(s<this.pendingBackendInitId||(this.pendingBackendInit=null,console.warn(`Initialization of backend ${t} failed`),console.warn(a.stack||a.message)),!1));return this.pendingBackendInit=o,{success:o,asyncInit:!0}}else return this.registry[t]=n,{success:!0,asyncInit:!1}}catch(n){return console.warn(`Initialization of backend ${t} failed`),console.warn(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(t){if(!(t in this.registryFactory))throw new Error(`${t} backend not found in registry`);this.backendName===t&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,t in this.registry&&(this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t]),delete this.registryFactory[t],this.backendName===t&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((t,e)=>this.registryFactory[e].priority-this.registryFactory[t].priority)}initializeBackendsAndReturnBest(){let t=this.getSortedBackends();for(let e=0;e<t.length;e++){let n=t[e],{success:s,asyncInit:o}=this.initializeBackend(n);if(o||s)return{name:n,asyncInit:o}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(t,e){let n=this.state.tensorInfo.get(e),s=n.backend,o=this.readSync(e);s.disposeData(e),n.backend=t,t.move(e,o,n.shape,n.dtype),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(t,e){let n=null;if(e==null){if(typeof t!="function")throw new Error("Please provide a function to tidy()");e=t}else{if(typeof t!="string"&&!(t instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof e!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");n=t}let s;return this.scopedRun(()=>this.startScope(n),()=>this.endScope(s),()=>(s=e(),s instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),s))}scopedRun(t,e,n){t();try{let s=n();return e(),s}catch(s){throw e(),s}}nextTensorId(){return cl.nextTensorId++}nextVariableId(){return cl.nextVariableId++}clone(t){let e=this.makeTensorFromDataId(t.dataId,t.shape,t.dtype),n={x:t},s=a=>({x:()=>{let l="float32",u={x:a},p={dtype:l};return Y.runKernel(Ws,u,p)}}),o=[];return this.addTapeNode(this.state.activeScope.name,n,[e],s,o,{}),e}runKernel(t,e,n){if(!(rp(t,this.backendName)!=null))throw new Error(`Kernel '${t}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:t,inputs:e,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(t,e,n){let s=this.backend.numDataIds(),o=0;n.forEach(u=>{o+=u.dtype==="complex64"?3:1});let a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],l=s-e-o-a;if(l>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${l} data ids) after running '${t}'`)}runKernelFunc(t){let e,n=[],s=this.isTapeOn(),o=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let l;this.backendName==null&&this.backend;let u,p=ix(t)?t.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ix(t)){let{kernelName:_,inputs:v,attrs:C}=t;this.backendName==null&&this.backend;let N=rp(_,this.backendName);tt(N!=null,()=>`Cannot find registered kernel '${_}' for backend '${this.backendName}'`),l=()=>{let A=this.backend.numDataIds();u=N.kernelFunc({inputs:v,attrs:C,backend:this.backend});let B=Array.isArray(u)?u:[u];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(_,A,B);let P=B.map(L=>{if(L.rank!=null)return L;let{dataId:Z,shape:K,dtype:et}=L;return this.makeTensorFromDataId(Z,K,et)});if(s){let L=this.getTensorsForGradient(_,v,P);n=this.saveTensorsForBackwardMode(L)}return P}}else{let{forwardFunc:_}=t,v=C=>{!s||(n=C.map(N=>this.keep(this.clone(N))))};l=()=>{let C=this.backend.numDataIds();u=this.tidy(()=>_(this.backend,v));let N=Array.isArray(u)?u:[u];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,C,N),N}}let{inputs:f,attrs:m}=t,d=ix(t)?null:t.backwardsFunc,y;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?e=l():(y=this.profiler.profileKernel(p,f,()=>l()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(y),e=y.outputs)}),s&&this.addTapeNode(p,f,e,d,n,m),this.state.profiling&&this.state.activeProfile.kernels.push({name:p,bytesAdded:this.state.numBytes-o,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(f).map(_=>f[_]!=null?f[_].shape:null),outputShapes:e.map(_=>_.shape),kernelTimeMs:y.timeMs,extraInfo:y.extraInfo}),Array.isArray(u)?e:e[0]}saveTensorsForBackwardMode(t){return t.map(n=>this.keep(this.clone(n)))}getTensorsForGradient(t,e,n){let s=Jg(t);if(s!=null){let o=s.inputsToSave||[],a=s.outputsToSave||[],l;s.saveAllInputs?(tt(Array.isArray(e),()=>"saveAllInputs is true, expected inputs to be an array."),l=Object.keys(e).map(p=>e[p])):l=o.map(p=>e[p]);let u=n.filter((p,f)=>a[f]);return l.concat(u)}return[]}makeTensor(t,e,n,s){if(t==null)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",s=s||this.backend;let o=t;n==="string"&&Ql(t[0])&&(o=t.map(u=>Fu(u)));let a=s.write(o,e,n),l=new Ae(e,n,a,this.nextTensorId());if(this.incRef(l,s),n==="string"){let u=this.state.tensorInfo.get(a),p=Hg(o);this.state.numBytes+=p-u.bytes,u.bytes=p}return l}makeTensorFromDataId(t,e,n,s){n=n||"float32";let o=new Ae(e,n,t,this.nextTensorId());return this.incRef(o,s),o}makeVariable(t,e=!0,n,s){n=n||this.nextVariableId().toString(),s!=null&&s!==t.dtype&&(t=t.cast(s));let o=new ul(t,e,n,this.nextTensorId());if(this.state.registeredVariables[o.name]!=null)throw new Error(`Variable with name ${o.name} was already registered`);return this.state.registeredVariables[o.name]=o,this.incRef(o,this.backend),o}incRef(t,e){let n=this.state.tensorInfo.has(t.dataId)?this.state.tensorInfo.get(t.dataId).refCount:0;if(this.state.numTensors++,t.dtype==="string"&&this.state.numStringTensors++,n===0){this.state.numDataBuffers++;let s=0;t.dtype!=="complex64"&&t.dtype!=="string"&&(s=t.size*qg(t.dtype)),this.state.tensorInfo.set(t.dataId,{backend:e||this.backend,dtype:t.dtype,shape:t.shape,bytes:s,refCount:0}),this.state.numBytes+=s}this.state.tensorInfo.get(t.dataId).refCount++,t instanceof ul||this.track(t)}disposeTensor(t){if(!this.state.tensorInfo.has(t.dataId))return;this.state.numTensors--,t.dtype==="string"&&this.state.numStringTensors--;let e=this.state.tensorInfo.get(t.dataId);e.refCount<=1?(t.dtype!=="complex64"&&(this.state.numBytes-=e.bytes),this.state.numDataBuffers--,e.backend.disposeData(t.dataId),this.state.tensorInfo.delete(t.dataId)):(e.backend.decComplexRef(t.dataId),this.state.tensorInfo.get(t.dataId).refCount--)}disposeVariables(){for(let t in this.state.registeredVariables){let e=this.state.registeredVariables[t];this.disposeVariable(e)}}disposeVariable(t){this.disposeTensor(t),this.state.registeredVariables[t.name]!=null&&delete this.state.registeredVariables[t.name]}memory(){let t=this.backend.memory();return t.numTensors=this.state.numTensors,t.numDataBuffers=this.state.numDataBuffers,t.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(t.unreliable=!0,t.reasons==null&&(t.reasons=[]),t.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),t}async profile(t){this.state.profiling=!0;let e=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await t(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(s=>s.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-e,this.state.activeProfile.newTensors=this.state.numTensors-n;for(let s of this.state.activeProfile.kernels)s.kernelTimeMs=await s.kernelTimeMs,s.extraInfo=await s.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(t,e,n,s,o,a){let l={id:this.state.nextTapeNodeId++,kernelName:t,inputs:e,outputs:n,saved:o},u=Jg(t);u!=null&&(s=u.gradFunc),s!=null&&(l.gradient=p=>(p=p.map((f,m)=>{if(f==null){let d=n[m],y=nu(d.size,d.dtype);return this.makeTensor(y,d.shape,d.dtype)}return f}),s(p.length>1?p:p[0],o,a))),this.state.activeTape.push(l)}keep(t){return t.kept=!0,t}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(t){let e={track:[],name:"unnamed scope",id:this.state.nextScopeId++};t&&(e.name=t),this.state.scopeStack.push(e),this.state.activeScope=e}endScope(t){let e=ip(t),n=new Set(e.map(o=>o.id));for(let o=0;o<this.state.activeScope.track.length;o++){let a=this.state.activeScope.track[o];!a.kept&&!n.has(a.id)&&a.dispose()}let s=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],e.forEach(o=>{!o.kept&&o.scopeId===s.id&&this.track(o)})}gradients(t,e,n,s=!1){if(tt(e.length>0,()=>"gradients() received an empty list of xs."),n!=null&&n.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${n.dtype}'`);let o=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",t));tt(o instanceof Ae,()=>"The result y returned by f() must be a tensor.");let a=$v(this.state.activeTape,e,o);if(!s&&a.length===0&&e.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{let l={};l[o.id]=n??xO(o.shape),Dv(l,a,p=>this.tidy(p),yO);let u=e.map(p=>l[p.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(p=>{for(let f of p.saved)f.dispose()}),this.state.activeTape=null),{value:o,grads:u}})}customGrad(t){return tt(eu(t),()=>"The f passed in customGrad(f) must be a function."),(...e)=>{tt(e.every(l=>l instanceof Ae),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let n,s={};e.forEach((l,u)=>{s[u]=l});let o=(l,u)=>(n=t(...e,u),tt(n.value instanceof Ae,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),tt(eu(n.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),n.value),a=(l,u)=>{let p=n.gradFunc(l,u),f=Array.isArray(p)?p:[p];tt(f.length===e.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),tt(f.every(d=>d instanceof Ae),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");let m={};return f.forEach((d,y)=>{m[y]=()=>d}),m};return this.runKernelFunc({forwardFunc:o,backwardsFunc:a,inputs:s})}}readSync(t){return this.state.tensorInfo.get(t).backend.readSync(t)}read(t){return this.state.tensorInfo.get(t).backend.read(t)}async time(t){let e=fh(),n=await this.backend.time(t);return n.wallMs=fh()-e,n}track(t){return this.state.activeScope!=null&&(t.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(t)),t}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new ax;for(let t in this.registry)this.disposeRegisteredKernels(t),this.registry[t].dispose(),delete this.registry[t];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}};cl.nextTensorId=0;cl.nextVariableId=0;function xO(r){let t=Xc(Je(r),"float32");return Y.makeTensor(t,r,"float32")}function lx(){let r=Yg();if(r._tfengine==null){let t=new Kg(r);r._tfengine=new cl(t)}return Sv(r._tfengine.ENV),Pv(()=>r._tfengine),r._tfengine}var Y=lx();function yO(r,t){let e={a:r,b:t};return Y.runKernel(_s,e)}var ap={};Yn(ap,{isBrowser:()=>ux,isMobile:()=>bO});function _O(){return typeof navigator!="undefined"&&navigator!=null}function bO(){if(_O()){let r=navigator.userAgent||navigator.vendor||window.opera;return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(r)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(r.substr(0,4))}return!1}function ux(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}var qs=vt();qs.registerFlag("DEBUG",()=>!1,r=>{r&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});qs.registerFlag("IS_BROWSER",()=>ux());qs.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");qs.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));qs.registerFlag("PROD",()=>!1);qs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>qs.getBool("DEBUG"));qs.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);qs.registerFlag("IS_TEST",()=>!1);qs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);function ti(r,t){let e=r;if(Dn(r))return t==="string"?[]:[r.length];if(!Array.isArray(r))return[];let n=[];for(;Array.isArray(e)||Dn(e)&&t!=="string";)n.push(e.length),e=e[0];return Array.isArray(r)&&vt().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&Vv(r,n,[]),n}function Vv(r,t,e){if(e=e||[],!Array.isArray(r)&&!Dn(r)){tt(t.length===0,()=>`Element arr[${e.join("][")}] is a primitive, but should be an array/TypedArray of ${t[0]} elements`);return}tt(t.length>0,()=>`Element arr[${e.join("][")}] should be a primitive, but is an array of ${r.length} elements`),tt(r.length===t[0],()=>`Element arr[${e.join("][")}] should have ${t[0]} elements, but has ${r.length} elements`);let n=t.slice(1);for(let s=0;s<r.length;++s)Vv(r[s],n,e.concat(s))}function Gv(r,t,e,n){if(r!=="string_or_numeric"){if(r==null)throw new Error("Expected dtype cannot be null.");if(r!=="numeric"&&r!==t||r==="numeric"&&t==="string")throw new Error(`Argument '${e}' passed to '${n}' must be ${r} tensor, but got ${t} tensor`)}}function X(r,t,e,n="numeric"){if(r instanceof Ae)return Gv(n,r.dtype,t,e),r;let s=tu(r);if(s!=="string"&&["bool","int32","float32"].indexOf(n)>=0&&(s=n),Gv(n,s,t,e),r==null||!Dn(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string"){let u=r==null?"null":r.constructor.name;throw new Error(`Argument '${t}' passed to '${e}' must be a Tensor or TensorLike, but got '${u}'`)}let o=ti(r,s);!Dn(r)&&!Array.isArray(r)&&(r=[r]);let l=s!=="string"?Ru(r,s):Ci(r,[],!0);return Y.makeTensor(l,o,s)}function mh(r,t,e,n="numeric"){if(!Array.isArray(r))throw new Error(`Argument ${t} passed to ${e} must be a \`Tensor[]\` or \`TensorLike[]\``);return r.map((o,a)=>X(o,`${t}[${a}]`,e,n))}var vO="__op";function Q(r){let t=Object.keys(r);if(t.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${t.length} keys.`);let e=t[0],n=r[e];e.endsWith("_")&&(e=e.substring(0,e.length-1)),e=e+vO;let s=(...o)=>{Y.startScope(e);try{let a=n(...o);return Zc(a)&&console.error("Cannot return a Promise inside of tidy."),Y.endScope(a),a}catch(a){throw Y.endScope(null),a}};return Object.defineProperty(s,"name",{value:e,configurable:!0}),s}function wO(r,t){let e=X(r,"real","complex"),n=X(t,"imag","complex");Jl(e.shape,n.shape,`real and imag shapes, ${e.shape} and ${n.shape}, must match in call to tf.complex().`);let s={real:e,imag:n};return Y.runKernel(uu,s)}var vs=Q({complex_:wO});function Hs(r,t,e,n){if(n==null&&(n=tu(r)),n==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Dn(r)&&!Array.isArray(r)&&typeof r!="number"&&typeof r!="boolean"&&typeof r!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(t!=null){Yc(t);let s=Je(t),o=Je(e);tt(s===o,()=>`Based on the provided shape, [${t}], the tensor should have ${s} values but has ${o}`);for(let a=0;a<e.length;++a){let l=e[a],u=a===e.length-1?l!==Je(t.slice(a)):!0;tt(e[a]===t[a]||!u,()=>`Error creating a new Tensor. Inferred shape (${e}) does not match the provided shape (${t}). `)}}return!Dn(r)&&!Array.isArray(r)&&(r=[r]),t=t||e,r=n!=="string"?Ru(r,n):Ci(r,[],!0),Y.makeTensor(r,t,n)}function ei(r,t,e){let n=ti(r,e);return Hs(r,t,n,e)}var lp={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};var dh=4;async function Wv(r,t){let e=[],n=[],s=Array.isArray(r)?r.map(a=>a.name):Object.keys(r);for(let a=0;a<s.length;++a){let l=s[a],u=Array.isArray(r)?r[a].tensor:r[l];if(u.dtype!=="float32"&&u.dtype!=="int32"&&u.dtype!=="bool"&&u.dtype!=="string"&&u.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${l}': ${u.dtype}`);let p={name:l,shape:u.shape,dtype:u.dtype};if(u.dtype==="string"){let f=new Promise(async m=>{let d=await u.bytes(),y=d.reduce((C,N)=>C+N.length,0)+dh*d.length,_=new Uint8Array(y),v=0;for(let C=0;C<d.length;C++){let N=d[C],A=new Uint8Array(new Uint32Array([N.length]).buffer);_.set(A,v),v+=dh,_.set(N,v),v+=N.length}m(_)});n.push(f)}else n.push(u.data());t!=null&&(p.group=t),e.push(p)}let o=await Promise.all(n);return{data:CO(o),specs:e}}function gh(r,t){let e={},n,s=0;for(let o of t){let a=o.name,l=o.dtype,u=o.shape,p=Je(u),f;if("quantization"in o){let m=o.quantization;if(m.dtype==="uint8"||m.dtype==="uint16"){if(!("min"in m&&"scale"in m))throw new Error(`Weight ${o.name} with quantization ${m.dtype} doesn't have corresponding metadata min and scale.`)}else if(m.dtype==="float16"){if(l!=="float32")throw new Error(`Weight ${o.name} is quantized with ${m.dtype} which only supports weights of type float32 not ${l}.`)}else throw new Error(`Weight ${o.name} has unknown quantization dtype ${m.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);let d=lp[m.dtype],y=r.slice(s,s+p*d),_=m.dtype==="uint8"?new Uint8Array(y):new Uint16Array(y);if(l==="float32")if(m.dtype==="uint8"||m.dtype==="uint16"){f=new Float32Array(_.length);for(let v=0;v<_.length;v++){let C=_[v];f[v]=C*m.scale+m.min}}else if(m.dtype==="float16")n===void 0&&(n=kO()),f=n(_);else throw new Error(`Unsupported quantization type ${m.dtype} for weight type float32.`);else if(l==="int32"){if(m.dtype!=="uint8"&&m.dtype!=="uint16")throw new Error(`Unsupported quantization type ${m.dtype} for weight type int32.`);f=new Int32Array(_.length);for(let v=0;v<_.length;v++){let C=_[v];f[v]=Math.round(C*m.scale+m.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${l}`);s+=p*d}else if(l==="string"){let m=Je(o.shape);f=[];for(let d=0;d<m;d++){let y=new Uint32Array(r.slice(s,s+dh))[0];s+=dh;let _=new Uint8Array(r.slice(s,s+y));f.push(_),s+=y}}else{let m=lp[l],d=r.slice(s,s+p*m);if(l==="float32")f=new Float32Array(d);else if(l==="int32")f=new Int32Array(d);else if(l==="bool")f=new Uint8Array(d);else if(l==="complex64"){f=new Float32Array(d);let y=new Float32Array(f.length/2),_=new Float32Array(f.length/2);for(let N=0;N<y.length;N++)y[N]=f[N*2],_[N]=f[N*2+1];let v=ei(y,u,"float32"),C=ei(_,u,"float32");e[a]=vs(v,C),v.dispose(),C.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${l}`);s+=p*m}l!=="complex64"&&(e[a]=ei(f,u,l))}return e}function CO(r){if(r===null)throw new Error(`Invalid input value: ${JSON.stringify(r)}`);let t=0,e=[];r.forEach(o=>{if(t+=o.byteLength,e.push(o.byteLength===o.buffer.byteLength?o:new o.constructor(o)),!(o instanceof Float32Array||o instanceof Int32Array||o instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${o.constructor.name}`)});let n=new Uint8Array(t),s=0;return e.forEach(o=>{n.set(new Uint8Array(o.buffer),s),s+=o.byteLength}),n.buffer}var cx=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function Uv(r){return cx?Buffer.byteLength(r):new Blob([r]).size}function jv(r){if(cx)return Buffer.from(r).toString("base64");let t=new Uint8Array(r),e="";for(let n=0,s=t.length;n<s;n++)e+=String.fromCharCode(t[n]);return btoa(e)}function qv(r){if(cx){let n=Buffer.from(r,"base64");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}let t=atob(r),e=new Uint8Array(t.length);for(let n=0;n<t.length;++n)e.set([t.charCodeAt(n)],n);return e.buffer}function zu(r){if(r.length===1)return r[0];let t=0;r.forEach(s=>{t+=s.byteLength});let e=new Uint8Array(t),n=0;return r.forEach(s=>{e.set(new Uint8Array(s),n),n+=s.byteLength}),e.buffer}function px(r){let t="/";for(r=r.trim();r.endsWith(t);)r=r.slice(0,r.length-1);let e=r.split(t);return e[e.length-1]}function Ks(r){if(r.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:r.modelTopology==null?0:Uv(JSON.stringify(r.modelTopology)),weightSpecsBytes:r.weightSpecs==null?0:Uv(JSON.stringify(r.weightSpecs)),weightDataBytes:r.weightData==null?0:r.weightData.byteLength}}function SO(){let r=e=>{let n=e<<13,s=0;for(;(n&8388608)==0;)s-=8388608,n<<=1;return n&=~8388608,s+=947912704,n|s},t=new Uint32Array(2048);t[0]=0;for(let e=1;e<1024;e++)t[e]=r(e);for(let e=1024;e<2048;e++)t[e]=939524096+(e-1024<<13);return t}function IO(){let r=new Uint32Array(64);r[0]=0,r[31]=1199570944,r[32]=2147483648,r[63]=3347054592;for(let t=1;t<31;t++)r[t]=t<<23;for(let t=33;t<63;t++)r[t]=2147483648+(t-32<<23);return r}function NO(){let r=new Uint32Array(64);for(let t=0;t<64;t++)r[t]=1024;return r[0]=r[32]=0,r}function kO(){let r=SO(),t=IO(),e=NO();return n=>{let s=new ArrayBuffer(4*n.length),o=new Uint32Array(s);for(let a=0;a<n.length;a++){let l=n[a],u=r[e[l>>10]+(l&1023)]+t[l>>10];o[a]=u}return new Float32Array(s)}}var rr=class{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return rr.instance==null&&(rr.instance=new rr),rr.instance}static registerSaveRouter(t){rr.getInstance().saveRouters.push(t)}static registerLoadRouter(t){rr.getInstance().loadRouters.push(t)}static getSaveHandlers(t){return rr.getHandlers(t,"save")}static getLoadHandlers(t,e){return rr.getHandlers(t,"load",e)}static getHandlers(t,e,n){let s=[];return(e==="load"?rr.getInstance().loadRouters:rr.getInstance().saveRouters).forEach(a=>{let l=a(t,n);l!==null&&s.push(l)}),s}},Hv=r=>rr.registerSaveRouter(r),Kv=r=>rr.registerLoadRouter(r),Xv=r=>rr.getSaveHandlers(r),Yv=(r,t)=>rr.getLoadHandlers(r,t);var fx="tensorflowjs",hx=1,pl="models_store",xa="model_info_store";function Zv(){if(!vt().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");let r=typeof window=="undefined"?self:window,t=r.indexedDB||r.mozIndexedDB||r.webkitIndexedDB||r.msIndexedDB||r.shimIndexedDB;if(t==null)throw new Error("The current browser does not appear to support IndexedDB.");return t}function mx(r){let t=r.result;t.createObjectStore(pl,{keyPath:"modelPath"}),t.createObjectStore(xa,{keyPath:"modelPath"})}var ri=class{constructor(t){if(this.indexedDB=Zv(),t==null||!t)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=t}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,t)}async load(){return this.databaseAction(this.modelPath)}databaseAction(t,e){return new Promise((n,s)=>{let o=this.indexedDB.open(fx,hx);o.onupgradeneeded=()=>mx(o),o.onsuccess=()=>{let a=o.result;if(e==null){let l=a.transaction(pl,"readonly"),p=l.objectStore(pl).get(this.modelPath);p.onsuccess=()=>{if(p.result==null)return a.close(),s(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));n(p.result.modelArtifacts)},p.onerror=f=>(a.close(),s(p.error)),l.oncomplete=()=>a.close()}else{let l=Ks(e),u=a.transaction(xa,"readwrite"),p=u.objectStore(xa),f=p.put({modelPath:this.modelPath,modelArtifactsInfo:l}),m;f.onsuccess=()=>{m=a.transaction(pl,"readwrite");let y=m.objectStore(pl).put({modelPath:this.modelPath,modelArtifacts:e,modelArtifactsInfo:l});y.onsuccess=()=>n({modelArtifactsInfo:l}),y.onerror=_=>{p=u.objectStore(xa);let v=p.delete(this.modelPath);v.onsuccess=()=>(a.close(),s(y.error)),v.onerror=C=>(a.close(),s(y.error))}},f.onerror=d=>(a.close(),s(f.error)),u.oncomplete=()=>{m==null?a.close():m.oncomplete=()=>a.close()}}},o.onerror=a=>s(o.error)})}};ri.URL_SCHEME="indexeddb://";var Jv=r=>vt().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(ri.URL_SCHEME)?TO(r.slice(ri.URL_SCHEME.length)):null;rr.registerSaveRouter(Jv);rr.registerLoadRouter(Jv);function TO(r){return new ri(r)}function EO(r){return r.startsWith(ri.URL_SCHEME)?r.slice(ri.URL_SCHEME.length):r}var dx=class{constructor(){this.indexedDB=Zv()}async listModels(){return new Promise((t,e)=>{let n=this.indexedDB.open(fx,hx);n.onupgradeneeded=()=>mx(n),n.onsuccess=()=>{let s=n.result,o=s.transaction(xa,"readonly"),l=o.objectStore(xa).getAll();l.onsuccess=()=>{let u={};for(let p of l.result)u[p.modelPath]=p.modelArtifactsInfo;t(u)},l.onerror=u=>(s.close(),e(l.error)),o.oncomplete=()=>s.close()},n.onerror=s=>e(n.error)})}async removeModel(t){return t=EO(t),new Promise((e,n)=>{let s=this.indexedDB.open(fx,hx);s.onupgradeneeded=()=>mx(s),s.onsuccess=()=>{let o=s.result,a=o.transaction(xa,"readwrite"),l=a.objectStore(xa),u=l.get(t),p;u.onsuccess=()=>{if(u.result==null)return o.close(),n(new Error(`Cannot find model with path '${t}' in IndexedDB.`));{let f=l.delete(t),m=()=>{p=o.transaction(pl,"readwrite");let y=p.objectStore(pl).delete(t);y.onsuccess=()=>e(u.result.modelArtifactsInfo),y.onerror=_=>n(u.error)};f.onsuccess=m,f.onerror=d=>(m(),o.close(),n(u.error))}},u.onerror=f=>(o.close(),n(u.error)),a.oncomplete=()=>{p==null?o.close():p.oncomplete=()=>o.close()}},s.onerror=o=>n(s.error)})}};var ni="/",Mu="tensorflowjs_models",Qv="info",AO="model_topology",$O="weight_specs",DO="weight_data",RO="model_metadata";function tw(r){return{info:[Mu,r,Qv].join(ni),topology:[Mu,r,AO].join(ni),weightSpecs:[Mu,r,$O].join(ni),weightData:[Mu,r,DO].join(ni),modelMetadata:[Mu,r,RO].join(ni)}}function FO(r){let t=r.split(ni);if(t.length<3)throw new Error(`Invalid key format: ${r}`);return t.slice(1,t.length-1).join(ni)}function OO(r){return r.startsWith(si.URL_SCHEME)?r.slice(si.URL_SCHEME.length):r}var si=class{constructor(t){if(!vt().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,t==null||!t)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=t,this.keys=tw(this.modelPath)}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{let e=JSON.stringify(t.modelTopology),n=JSON.stringify(t.weightSpecs),s=Ks(t);try{this.LS.setItem(this.keys.info,JSON.stringify(s)),this.LS.setItem(this.keys.topology,e),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,jv(t.weightData));let o={format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};return t.signature!=null&&(o.signature=t.signature),t.userDefinedMetadata!=null&&(o.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(o.modelInitializer=t.modelInitializer),this.LS.setItem(this.keys.modelMetadata,JSON.stringify(o)),{modelArtifactsInfo:s}}catch(o){throw this.LS.removeItem(this.keys.info),this.LS.removeItem(this.keys.topology),this.LS.removeItem(this.keys.weightSpecs),this.LS.removeItem(this.keys.weightData),this.LS.removeItem(this.keys.modelMetadata),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${s.modelTopologyBytes}, weightSpecsBytes=${s.weightSpecsBytes}, weightDataBytes=${s.weightDataBytes}.`)}}}async load(){let t=JSON.parse(this.LS.getItem(this.keys.info));if(t==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(t.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");let e={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(n==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);e.modelTopology=n;let s=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(s==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);e.weightSpecs=s;let o=this.LS.getItem(this.keys.modelMetadata);if(o!=null){let l=JSON.parse(o);e.format=l.format,e.generatedBy=l.generatedBy,e.convertedBy=l.convertedBy,l.signature!=null&&(e.signature=l.signature),l.userDefinedMetadata!=null&&(e.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(e.modelInitializer=l.modelInitializer)}let a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return e.weightData=qv(a),e}};si.URL_SCHEME="localstorage://";var ew=r=>vt().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(si.URL_SCHEME)?PO(r.slice(si.URL_SCHEME.length)):null;rr.registerSaveRouter(ew);rr.registerLoadRouter(ew);function PO(r){return new si(r)}var gx=class{constructor(){tt(vt().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),tt(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){let t={},e=Mu+ni,n=ni+Qv;for(let s=0;s<this.LS.length;++s){let o=this.LS.key(s);if(o.startsWith(e)&&o.endsWith(n)){let a=FO(o);t[a]=JSON.parse(this.LS.getItem(o))}}return t}async removeModel(t){t=OO(t);let e=tw(t);if(this.LS.getItem(e.info)==null)throw new Error(`Cannot find model at path '${t}'`);let n=JSON.parse(this.LS.getItem(e.info));return this.LS.removeItem(e.info),this.LS.removeItem(e.topology),this.LS.removeItem(e.weightSpecs),this.LS.removeItem(e.weightData),n}};var Bu="://",cn=class{constructor(){this.managers={}}static getInstance(){return cn.instance==null&&(cn.instance=new cn),cn.instance}static registerManager(t,e){tt(t!=null,()=>"scheme must not be undefined or null."),t.endsWith(Bu)&&(t=t.slice(0,t.indexOf(Bu))),tt(t.length>0,()=>"scheme must not be an empty string.");let n=cn.getInstance();tt(n.managers[t]==null,()=>`A model store manager is already registered for scheme '${t}'.`),n.managers[t]=e}static getManager(t){let e=this.getInstance().managers[t];if(e==null)throw new Error(`Cannot find model manager for scheme '${t}'`);return e}static getSchemes(){return Object.keys(this.getInstance().managers)}};function xh(r){if(r.indexOf(Bu)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${cn.getSchemes().join(",")}`);return{scheme:r.split(Bu)[0],path:r.split(Bu)[1]}}async function rw(r,t,e=!1){tt(r!==t,()=>`Old path and new path are the same: '${r}'`);let n=rr.getLoadHandlers(r);tt(n.length>0,()=>`Copying failed because no load handler is found for source URL ${r}.`),tt(n.length<2,()=>`Copying failed because more than one (${n.length}) load handlers for source URL ${r}.`);let s=n[0],o=rr.getSaveHandlers(t);tt(o.length>0,()=>`Copying failed because no save handler is found for destination URL ${t}.`),tt(o.length<2,()=>`Copying failed because more than one (${n.length}) save handlers for destination URL ${t}.`);let a=o[0],l=xh(r).scheme,u=xh(r).path,p=l===xh(r).scheme,f=await s.load();e&&p&&await cn.getManager(l).removeModel(u);let m=await a.save(f);return e&&!p&&await cn.getManager(l).removeModel(u),m.modelArtifactsInfo}async function nw(){let r=cn.getSchemes(),t={};for(let e of r){let n=await cn.getManager(e).listModels();for(let s in n){let o=e+Bu+s;t[o]=n[s]}}return t}async function sw(r){let t=xh(r);return cn.getManager(t.scheme).removeModel(t.path)}async function ow(r,t){return rw(r,t,!1)}async function iw(r,t){return rw(r,t,!0)}var aw=class{fetch(t,e){return fetch(t,e)}now(){return performance.now()}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${e}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(t)}decode(t,e){return new TextDecoder(e).decode(t)}};if(vt().get("IS_BROWSER")){vt().setPlatform("browser",new aw);try{cn.registerManager(si.URL_SCHEME,new gx)}catch(r){}try{cn.registerManager(ri.URL_SCHEME,new dx)}catch(r){}}var LO={importFetch:()=>lw()},xx;var cw=class{constructor(){this.util=uw(),this.textEncoder=new this.util.TextEncoder}fetch(t,e){return vt().global.fetch!=null?vt().global.fetch(t,e):(xx==null&&(xx=LO.importFetch()),xx(t,e))}now(){let t=process.hrtime();return t[0]*1e3+t[1]/1e6}encode(t,e){if(e!=="utf-8"&&e!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${e}`);return this.textEncoder.encode(t)}decode(t,e){return t.length===0?"":new this.util.TextDecoder(e).decode(t)}};vt().get("IS_NODE")&&vt().setPlatform("node",new cw);function ae(r,t="float32",e){return t=t||"float32",Yc(r),new er(r,t,e)}function zO(r,t){let e=X(r,"x","cast");if(!jg(t))throw new Error(`Failed to cast to unknown dtype ${t}`);if(t==="string"&&e.dtype!=="string"||t!=="string"&&e.dtype==="string")throw new Error("Only strings can be casted to strings");let n={x:e},s={dtype:t};return Y.runKernel(Ws,n,s)}var Vt=Q({cast_:zO});function MO(r){let e={x:X(r,"x","clone","string_or_numeric")};return Y.runKernel(Gi,e)}var ws=Q({clone_:MO});function pw(r,t=!1){console.log(r.toString(t))}lx();var BO={buffer:ae,cast:Vt,clone:ws,print:pw};Lv(BO);var Cs={};Yn(Cs,{browserFiles:()=>mw,browserHTTPRequest:()=>xw,concatenateArrayBuffers:()=>zu,copyModel:()=>ow,decodeWeights:()=>gh,encodeWeights:()=>Wv,fromMemory:()=>_w,getLoadHandlers:()=>Yv,getModelArtifactsInfoForJSON:()=>Ks,getSaveHandlers:()=>Xv,http:()=>bh,isHTTPScheme:()=>_h,listModels:()=>nw,loadWeights:()=>dw,moveModel:()=>iw,registerLoadRouter:()=>Kv,registerSaveRouter:()=>Hv,removeModel:()=>sw,weightsLoaderFactory:()=>bx,withSaveHandler:()=>bw});var VO="model",GO=".json",WO=".weights.bin";function fw(r){return new Promise(t=>setTimeout(t)).then(r)}var ya=class{constructor(t){if(!vt().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");t.startsWith(ya.URL_SCHEME)&&(t=t.slice(ya.URL_SCHEME.length)),(t==null||t.length===0)&&(t=VO),this.modelTopologyFileName=t+GO,this.weightDataFileName=t+WO}async save(t){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");let e=window.URL.createObjectURL(new Blob([t.weightData],{type:"application/octet-stream"}));if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{let n=[{paths:["./"+this.weightDataFileName],weights:t.weightSpecs}],s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n};t.signature!=null&&(s.signature=t.signature),t.userDefinedMetadata!=null&&(s.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(s.modelInitializer=t.modelInitializer);let o=window.URL.createObjectURL(new Blob([JSON.stringify(s)],{type:"application/json"})),a=this.jsonAnchor==null?document.createElement("a"):this.jsonAnchor;if(a.download=this.modelTopologyFileName,a.href=o,await fw(()=>a.dispatchEvent(new MouseEvent("click"))),t.weightData!=null){let l=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;l.download=this.weightDataFileName,l.href=e,await fw(()=>l.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Ks(t)}}}};ya.URL_SCHEME="downloads://";var hw=class{constructor(t){if(t==null||t.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${t}`);this.files=t}async load(){let t=this.files[0],e=this.files.slice(1);return new Promise((n,s)=>{let o=new FileReader;o.onload=a=>{let l=JSON.parse(a.target.result),u=l.modelTopology;if(u==null){s(new Error(`modelTopology field is missing from file ${t.name}`));return}e.length===0&&n({modelTopology:u});let p=l.weightsManifest;if(p==null){s(new Error(`weightManifest field is missing from file ${t.name}`));return}let f;try{f=this.checkManifestAndWeightFiles(p,e)}catch(_){s(_);return}let m=[],d=[],y=[];p.forEach(_=>{_.paths.forEach(v=>{d.push(v),y.push(null)}),m.push(..._.weights)}),p.forEach(_=>{_.paths.forEach(v=>{let C=new FileReader;C.onload=N=>{let A=N.target.result,B=d.indexOf(v);if(y[B]=A,y.indexOf(null)===-1){let P={modelTopology:u,weightSpecs:m,weightData:zu(y),format:l.format,generatedBy:l.generatedBy,convertedBy:l.convertedBy};l.signature!=null&&(P.signature=l.signature),l.userDefinedMetadata!=null&&(P.userDefinedMetadata=l.userDefinedMetadata),l.modelInitializer!=null&&(P.modelInitializer=l.modelInitializer),n(P)}},C.onerror=N=>s(`Failed to weights data from file of path '${v}'.`),C.readAsArrayBuffer(f[v])})})},o.onerror=a=>s(`Failed to read model topology and weights manifest JSON from file '${t.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),o.readAsText(t)})}checkManifestAndWeightFiles(t,e){let n=[],s=e.map(a=>px(a.name)),o={};for(let a of t)a.paths.forEach(l=>{let u=px(l);if(n.indexOf(u)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${u}'`);if(n.push(u),s.indexOf(u)===-1)throw new Error(`Weight file with basename '${u}' is not provided.`);o[l]=e[s.indexOf(u)]});if(n.length!==e.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${e.length}).`);return o}},jO=r=>vt().getBool("IS_BROWSER")&&!Array.isArray(r)&&r.startsWith(ya.URL_SCHEME)?UO(r.slice(ya.URL_SCHEME.length)):null;rr.registerSaveRouter(jO);function UO(r="model"){return new ya(r)}function mw(r){return new hw(r)}function yx(r,t,e,n){a(r),e=e??0,n=n??1,l(e,n);let s=0,o=u=>(u.then(p=>{let f=e+ ++s/r.length*(n-e);return t(f),p}),u);function a(u){tt(u!=null&&Array.isArray(u)&&u.length>0,()=>"promises must be a none empty array")}function l(u,p){tt(u>=0&&u<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${u}`),tt(p>=0&&p<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${p}`),tt(p>=u,()=>`startFraction must be no more than endFraction, but got startFraction ${u} and endFraction ${p}`)}return Promise.all(r.map(o))}async function _x(r,t){t==null&&(t={});let e=t.fetchFunc==null?vt().platform.fetch:t.fetchFunc,n=r.map(m=>e(m,t.requestInit,{isBinary:!0})),s=0,o=.5,l=(t.onProgress==null?await Promise.all(n):await yx(n,t.onProgress,s,o)).map(m=>m.arrayBuffer()),u=.5,p=1;return t.onProgress==null?await Promise.all(l):await yx(l,t.onProgress,u,p)}async function dw(r,t="",e,n){return bx(a=>_x(a,{requestInit:n}))(r,t,e)}function bx(r){return async(t,e="",n)=>{let s=t.map(()=>!1),o={},a=n!=null?n.map(()=>!1):[],l=[];if(t.forEach((y,_)=>{let v=0;y.weights.forEach(C=>{let N="quantization"in C?C.quantization.dtype:C.dtype,A=lp[N]*Je(C.shape),B=()=>{s[_]=!0,o[_]==null&&(o[_]=[]),o[_].push({manifestEntry:C,groupOffset:v,sizeBytes:A})};n!=null?n.forEach((P,L)=>{P===C.name&&(B(),a[L]=!0)}):B(),l.push(C.name),v+=A})}),!a.every(y=>y)){let y=n.filter((_,v)=>!a[v]);throw new Error(`Could not find weights in manifest with names: ${y.join(", ")}. 
Manifest JSON has weights with names: ${l.join(", ")}.`)}let u=s.reduce((y,_,v)=>(_&&y.push(v),y),[]),p=[];u.forEach(y=>{t[y].paths.forEach(_=>{let v=e+(e.endsWith("/")?"":"/")+_;p.push(v)})});let f=await r(p),m={},d=0;return u.forEach(y=>{let _=t[y].paths.length,v=0;for(let P=0;P<_;P++)v+=f[d+P].byteLength;let C=new ArrayBuffer(v),N=new Uint8Array(C),A=0;for(let P=0;P<_;P++){let L=new Uint8Array(f[d+P]);N.set(L,A),A+=L.byteLength}o[y].forEach(P=>{let L=C.slice(P.groupOffset,P.groupOffset+P.sizeBytes),Z=gh(L,[P.manifestEntry]);for(let K in Z)m[K]=Z[K]}),d+=_}),m}}var qO="application/octet-stream",HO="application/json",yh=class{constructor(t,e){if(this.DEFAULT_METHOD="POST",e==null&&(e={}),this.weightPathPrefix=e.weightPathPrefix,this.onProgress=e.onProgress,this.weightUrlConverter=e.weightUrlConverter,e.fetchFunc!=null?(tt(typeof e.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=e.fetchFunc):this.fetch=vt().platform.fetch,tt(t!=null&&t.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(t)&&tt(t.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${t.length}).`),this.path=t,e.requestInit!=null&&e.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=e.requestInit||{}}async save(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");let e=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);e.body=new FormData;let n=[{paths:["./model.weights.bin"],weights:t.weightSpecs}],s={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:n};t.signature!=null&&(s.signature=t.signature),t.userDefinedMetadata!=null&&(s.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(s.modelInitializer=t.modelInitializer),e.body.append("model.json",new Blob([JSON.stringify(s)],{type:HO}),"model.json"),t.weightData!=null&&e.body.append("model.weights.bin",new Blob([t.weightData],{type:qO}),"model.weights.bin");let o=await this.fetch(this.path,e);if(o.ok)return{modelArtifactsInfo:Ks(t),responses:[o]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${o.status}.`)}async load(){let t=await this.fetch(this.path,this.requestInit);if(!t.ok)throw new Error(`Request to ${this.path} failed with status code ${t.status}. Please verify this URL points to the model JSON of the model to load.`);let e;try{e=await t.json()}catch(_){let v=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?v+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":v+=" Please make sure the server is serving valid JSON for this request.",new Error(v)}let n=e.modelTopology,s=e.weightsManifest,o=e.generatedBy,a=e.convertedBy,l=e.format,u=e.signature,p=e.userDefinedMetadata;if(n==null&&s==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);let f,m;s!=null&&([f,m]=await this.loadWeights(s));let d={modelTopology:n,weightSpecs:f,weightData:m,generatedBy:o,convertedBy:a,format:l};u!=null&&(d.signature=u),p!=null&&(d.userDefinedMetadata=p);let y=e.modelInitializer;return y&&(d.modelInitializer=y),d}async loadWeights(t){let e=Array.isArray(this.path)?this.path[1]:this.path,[n,s]=KO(e),o=this.weightPathPrefix||n,a=[];for(let f of t)a.push(...f.weights);let l=[],u=[];for(let f of t)for(let m of f.paths)this.weightUrlConverter!=null?u.push(this.weightUrlConverter(m)):l.push(o+m+s);this.weightUrlConverter&&l.push(...await Promise.all(u));let p=await _x(l,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,zu(p)]}};yh.URL_SCHEME_REGEX=/^https?:\/\//;function KO(r){let t=r.lastIndexOf("/"),e=r.lastIndexOf("?"),n=r.substring(0,t),s=e>t?r.substring(e):"";return[n+"/",s]}function _h(r){return r.match(yh.URL_SCHEME_REGEX)!=null}var gw=(r,t)=>{if(typeof fetch=="undefined"&&(t==null||t.fetchFunc==null))return null;{let e=!0;if(Array.isArray(r)?e=r.every(n=>_h(n)):e=_h(r),e)return bh(r,t)}return null};rr.registerSaveRouter(gw);rr.registerLoadRouter(gw);function bh(r,t){return new yh(r,t)}function xw(r,t){return bh(r,t)}var vh=class{constructor(t){this.modelArtifacts=t}async load(){return this.modelArtifacts}},yw=class{constructor(t){this.saveHandler=t}async save(t){return this.saveHandler(t)}};function _w(r,t,e,n){return arguments.length===1?r.modelTopology!=null||r.weightSpecs!=null?new vh(r):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new vh({modelTopology:r})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new vh({modelTopology:r,weightSpecs:t,weightData:e,trainingConfig:n}))}function bw(r){return new yw(r)}function XO(r,t,e=!1,n=!1){let s=X(r,"a","matMul"),o=X(t,"b","matMul");[s,o]=Ne(s,o);let a={a:s,b:o},l={transposeA:e,transposeB:n};return Y.runKernel(Ei,a,l)}var Ve=Q({matMul_:XO});function YO(r,t,e=1,n=0){if(t<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${t}`);let o={indices:X(r,"indices","oneHot","int32")},a={depth:t,onValue:e,offValue:n};return Y.runKernel(Qi,o,a)}var up=Q({oneHot_:YO});function ZO(r,t){let e=X(r,"x","transpose");if(t==null&&(t=e.shape.map((o,a)=>a).reverse()),tt(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of perm ${t}.`),t.forEach(o=>{tt(o>=0&&o<e.rank,()=>`All entries in 'perm' must be between 0 and ${e.rank-1} but got ${t}`)}),e.rank<=1)return e.clone();let n={x:e},s={perm:t};return Y.runKernel(ha,n,s)}var Le=Q({transpose_:ZO});var wh={};Yn(wh,{fromPixels:()=>tP,toPixels:()=>QO});function vw(r,t,e){if(Xa(r),t!=null&&t.length!==3)throw new Error("tensor3d() requires shape to have three numbers");let n=ti(r,e);if(n.length!==3&&n.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Hs(r,t,n,e)}var Vu;function JO(r,t=3){if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(r==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let e=!1,n=!1,s=!1,o=!1,a=!1,l=!1;if(r.data instanceof Uint8Array)e=!0;else if(typeof ImageData!="undefined"&&r instanceof ImageData)n=!0;else if(typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement)s=!0;else if(typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement)o=!0;else if(r.getContext!=null)a=!0;else if(typeof ImageBitmap!="undefined"&&r instanceof ImageBitmap)l=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${r.constructor.name}`);if(s){let _=2;if(s&&r.readyState<_)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(rp(ep,Y.backendName)!=null){let _={pixels:r},v={numChannels:t};return Y.runKernel(ep,_,v)}let[p,f]=s?[r.videoWidth,r.videoHeight]:[r.width,r.height],m;a?m=r.getContext("2d").getImageData(0,0,p,f).data:n||e?m=r.data:(o||s||l)&&(Vu==null&&(Vu=document.createElement("canvas").getContext("2d")),Vu.canvas.width=p,Vu.canvas.height=f,Vu.drawImage(r,0,0,p,f),m=Vu.getImageData(0,0,p,f).data);let d;if(t===4)d=new Int32Array(m);else{let _=p*f;d=new Int32Array(_*t);for(let v=0;v<_;v++)for(let C=0;C<t;++C)d[v*t+C]=m[v*4+C]}return vw(d,[f,p,t],"int32")}async function QO(r,t){let e=X(r,"img","toPixels");if(!(r instanceof Ae)){let p=e;e=Vt(p,"int32"),p.dispose()}if(e.rank!==2&&e.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${e.rank}.`);let[n,s]=e.shape.slice(0,2),o=e.rank===2?1:e.shape[2];if(o>4||o===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${o}`);if(e.dtype!=="float32"&&e.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${e.dtype}. Please use float32 or int32 tensors.`);let a=await e.data(),l=e.dtype==="float32"?255:1,u=new Uint8ClampedArray(s*n*4);for(let p=0;p<n*s;++p){let f=[0,0,0,255];for(let d=0;d<o;d++){let y=a[p*o+d];if(e.dtype==="float32"){if(y<0||y>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${y}.`)}else if(e.dtype==="int32"&&(y<0||y>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${y}.`);o===1?(f[0]=y*l,f[1]=y*l,f[2]=y*l):f[d]=y*l}let m=p*4;u[m+0]=Math.round(f[0]),u[m+1]=Math.round(f[1]),u[m+2]=Math.round(f[2]),u[m+3]=Math.round(f[3])}if(t!=null){t.width=s,t.height=n;let p=t.getContext("2d"),f=new ImageData(u,s,n);p.putImageData(f,0,0)}return e!==r&&e.dispose(),u}var tP=Q({fromPixels_:JO});function eP(r,t){let e=r.shape.length,n=t.shape.length;if(e<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${e}.`);if(n<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${n}.`);if(t.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.shape[n-1]>e)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${t.shape[n-1]} vs. ${e}`);if(Je(r.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${r.shape}.`);let s=t.shape,o=s[s.length-1],a=1;for(let m=0;m<s.length-1;++m)a*=s[m];let l=r.shape,u=s.slice();u.pop();let p=1;for(let m=o;m<e;++m)p*=l[m],u.push(l[m]);let f=[...Gs(r.shape).map(m=>m/p),1].slice(0,o);return[u,a,p,f]}function ww(r,t,e){let n=t.rank>1?t.shape[t.rank-1]:1,s=t.rank>1?t.rank-1:1,o=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${e.shape}, indices.shape: ${t.shape}, shape: ${r}, sliceDim: ${n}, and batchDim: ${s}.`;if(e.rank<s)throw new Error(o+` update.rank < ${s}. `);if(r.length<n+(e.rank-s))throw new Error(o+` Output shape length < ${n+(e.rank-s)}`);if(e.rank!==s+r.length-n)throw new Error(o+` update.rank != ${s+r.length-n}`);for(let a=0;a<s;++a)if(e.shape[a]!==t.shape[a])throw new Error(o+` updates.shape[${a}] (${e.shape[a]}) != indices.shape[${a}] (${t.shape[a]}).`);for(let a=0;a<e.rank-s;++a)if(e.shape[a+s]!==r[a+n])throw new Error(o+` updates.shape[${a+s}] (${e.shape[a+s]}) != shape[${a+s}] (${r[a+s]})`)}function rP(r,t,e){if(t.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${t.rank}.`);if(r.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${r.rank}.`);if(t.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${t.dtype}`);if(e.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${e}`);if(e.length===0){if(t.size===0)throw new Error(`Indices specified for empty output. indices shape: ${t.shape}`);if(r.size===0)throw new Error(`Updates specified for empty output. updates shape: ${r.shape}`)}ww(e,t,r)}function nP(r,t,e){let n=t.shape.length,s=n>1?t.shape[n-1]:1,o=e.length,a=1;for(let m=s;m<o;++m)a*=e[m];let l=s<1?1:s,u=Je(t.shape)/l,p=[...Gs(e.slice(0,s)),1],f=Je(e);return{sliceRank:s,numUpdates:u,sliceSize:a,strides:p,outputSize:f}}var pn={};Yn(pn,{assertParamsValid:()=>sP,computeFlatOffset:()=>iP,computeOutShape:()=>Cw,getNormalizedAxes:()=>Dw,isSliceContinous:()=>oP,maskToAxes:()=>Ch,parseSliceParams:()=>vx,sliceInfo:()=>aP,startForAxis:()=>Aw,startIndicesWithElidedDims:()=>Nw,stopForAxis:()=>$w,stopIndicesWithElidedDims:()=>Tw,stridesForAxis:()=>Ew,stridesWithElidedDims:()=>kw});function sP(r,t,e){let n=r.shape.length;tt(n===t.length,()=>`Error in slice${n}D: Length of begin ${t} must match the rank of the array (${n}).`),tt(n===e.length,()=>`Error in slice${n}D: Length of size ${e} must match the rank of the array (${n}).`);for(let s=0;s<n;++s)tt(t[s]+e[s]<=r.shape[s],()=>`Error in slice${n}D: begin[${s}] + size[${s}] (${t[s]+e[s]}) would overflow input.shape[${s}] (${r.shape[s]})`)}function Ch(r){let t=[],e=0;for(;r>0;)r&1&&t.push(e),r/=2,e++;return t}function Cw(r,t,e){let n=[];for(let s=0;s<r.length;s++)n[s]=Math.ceil((t[s]-r[s])/e[s]);return n}function kw(r,t,e,n){let s=[...r];for(let o=s.length;o<n.length;o++)s.push(1);for(let o=0;o<e;o++)o===0?s[t]=1:(s.splice(t,0,1),s.pop());return s}function Sw(r,t,e){return e<=r?e:e-(t-1)}function Iw(r,t){let e=[];for(let n=0;n<r;n++)e.push(t+n);return e}function Dw(r,t,e,n,s,o,a,l,u){let p=r.length,f=new Array(p),m=new Array(p),d=new Array(p);if(t.length&&e>0){let y=t[0],_=e+1;f=Nw(a,y,_,n,r),m=Tw(l,y,_,s,r),d=kw(o,y,_,r)}else for(let y=0;y<p;y++)f[y]=Aw(a,n,o,r,y,u),m[y]=$w(l,s,o,r,y,u),d[y]=Ew(o,y,u);return{begin:f,end:m,strides:d}}function Nw(r,t,e,n,s){let o=[...s],a=Iw(e,t);for(let l=0;l<o.length;l++)if(a.indexOf(l)>-1)o[l]=0;else{let u=Sw(t,e,l),p=n[u];r&1<<u&&(p=0),o[l]=p}return o}function Tw(r,t,e,n,s){let o=[...s],a=Iw(e,t);for(let l=0;l<o.length;l++)if(a.indexOf(l)>-1)o[l]=Number.MAX_SAFE_INTEGER;else{let u=Sw(t,e,l),p=n[u];r&1<<u&&(p=Number.MAX_SAFE_INTEGER),o[l]=p}for(let l=0;l<o.length;l++){let u=s[l];o[l]<0&&(o[l]+=u),o[l]=Zl(0,o[l],s[l])}return o}function Ew(r,t,e){let n=r[t];return(e&1<<t||n==null)&&(n=1),n}function Aw(r,t,e,n,s,o){let a=t[s],l=e[s]||1;(r&1<<s||o&1<<s||a==null)&&(l>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);let u=n[s];return a<0&&(a+=u),a=Zl(0,a,u-1),a}function $w(r,t,e,n,s,o){let a=t[s],l=e[s]||1;(r&1<<s||o&1<<s||a==null)&&(l>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);let u=n[s];return a<0&&(a+=u),l>0?a=Zl(0,a,u):a=Zl(-1,a,u-1),a}function oP(r,t,e){let n=e.length;for(let s=0;s<e.length;s++)if(e[s]>1){n=s;break}for(let s=n+1;s<e.length;s++)if(t[s]>0||e[s]!==r[s])return!1;return!0}function iP(r,t){let e=r.length>0?r[r.length-1]:1;for(let n=0;n<r.length-1;n++)e+=r[n]*t[n];return e}function vx(r,t,e){let n,s=r.shape.length;typeof t=="number"?n=[t,...new Array(s-1).fill(0)]:t.length<s?n=t.concat(new Array(s-t.length).fill(0)):n=t.slice(),n.forEach(a=>{tt(a!==-1,()=>"slice() does not support negative begin indexing.")});let o;return e==null?o=new Array(s).fill(-1):typeof e=="number"?o=[e,...new Array(s-1).fill(-1)]:e.length<s?o=e.concat(new Array(s-e.length).fill(-1)):o=e,o=o.map((a,l)=>a>=0?a:(tt(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${l}.`),r.shape[l]-n[l])),[n,o]}function aP(r,t,e,n,s,o,a,l,u){let p=t.slice(),f=e.slice(),m=n;n==null&&(m=new Array(p.length));let d=Ch(a);if(d.length>1)throw new Error("Multiple ellipses in slice is not allowed.");if(a!==0&&l!==0)throw new Error("Using both ellipsisMask and newAxisMask is not yet supported.");if(a!==0&&u!==0)throw new Error("Using both ellipsisMask and shrinkAxisMask is not yet supported.");let y=r.length-p.length,_=Ch(l),v=r.slice();_.forEach(K=>{p[K]=0,f[K]=1,v.splice(K,0,1)});let{begin:C,end:N,strides:A}=Dw(v,d,y,p,f,m,s,o,a);p=C,f=N,m=A;let B=Ch(u);B.forEach(K=>{f[K]=p[K]+1,m[K]=1});let P=Cw(p,f,m),L=P.filter((K,et)=>B.indexOf(et)===-1);return{nonStrided:m.every(K=>K===1),$begin:p,$end:f,$strides:m,size:P,newShape:v,outShape:L}}var At={};Yn(At,{Serializable:()=>kh,SerializationMap:()=>oi,registerClass:()=>yn});var kh=class{getClassName(){return this.constructor.className}static fromConfig(t,e){return new t(e)}},oi=class{constructor(){this.classNameMap={}}static getMap(){return oi.instance==null&&(oi.instance=new oi),oi.instance}static register(t){oi.getMap().classNameMap[t.className]=[t,t.fromConfig]}};function yn(r){tt(r.className!=null,()=>"Class being registered does not have the static className property defined."),tt(typeof r.className=="string",()=>"className is required to be a string, but got type "+typeof r.className),tt(r.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),oi.register(r)}function lP(r){vt().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(r+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}zv(lP);function _a(){return Y}function cp(){return Y.memory()}function _t(r,t){return Y.tidy(r,t)}function pe(r){ip(r).forEach(e=>e.dispose())}function Fr(r){return Y.keep(r)}function Sh(r,t,e=1){return Y.registerBackend(r,t,e)}function Rw(){return Y.backend}function uP(r,t){let e=X(r,"a","add"),n=X(t,"b","add");[e,n]=Ne(e,n);let s={a:e,b:n};return Y.runKernel(_s,s)}var Ot=Q({add_:uP});function cP(r,t){let e=X(r,"a","floorDiv"),n=X(t,"b","floorDiv");[e,n]=Ne(e,n);let s={a:e,b:n};return Y.runKernel(So,s)}var Ih=Q({floorDiv_:cP});function pP(r,t){let e=X(r,"a","div"),n=X(t,"b","div");if([e,n]=Ne(e,n),e.dtype==="int32"&&n.dtype==="int32")return Ih(e,n);let s={a:e,b:n},o={};return Y.runKernel(_o,s,o)}var Xt=Q({div_:pP});function fP(r,t){let e=X(r,"a","mul"),n=X(t,"b","mul");[e,n]=Ne(e,n);let s={a:e,b:n};return Y.runKernel(Oo,s)}var ft=Q({mul_:fP});function hP(r){let t=X(r,"x","abs");if(t.dtype==="complex64"){let e={x:t};return Y.runKernel($i,e)}else{let e={x:t};return Y.runKernel(ki,e)}}var Ar=Q({abs_:hP});function mP(r){let e={x:X(r,"x","acos")};return Y.runKernel(ao,e)}var Fw=Q({acos_:mP});function dP(r){let e={x:X(r,"x","acosh")};return Y.runKernel(lo,e)}var Ow=Q({acosh_:dP});function gP(r,t=null,e=!1){let s={x:X(r,"x","all","bool")},o={axis:t,keepDims:e};return Y.runKernel(ou,s,o)}var Nh=Q({all_:gP});function xP(r,t=null,e=!1){let s={x:X(r,"x","any","bool")},o={axis:t,keepDims:e};return Y.runKernel(iu,s,o)}var pp=Q({any_:xP});function yP(r,t=0){let n={x:X(r,"x","argMax")},s={axis:t};return Y.runKernel(Si,n,s)}var fp=Q({argMax_:yP});function _P(r,t=0){let n={x:X(r,"x","argMin")},s={axis:t};return Y.runKernel(Ii,n,s)}var Pw=Q({argMin_:_P});function bP(r){let e={x:X(r,"x","asin")};return Y.runKernel(uo,e)}var Lw=Q({asin_:bP});function vP(r){let e={x:X(r,"x","asinh")};return Y.runKernel(co,e)}var zw=Q({asinh_:vP});function wP(r){let e={x:X(r,"x","atan")};return Y.runKernel(po,e)}var Mw=Q({atan_:wP});function CP(r,t){let e=X(r,"a","atan2"),n=X(t,"b","atan2");[e,n]=Ne(e,n);let s={a:e,b:n};return Y.runKernel(ho,s)}var Bw=Q({atan2_:CP});function kP(r){let e={x:X(r,"x","atanh")};return Y.runKernel(fo,e)}var Vw=Q({atanh_:kP});function SP(r,t,e,n,s="NHWC",o){let a=r[3],l=[...t,a],u=Gw(s);return fl(r,l,e,o,n,null,null,u)}function wx(r,t,e,n,s,o,a="channelsLast"){let[l,u]=Th(t),p;if(a==="channelsLast")p=[l,u,r[3],r[3]];else if(a==="channelsFirst")p=[l,u,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return fl(r,p,e,n,s,o,!1,a)}function IP(r,t,e,n,s,o,a="NDHWC"){let[l,u,p]=Cx(t),f,m;if(a==="NDHWC")m="channelsLast",f=[l,u,p,r[4],r[4]];else if(a==="NCDHW")m="channelsFirst",f=[l,u,p,r[1],r[1]];else throw new Error(`Unknown dataFormat ${a}`);return Ww(r,f,e,n,s,!1,m,o)}function fl(r,t,e,n,s,o,a=!1,l="channelsLast"){let[u,p,f,m]=[-1,-1,-1,-1];if(l==="channelsLast")[u,p,f,m]=r;else if(l==="channelsFirst")[u,m,p,f]=r;else throw new Error(`Unknown dataFormat ${l}`);let[d,y,,_]=t,[v,C]=Th(e),[N,A]=Th(n),B=Gu(d,N),P=Gu(y,A),{padInfo:L,outHeight:Z,outWidth:K}=NP(s,p,f,v,C,B,P,o,l),et=a?_*m:_,it;return l==="channelsFirst"?it=[u,et,Z,K]:l==="channelsLast"&&(it=[u,Z,K,et]),{batchSize:u,dataFormat:l,inHeight:p,inWidth:f,inChannels:m,outHeight:Z,outWidth:K,outChannels:et,padInfo:L,strideHeight:v,strideWidth:C,filterHeight:d,filterWidth:y,effectiveFilterHeight:B,effectiveFilterWidth:P,dilationHeight:N,dilationWidth:A,inShape:r,outShape:it,filterShape:t}}function Ww(r,t,e,n,s,o=!1,a="channelsLast",l){let[u,p,f,m,d]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[u,p,f,m,d]=r;else if(a==="channelsFirst")[u,d,p,f,m]=r;else throw new Error(`Unknown dataFormat ${a}`);let[y,_,v,,C]=t,[N,A,B]=Cx(e),[P,L,Z]=Cx(n),K=Gu(y,P),et=Gu(_,L),it=Gu(v,Z),{padInfo:xt,outDepth:wt,outHeight:St,outWidth:yt}=TP(s,p,f,m,N,A,B,K,et,it,l),Nt=o?C*d:C,ht;return a==="channelsFirst"?ht=[u,Nt,wt,St,yt]:a==="channelsLast"&&(ht=[u,wt,St,yt,Nt]),{batchSize:u,dataFormat:a,inDepth:p,inHeight:f,inWidth:m,inChannels:d,outDepth:wt,outHeight:St,outWidth:yt,outChannels:Nt,padInfo:xt,strideDepth:N,strideHeight:A,strideWidth:B,filterDepth:y,filterHeight:_,filterWidth:v,effectiveFilterDepth:K,effectiveFilterHeight:et,effectiveFilterWidth:it,dilationDepth:P,dilationHeight:L,dilationWidth:Z,inShape:r,outShape:ht,filterShape:t}}function EP(r,t,e,n,s){n==null&&(n=kx(r,t,e));let o=r[0],a=r[1],l=hl((o-t+2*n)/e+1,s),u=hl((a-t+2*n)/e+1,s);return[l,u]}function AP(r,t,e,n,s,o){s==null&&(s=kx(r,t,n));let a=r[0],l=r[1],u=r[2],p=hl((a-t+2*s)/n+1,o),f=hl((l-t+2*s)/n+1,o),m=hl((u-t+2*s)/n+1,o);return[p,f,m,e]}function kx(r,t,e,n=1){let s=Gu(t,n);return Math.floor((r[0]*(e-1)-e+s)/2)}function Th(r){return typeof r=="number"?[r,r,r]:r.length===2?[r[0],r[1],1]:r}function Cx(r){return typeof r=="number"?[r,r,r]:r}function Gu(r,t){return t<=1?r:r+(r-1)*(t-1)}function NP(r,t,e,n,s,o,a,l,u){let p,f,m;if(typeof r=="number"){p={top:r,bottom:r,left:r,right:r,type:r===0?"VALID":"NUMBER"};let y=EP([t,e],o,n,r,l);f=y[0],m=y[1]}else if(r==="same"){f=Math.ceil(t/n),m=Math.ceil(e/s);let d=Math.max(0,(f-1)*n+o-t),y=Math.max(0,(m-1)*s+a-e),_=Math.floor(d/2),v=d-_,C=Math.floor(y/2),N=y-C;p={top:_,bottom:v,left:C,right:N,type:"SAME"}}else if(r==="valid")p={top:0,bottom:0,left:0,right:0,type:"VALID"},f=Math.ceil((t-o+1)/n),m=Math.ceil((e-a+1)/s);else if(typeof r=="object"){let d=u==="channelsLast"?r[1][0]:r[2][0],y=u==="channelsLast"?r[1][1]:r[2][1],_=u==="channelsLast"?r[2][0]:r[3][0],v=u==="channelsLast"?r[2][1]:r[3][1];p={top:d,bottom:y,left:_,right:v,type:d===0&&y===0&&_===0&&v===0?"VALID":"EXPLICIT"},f=hl((t-o+d+y)/n+1,l),m=hl((e-a+_+v)/s+1,l)}else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:p,outHeight:f,outWidth:m}}function TP(r,t,e,n,s,o,a,l,u,p,f){let m,d,y,_;if(typeof r=="number"){m={top:r,bottom:r,left:r,right:r,front:r,back:r,type:r===0?"VALID":"NUMBER"};let C=AP([t,e,n,1],l,1,s,r,f);d=C[0],y=C[1],_=C[2]}else if(r==="same"){d=Math.ceil(t/s),y=Math.ceil(e/o),_=Math.ceil(n/a);let v=(d-1)*s+l-t,C=(y-1)*o+u-e,N=(_-1)*a+p-n,A=Math.floor(v/2),B=v-A,P=Math.floor(C/2),L=C-P,Z=Math.floor(N/2),K=N-Z;m={top:P,bottom:L,left:Z,right:K,front:A,back:B,type:"SAME"}}else if(r==="valid")m={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-l+1)/s),y=Math.ceil((e-u+1)/o),_=Math.ceil((n-p+1)/a);else throw Error(`Unknown padding parameter: ${r}`);return{padInfo:m,outDepth:d,outHeight:y,outWidth:_}}function hl(r,t){if(!t)return Math.trunc(r);switch(t){case"round":return Math.round(r);case"ceil":return Math.ceil(r);case"floor":return Math.floor(r);default:throw new Error(`Unknown roundingMode ${t}`)}}function Mn(r){let[t,e,n]=Th(r);return t===1&&e===1&&n===1}function Vr(r,t){return Mn(r)||Mn(t)}function Gw(r){if(r==="NHWC")return"channelsLast";if(r==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${r}`)}function $P(r,t){let n={x:X(r,"x","reshape","string_or_numeric")},s={shape:t};return Y.runKernel(na,n,s)}var dt=Q({reshape_:$P});function DP(r,t,e,n,s){let o=X(r,"x","avgPool","float32"),a=1;tt(Vr(e,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`);let l=o,u=!1;o.rank===3&&(u=!0,l=dt(o,[1,o.shape[0],o.shape[1],o.shape[2]])),tt(l.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${l.rank}.`),s!=null&&tt(Be(n),()=>`Error in avgPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${n}.`);let p={x:l},f={filterSize:t,strides:e,pad:n,dimRoundingMode:s},m=Y.runKernel(Ni,p,f);return m=Vt(m,o.dtype),u?dt(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Wu=Q({avgPool_:DP});function RP(r,t,e,n,s,o="NDHWC"){let a=X(r,"x","avgPool3d","float32"),l=a,u=!1;a.rank===4&&(u=!0,l=dt(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),tt(l.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${l.rank}.`),tt(o==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&tt(Be(n),()=>`Error in avgPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${n}.`);let p={x:l},f={filterSize:t,strides:e,pad:n,dimRoundingMode:s,dataFormat:o},m=Y.runKernel(Ti,p,f);return m=Vt(m,l.dtype),u?dt(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var Uw=Q({avgPool3d_:RP});function FP(r,t=0){tt(r.length>=1,()=>"Pass at least one tensor to concat");let e=mh(r,"tensors","concat","string_or_numeric");if(e[0].dtype==="complex64"&&e.forEach(o=>{if(o.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${o.dtype}. `)}),e.length===1)return ws(e[0]);let n=e,s={axis:t};return Y.runKernel(Di,n,s)}var ar=Q({concat_:FP});function OP(r){let e={x:X(r,"x","sigmoid")};return Y.runKernel(qo,e)}var ii=Q({sigmoid_:OP});function PP(r,t,e){let n=X(r,"x","slice","string_or_numeric");if(n.rank===0)throw new Error("Slicing scalar is not possible");let s={x:n},o={begin:t,size:e};return Y.runKernel(la,s,o)}var ze=Q({slice_:PP});function LP(r){let e={x:X(r,"x","tanh")};return Y.runKernel(Jo,e)}var Eh=Q({tanh_:LP});function zP(r,t,e){let n=X(r,"x","batchToSpaceND"),s=t.reduce((l,u)=>l*u);tt(n.rank>=1+t.length,()=>`input rank is ${n.rank} but should be > than blockShape.length ${t.length}`),tt(e.length===t.length,()=>`crops.length is ${e.length} but should be equal to blockShape.length  ${t.length}`),tt(n.shape[0]%s==0,()=>`input tensor batch is ${n.shape[0]} but is not divisible by the product of the elements of blockShape ${t.join(" * ")} === ${s}`);let o={x:n},a={blockShape:t,crops:e};return Y.runKernel(Ai,o,a)}var Uu=Q({batchToSpaceND_:zP});function jw(r){let t;return r.rank===0||r.rank===1?t=dt(r,[1,1,1,r.size]):r.rank===2?t=dt(r,[1,1,r.shape[0],r.shape[1]]):r.rank===3?t=dt(r,[1,r.shape[0],r.shape[1],r.shape[2]]):t=r,t}function MP(r,t,e,n,s,o){o==null&&(o=.001);let a=X(r,"x","batchNorm"),l=X(t,"mean","batchNorm"),u=X(e,"variance","batchNorm"),p;s!=null&&(p=X(s,"scale","batchNorm"));let f;n!=null&&(f=X(n,"offset","batchNorm")),tt(l.rank===u.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),tt(f==null||l.rank===f.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),tt(p==null||l.rank===p.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let d={x:jw(a),scale:p,offset:f,mean:l,variance:u},y={varianceEpsilon:o},_=Y.runKernel(Bi,d,y);return dt(_,a.shape)}var ba=Q({batchNorm_:MP});function BP(r,t,e,n,s,o){let a=X(r,"x","batchNorm"),l=X(t,"mean","batchNorm"),u=X(e,"variance","batchNorm"),p;s!=null&&(p=X(s,"scale","batchNorm"));let f;return n!=null&&(f=X(n,"offset","batchNorm")),tt(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),tt(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${l.rank}.`),tt(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${u.rank}.`),p!=null&&tt(p.rank===2||p.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${p.rank}.`),f!=null&&tt(f.rank===2||f.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${f.rank}.`),ba(a,l,u,f,p,o)}var qw=Q({batchNorm2d_:BP});function VP(r,t,e,n,s,o){let a=X(r,"x","batchNorm"),l=X(t,"mean","batchNorm"),u=X(e,"variance","batchNorm"),p;s!=null&&(p=X(s,"scale","batchNorm"));let f;return n!=null&&(f=X(n,"offset","batchNorm")),tt(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),tt(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${l.rank}.`),tt(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${u.rank}.`),p!=null&&tt(p.rank===3||p.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${p.rank}.`),f!=null&&tt(f.rank===3||f.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${f.rank}.`),ba(a,l,u,f,p,o)}var Hw=Q({batchNorm3d_:VP});function GP(r,t,e,n,s,o){let a=X(r,"x","batchNorm"),l=X(t,"mean","batchNorm"),u=X(e,"variance","batchNorm"),p;s!=null&&(p=X(s,"scale","batchNorm"));let f;return n!=null&&(f=X(n,"offset","batchNorm")),tt(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),tt(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${l.rank}.`),tt(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${u.rank}.`),p!=null&&tt(p.rank===4||p.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${p.rank}.`),f!=null&&tt(f.rank===4||f.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${f.rank}.`),ba(a,l,u,f,p,o)}var Kw=Q({batchNorm4d_:GP});function WP(r,t){let e=X(r,"broadcastTo","x"),n=e.shape;if(t.some(p=>!(p>0)||p%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${t}].`);if(t.length<e.rank)throw new Error(`broadcastTo(): shape.length=${t.length} < input.rank=${e.rank}.`);if(t.length>e.rank){let p=e.shape.slice();for(;p.length<t.length;)p.unshift(1);e=dt(e,p)}let s=e.shape,o=Array.from(t);for(let p=t.length-1;p>=0;p--)if(s[p]===t[p])o[p]=1;else if(e.shape[p]!==1)throw new Error(`broadcastTo(): [${n}] cannot be broadcast to [${t}].`);if(o.map((p,f)=>p>1?f:-1).filter(p=>p>=0).length===0)return ws(e);let l={x:e},u={reps:o};return Y.runKernel(Us,l,u)}var hp=Q({broadcastTo_:WP});function UP(r){let e={x:X(r,"x","ceil")};return Y.runKernel(mo,e)}var Xw=Q({ceil_:UP});function jP(r,t,e){let n=X(r,"x","clipByValue");tt(t<=e,()=>`Error in clip: min (${t}) must be less than or equal to max (${e}).`);let s={x:n},o={clipValueMin:t,clipValueMax:e};return Y.runKernel(go,s,o)}var Hr=Q({clipByValue_:jP});function qP(r){return ar(r,0)}var Yw=Q({concat1d_:qP});function HP(r,t){return ar(r,t)}var Zw=Q({concat2d_:HP});function KP(r,t){return ar(r,t)}var Jw=Q({concat3d_:KP});function XP(r,t){return ar(r,t)}var Qw=Q({concat4d_:XP});function YP(r,t,e,n,s="NHWC",o=[1,1],a){let l=X(r,"x","conv2d"),u=X(t,"filter","conv2d"),p=l,f=!1;l.rank===3&&(f=!0,p=dt(l,[1,l.shape[0],l.shape[1],l.shape[2]])),tt(p.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${p.rank}.`),tt(u.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${u.rank}.`),a!=null&&tt(Be(n),()=>`Error in conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`);let m=s==="NHWC"?p.shape[3]:p.shape[1];tt(m===u.shape[2],()=>`Error in conv2d: depth of input (${m}) must match input depth for filter ${u.shape[2]}.`),tt(Vr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`);let d={x:p,filter:u},y={strides:e,pad:n,dataFormat:s,dilations:o,dimRoundingMode:a},_=Y.runKernel(Ri,d,y);return f?dt(_,[_.shape[1],_.shape[2],_.shape[3]]):_}var Bn=Q({conv2d_:YP});function ZP(r,t,e,n,s="NWC",o=1,a){let l=X(r,"x","conv1d"),u=X(t,"filter","conv1d"),p=l,f=!1;l.rank===2&&(f=!0,p=dt(l,[1,l.shape[0],l.shape[1]])),tt(p.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${p.rank}.`),tt(u.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${u.rank}.`),a!=null&&tt(Be(n),()=>`Error in conv1d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`),tt(p.shape[2]===u.shape[1],()=>`Error in conv1d: depth of input (${p.shape[2]}) must match input depth for filter ${u.shape[1]}.`),tt(Vr(e,o),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${e} and dilation '${o}'`),tt(s==="NWC",()=>`Error in conv1d: got dataFormat of ${s} but only NWC is currently supported.`);let m=dt(u,[1,u.shape[0],u.shape[1],u.shape[2]]),d=dt(p,[p.shape[0],1,p.shape[1],p.shape[2]]),C=Bn(d,m,[1,e],n,"NHWC",[1,o],a);return f?dt(C,[C.shape[2],C.shape[3]]):dt(C,[C.shape[0],C.shape[2],C.shape[3]])}var Ah=Q({conv1d_:ZP});function JP(r,t,e,n,s,o="NHWC",a){tt(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let l=r,u=t,p=!1;t.rank===3&&(p=!0,u=dt(t,[1,t.shape[0],t.shape[1],t.shape[2]]),l=[1,r[0],r[1],r[2]]),tt(l.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${l.length}.`),tt(u.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${u.rank}`),tt(e.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${e.rank}`);let f=o==="NHWC"?l[3]:l[1],m=o==="NHWC"?u.shape[3]:u.shape[1];tt(f===e.shape[2],()=>`Error in conv2dDerInput: depth of input (${f}) must match input depth for filter ${e.shape[2]}.`),tt(m===e.shape[3],()=>`Error in conv2dDerInput: depth of output (${m}) must match output depth for filter ${e.shape[3]}.`),a!=null&&tt(Be(s),()=>`Error in conv2dDerInput: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let d={dy:u,filter:e},y={strides:n,pad:s,dataFormat:o,dimRoundingMode:a,inputShape:l},_=Y.runKernel(Fi,d,y);return p?dt(_,[_.shape[1],_.shape[2],_.shape[3]]):_}var ju=Q({conv2DBackpropInput_:JP});function QP(r,t,e,n,s,o){let a=X(r,"x","conv2dTranspose"),l=X(t,"filter","conv2dTranspose");return ju(e,a,l,n,s,"NHWC",o)}var $h=Q({conv2dTranspose_:QP});function tL(r,t,e,n,s="NDHWC",o=[1,1,1]){let a=X(r,"x","conv3d"),l=X(t,"filter","conv3d"),u=a,p=!1;a.rank===4&&(p=!0,u=dt(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),tt(u.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${u.rank}.`),tt(l.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${l.rank}.`),tt(u.shape[4]===l.shape[3],()=>`Error in conv3d: depth of input (${u.shape[4]}) must match input depth for filter ${l.shape[3]}.`),tt(Vr(e,o),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),tt(s==="NDHWC",()=>`Error in conv3d: got dataFormat of ${s} but only NDHWC is currently supported.`);let f={x:u,filter:l},m={strides:e,pad:n,dataFormat:s,dilations:o},d=Y.runKernel(Oi,f,m);return p?dt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var tC=Q({conv3d_:tL});function eL(r,t,e,n,s){tt(r.length===t.rank,()=>`Length of inShape (${r.length}) and rank of dy (${t.rank}) must match`);let o=r,a=t,l=!1;t.rank===4&&(l=!0,a=dt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),o=[1,r[0],r[1],r[2],r[3]]);let u=o[4],p=a.shape[4];tt(o.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${o.length}.`),tt(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),tt(e.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${e.rank}`),tt(u===e.shape[3],()=>`Error in conv3dDerInput: depth of input (${u}) must match input depth for filter ${e.shape[3]}.`),tt(p===e.shape[4],()=>`Error in conv3dDerInput: depth of output (${p}) must match output depth for filter ${e.shape[4]}.`);let f={dy:a,filter:e},m={pad:s,strides:n,inputShape:o},d=Y.runKernel(fu,f,m);return l?dt(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}var eC=Q({conv3DBackpropInput_:eL});function rL(r){let e={x:X(r,"x","cos")};return Y.runKernel(xo,e)}var qu=Q({cos_:rL});function nL(r){let e={x:X(r,"x","cosh")};return Y.runKernel(yo,e)}var Dh=Q({cosh_:nL});function sL(r,t=0,e=!1,n=!1){let o={x:X(r,"x","cumsum")},a={axis:t,exclusive:e,reverse:n};return Y.runKernel(Pi,o,a)}var Rh=Q({cumsum_:sL});function oL(r,t,e="NHWC"){let n=X(r,"x","depthToSpace"),s=e==="NHWC"?n.shape[1]:n.shape[2],o=e==="NHWC"?n.shape[2]:n.shape[3],a=e==="NHWC"?n.shape[3]:n.shape[1];tt(s*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${t}  for depthToSpace with input shape
    ${n.shape}`),tt(o*t>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${o} and ${t} for depthToSpace with input shape
        ${n.shape}`),tt(a%(t*t)==0,()=>`Dimension size must be evenly divisible by ${t*t} but is ${a} for depthToSpace with input shape ${n.shape}`);let l={x:n},u={blockSize:t,dataFormat:e};return Y.runKernel(hu,l,u)}var rC=Q({depthToSpace_:oL});function iL(r,t,e,n,s="NHWC",o=[1,1],a){let l=X(r,"x","depthwiseConv2d"),u=X(t,"filter","depthwiseConv2d"),p=l,f=!1;l.rank===3&&(f=!0,p=dt(l,[1,l.shape[0],l.shape[1],l.shape[2]])),tt(p.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),tt(u.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${u.rank}.`),tt(p.shape[3]===u.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${u.shape[2]}.`),a!=null&&tt(Be(n),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`);let m={x:p,filter:u},d={strides:e,pad:n,dataFormat:s,dilations:o,dimRoundingMode:a},y=Y.runKernel(Li,m,d);return f?dt(y,[y.shape[1],y.shape[2],y.shape[3]]):y}var va=Q({depthwiseConv2d_:iL});function aL(r,t,e,n,s=[1,1],o="NHWC"){let a=X(r,"x","dilation2d"),l=X(t,"filter","dilation2d");tt(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),tt(l.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${l.rank}.`),tt(o==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${o}`);let u=a,p=!1;a.rank===3&&(u=dt(a,[1,a.shape[0],a.shape[1],a.shape[2]]),p=!0);let f={x:u,filter:l},m={strides:e,pad:n,dilations:s},d=Y.runKernel(zi,f,m);return p?dt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var nC=Q({dilation2d_:aL});function lL(r,t){let e=r.length,n=[];for(let s=0;s<e;s++){let o=e-1-s,a=r[o]||1;(t[t.length-1-s]||1)>1&&a===1&&n.unshift(o)}return n}function Qe(r,t){let e=[];for(let n=0;n<t.length;n++){let s=r[r.length-n-1],o=t.length-n-1,a=t[o];(s==null||s===1&&a>1)&&e.unshift(o)}return e}function ve(r,t){let e=[],n=Math.max(r.length,t.length);for(let s=0;s<n;s++){let o=r[r.length-s-1];o==null&&(o=1);let a=t[t.length-s-1];if(a==null&&(a=1),o===1)e.unshift(a);else if(a===1)e.unshift(o);else if(o!==a){let l=`Operands could not be broadcast together with shapes ${r} and ${t}.`;throw Error(l)}else e.unshift(o)}return e}function uL(r,t){let e=X(r,"a","equal"),n=X(t,"b","equal");[e,n]=Ne(e,n),ve(e.shape,n.shape);let s={a:e,b:n};return Y.runKernel(Ja,s)}var ks=Q({equal_:uL});function cL(r,t,e){let n=X(t,"a","where"),s=X(e,"b","where"),o=X(r,"condition","where","bool"),a=ve(n.shape,s.shape),l=hp(n,a),u=hp(s,a);o.rank===1&&tt(o.shape[0]===n.shape[0],()=>"The first dimension of `a` must match the size of `condition`."),o.rank!==1&&Jl(o.shape,u.shape,"Error in where: ");let p={condition:o,t:l,e:u};return Y.runKernel(aa,p)}var Cr=Q({where_:cL});function pL(r){let e={x:X(r,"x","zerosLike")};return Y.runKernel(ga,e)}var le=Q({zerosLike_:pL});function fL(r,t){let e=X(r,"a","div"),n=X(t,"b","div");[e,n]=Ne(e,n);let s=Xt(e,n),o=le(s),a=ks(n,o);return Cr(a,o,s)}var sC=Q({divNoNan_:fL});function hL(r,t){let e=X(r,"t1","dot"),n=X(t,"t2","dot");tt((e.rank===1||e.rank===2)&&(n.rank===1||n.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${e.rank} and ${n.rank}.`);let s=e.rank===1?e.size:e.shape[1],o=n.rank===1?n.size:n.shape[0];if(tt(s===o,()=>`Error in dot: inner dimensions of inputs must match, but got ${s} and ${o}.`),e.rank===1&&n.rank===1){let a=dt(e,[1,-1]),l=dt(n,[-1,1]),u=Ve(a,l);return dt(u,[])}else if(e.rank===1&&n.rank===2){let a=dt(e,[1,-1]),l=dt(n,[n.shape[0],n.shape[1]]),u=Ve(a,l);return dt(u,[u.size])}else if(e.rank===2&&n.rank===1){let a=dt(n,[-1,1]),l=Ve(e,a);return dt(l,[l.size])}else{let a=dt(n,[n.shape[0],n.shape[1]]);return Ve(e,a)}}var oC=Q({dot_:hL});function mL(r){let e={x:X(r,"x","elu")};return Y.runKernel(bo,e)}var wa=Q({elu_:mL});function dL(r){let t=X(r,"x","erf");tt(t.dtype==="int32"||t.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),t.dtype==="int32"&&(t=Vt(t,"float32"));let e={x:t};return Y.runKernel(vo,e)}var iC=Q({erf_:dL});function gL(r){let e={x:X(r,"x","exp")};return Y.runKernel(wo,e)}var _n=Q({exp_:gL});function xL(r,t=0){let e=X(r,"x","expandDims","string_or_numeric");tt(t<=e.rank,()=>"Axis must be <= rank of the tensor");let n={input:e},s={dim:t};return Y.runKernel(Mi,n,s)}var nn=Q({expandDims_:xL});function yL(r){let e={x:X(r,"x","expm1")};return Y.runKernel(Co,e)}var aC=Q({expm1_:yL});function _L(r,t){let e=X(r,"x","tile","string_or_numeric");tt(e.rank===t.length,()=>`Error in transpose: rank of input ${e.rank} must match length of reps ${t}.`);let n={x:e},s={reps:t};return Y.runKernel(Us,n,s)}var Xs=Q({tile_:_L});function bL(r,t,e,n="float32"){t==null&&(t=r);let s=ae([r,t],n),o=r<=t?r:t;for(let l=0;l<o;++l)s.set(1,l,l);let a=dt(s.toTensor(),[r,t]);if(e==null)return a;if(e.length===1)return Xs(nn(a,0),[e[0],1,1]);if(e.length===2)return Xs(nn(nn(a,0),0),[e[0],e[1],1,1]);if(e.length===3)return Xs(nn(nn(nn(a,0),0),0),[e[0],e[1],e[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${e.length}D.`)}var mp=Q({eye_:bL});function Fh(r,t,e){let n={shape:r,value:t,dtype:e};return Y.runKernel(yu,{},n)}function vL(r){let e={x:X(r,"x","floor")};return Y.runKernel(ko,e)}var Ca=Q({floor_:vL});function wL(r,t,e=0,n=0){let s=X(r,"x","gather"),o=X(t,"indices","gather","int32"),a={x:s,indices:o},l={axis:e,batchDims:n};return Y.runKernel(Vi,a,l)}var Hu=Q({gather_:wL});function CL(r,t){let e=X(r,"a","greater"),n=X(t,"b","greater");[e,n]=Ne(e,n),ve(e.shape,n.shape);let s={a:e,b:n};return Y.runKernel(Qa,s)}var Kr=Q({greater_:CL});function kL(r,t){let e=X(r,"a","greaterEqual"),n=X(t,"b","greaterEqual");[e,n]=Ne(e,n),ve(e.shape,n.shape);let s={a:e,b:n};return Y.runKernel(Io,s)}var Zn=Q({greaterEqual_:kL});function SL(r){let e={input:X(r,"input","imag")};return Y.runKernel(bu,e)}var Oh=Q({imag_:SL});function IL(r){let e={x:X(r,"x","isFinite")};return Y.runKernel(No,e)}var lC=Q({isFinite_:IL});function NL(r){let e={x:X(r,"x","isInf")};return Y.runKernel(To,e)}var uC=Q({isInf_:NL});function TL(r){let e={x:X(r,"x","isNaN")};return Y.runKernel(Eo,e)}var cC=Q({isNaN_:TL});function EL(r,t=.2){let n={x:X(r,"x","leakyRelu")},s={alpha:t};return Y.runKernel(Wi,n,s)}var Ku=Q({leakyRelu_:EL});function AL(r,t){let e=X(r,"a","less"),n=X(t,"b","less");[e,n]=Ne(e,n),ve(e.shape,n.shape);let s={a:e,b:n};return Y.runKernel(tl,s)}var Ph=Q({less_:AL});function $L(r,t){let e=X(r,"a","lessEqual"),n=X(t,"b","lessEqual");[e,n]=Ne(e,n),ve(e.shape,n.shape);let s={a:e,b:n};return Y.runKernel(el,s)}var Ys=Q({lessEqual_:$L});function DL(r,t=5,e=1,n=1,s=.5){let o=X(r,"x","localResponseNormalization");tt(o.rank===4||o.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${o.rank}.`),tt(Be(t),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${t}.`);let a=o,l=!1;o.rank===3&&(l=!0,a=dt(o,[1,o.shape[0],o.shape[1],o.shape[2]]));let u={x:a},p={depthRadius:t,bias:e,alpha:n,beta:s},f=Y.runKernel(Ui,u,p);return l?dt(f,[f.shape[1],f.shape[2],f.shape[3]]):f}var pC=Q({localResponseNormalization_:DL});function RL(r){let e={x:X(r,"x","log")};return Y.runKernel(Ao,e)}var bn=Q({log_:RL});function FL(r){let e={x:X(r,"x","log1p")};return Y.runKernel($o,e)}var fC=Q({log1p_:FL});function Sx(r,t){tt(eu(r),()=>"The f passed in variableGrads(f) must be a function"),tt(t==null||Array.isArray(t)&&t.every(p=>p instanceof ul),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");let e=t!=null;if(!e){t=[];for(let p in Y.registeredVariables)t.push(Y.registeredVariables[p])}let n=e?t.filter(p=>!p.trainable):null,s=t.length;t=t.filter(p=>p.trainable),tt(t.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${s} variables is trainable.`);let o=!0,{value:a,grads:l}=Y.gradients(r,t,null,o);tt(l.some(p=>p!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),tt(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);let u={};return t.forEach((p,f)=>{l[f]!=null&&(u[p.name]=l[f])}),n!=null&&n.forEach(p=>u[p.name]=null),{value:a,grads:u}}function Vn(r){return Y.customGrad(r)}function OL(r){let e={x:X(r,"x","neg")};return Y.runKernel(Zi,e)}var je=Q({neg_:OL});function PL(r){let e={x:X(r,"x","softplus")};return Y.runKernel(Ho,e)}var ka=Q({softplus_:PL});function LL(r){let t=X(r,"x","logSigmoid");return Vn(n=>({value:je(ka(je(n))),gradFunc:a=>ft(a,ii(je(n)))}))(t)}var hC=Q({logSigmoid_:LL});function zL(r,t=null,e=!1){let s={x:X(r,"x","max")},o={reductionIndices:t,keepDims:e};return Y.runKernel(ji,s,o)}var Xr=Q({max_:zL});function ML(r,t){let e=X(r,"a","sub"),n=X(t,"b","sub");[e,n]=Ne(e,n);let s={a:e,b:n};return Y.runKernel(Yo,s)}var ie=Q({sub_:ML});function BL(r,t=null,e=!1){let n=X(r,"x","sum");n.dtype==="bool"&&(n=Vt(n,"int32"));let s={x:n},o={axis:t,keepDims:e};return Y.runKernel(ua,s,o)}var ee=Q({sum_:BL});function VL(r,t=-1){let e=X(r,"logits","logSoftmax");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and axis was ${t}`);return Vn((s,o)=>{let a=!0,l=Xr(s,t,!0),u=ie(s,l),p=ie(Vt(u,"float32"),bn(ee(_n(u),t,a)));return o([p]),{value:p,gradFunc:(m,d)=>{let[y]=d,_=!0,v=_n(y);return ie(m,ft(ee(m,t,_),v))}}})(e)}var Lh=Q({logSoftmax_:VL});function Ix(r,t){for(let e=0;e<r.length;++e)if(r[r.length-e-1]!==t-1-e)return!1;return!0}function mC(r,t,e){let n=r.length+t.length,s=[],o=0,a=0;for(let l=0;l<n;l++)e.indexOf(l)===-1?s.push(r[o++]):s.push(t[a++]);return s}function Nx(r,t){let e=[],n=r.length;for(let o=0;o<n;o++)t.indexOf(o)===-1&&e.push(r[o]);let s=t.map(o=>r[o]);return[e,s]}function Zs(r,t){let e=t.map(n=>1);return mC(r,e,t)}function GL(r,t,e){tt(Ix(t,e),()=>`${r} supports only inner-most axes for now. Got axes ${t} and rank-${e} input.`)}function Tx(r,t){if(Ix(r,t))return null;let e=[];for(let n=0;n<t;++n)r.indexOf(n)===-1&&e.push(n);return r.forEach(n=>e.push(n)),e}function dp(r){return r.map((t,e)=>[e,t]).sort((t,e)=>t[1]-e[1]).map(t=>t[0])}function WL(r,t){let e=[];for(let n=t-r;n<t;++n)e.push(n);return e}function UL(r,t=null,e=!1){let n=X(r,"x","logSumExp"),s=Ir(t,n.shape),o=Xr(n,s,!0),a=ie(n,o),l=_n(a),u=ee(l,s),p=bn(u),f=Ot(dt(o,p.shape),p);if(e){let m=Zs(f.shape,s);return dt(f,m)}return f}var dC=Q({logSumExp_:UL});function jL(r,t){let e=X(r,"a","logicalAnd","bool"),n=X(t,"b","logicalAnd","bool");ve(e.shape,n.shape);let s={a:e,b:n};return Y.runKernel(rl,s)}var fn=Q({logicalAnd_:jL});function qL(r){let e={x:X(r,"x","logicalNot","bool")};return Y.runKernel(nl,e)}var Xu=Q({logicalNot_:qL});function HL(r,t){let e=X(r,"a","logicalOr","bool"),n=X(t,"b","logicalOr","bool");ve(e.shape,n.shape);let s={a:e,b:n};return Y.runKernel(sl,s)}var zh=Q({logicalOr_:HL});function KL(r,t){let e=X(r,"a","logicalXor","bool"),n=X(t,"b","logicalXor","bool");return ve(e.shape,n.shape),fn(zh(r,t),Xu(fn(r,t)))}var gC=Q({logicalXor_:KL});function XL(r,t,e,n,s){let o=X(r,"x","maxPool"),a=1,l=o,u=!1;o.rank===3&&(u=!0,l=dt(o,[1,o.shape[0],o.shape[1],o.shape[2]])),tt(l.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${l.rank}.`),tt(Vr(e,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${e} and dilations '${a}'`),s!=null&&tt(Be(n),()=>`Error in maxPool: pad must be an integer when using, dimRoundingMode ${s} but got pad ${n}.`);let p={x:l},f={filterSize:t,strides:e,pad:n,dimRoundingMode:s},m=Y.runKernel(qi,p,f);return u?dt(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Yu=Q({maxPool_:XL});function YL(r,t=[1,1,1],e,n,s,o="NDHWC"){let a=X(r,"x","maxPool3d"),l=a,u=!1;a.rank===4&&(u=!0,l=dt(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),tt(l.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${l.rank}.`),tt(o==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${o}`),s!=null&&tt(Be(n),()=>`Error in maxPool3d: pad must be an integer when using, dimRoundingMode ${s} but got pad ${n}.`);let p={x:l},f={filterSize:t,strides:e,pad:n,dimRoundingMode:s,dataFormat:o},m=Y.runKernel(Hi,p,f);return u?dt(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}var xC=Q({maxPool3d_:YL});function ZL(r,t){let e=X(r,"a","maximum"),n=X(t,"b","maximum");[e,n]=Ne(e,n),e.dtype==="bool"&&(e=Vt(e,"int32"),n=Vt(n,"int32")),ve(e.shape,n.shape);let s={a:e,b:n};return Y.runKernel(Do,s)}var Gn=Q({maximum_:ZL});function JL(r,t=null,e=!1){let s={x:X(r,"x","mean")},o={axis:t,keepDims:e};return Y.runKernel(Ki,s,o)}var hr=Q({mean_:JL});function QL(r,t=null,e=!1){let s={x:X(r,"x","min")},o={axis:t,keepDims:e};return Y.runKernel(Xi,s,o)}var ml=Q({min_:QL});function tz(r,t){let e=X(r,"a","minimum"),n=X(t,"b","minimum");[e,n]=Ne(e,n),e.dtype==="bool"&&(e=Vt(e,"int32"),n=Vt(n,"int32")),ve(e.shape,n.shape);let s={a:e,b:n};return Y.runKernel(Ro,s)}var Zu=Q({minimum_:tz});function ez(r,t,e){tt(e==="reflect"||e==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${e}.`);let n=X(r,"x","mirrorPad");if(n.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");tt(t.length===n.rank,()=>`Padding doesn't match input. Must be ${n.rank}. Got ${t.length}.`);let s=e==="reflect"?1:0;for(let l=0;l<n.rank;l++)tt(t[l].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),tt(t[l][0]>=0&&t[l][0]<=n.shape[l]-s&&t[l][1]>=0&&t[l][1]<=n.shape[l]-s,()=>`Padding in dimension ${l} cannot be greater than or equal to ${n.shape[l]-s} or less than 0 for input of shape ${n.shape}`);let o={paddings:t,mode:e},a={x:n};return Y.runKernel(Yi,a,o)}var yC=Q({mirrorPad_:ez});function rz(r,t){let e=X(r,"a","mod"),n=X(t,"b","mod");[e,n]=Ne(e,n);let s={a:e,b:n};return Y.runKernel(Fo,s)}var _C=Q({mod_:rz});function nz(r){let t=X(r,"x","square"),e={};return Y.runKernel("Square",{x:t},e)}var Te=Q({square_:nz});function sz(r,t=null,e=!1){r=X(r,"x","moments");let n=Ir(t,r.shape),s=hr(r,n,e),o=s.shape;e||(o=Zs(s.shape,n));let a=Te(ie(Vt(r,"float32"),dt(s,o))),l=hr(a,n,e);return{mean:s,variance:l}}var gp=Q({moments_:sz});function oz(r,t){let e=X(r,"a","notEqual"),n=X(t,"b","notEqual");[e,n]=Ne(e,n),ve(e.shape,n.shape);let s={a:e,b:n};return Y.runKernel(ol,s)}var dl=Q({notEqual_:oz});function lr(r,t="float32"){if(t==="complex64"){let n=lr(r,"float32"),s=lr(r,"float32");return vs(n,s)}let e=nu(Je(r),t);return Y.makeTensor(e,r,t)}function Wn(r,t="float32"){if(t==="complex64"){let n=Wn(r,"float32"),s=lr(r,"float32");return vs(n,s)}let e=Xc(Je(r),t);return Y.makeTensor(e,r,t)}function iz(r){let e={x:X(r,"x","onesLike")};return Y.runKernel(Ji,e)}var Gr=Q({onesLike_:iz});function az(r,t,e=0){let n=X(r,"x","pad");if(n.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");let s={paddings:t,constantValue:e},o={x:n};return Y.runKernel(ea,o,s)}var Ju=Q({pad_:az});function lz(r,t,e){let n=X(r,"x","spaceToBatchND");tt(n.rank>=1+t.length,()=>`input rank ${n.rank} should be > than [blockShape] ${t.length}`),tt(e.length===t.length,()=>`paddings.shape[0] ${e.length} must be equal to [blockShape] ${t.length}`),tt(n.shape.reduce((a,l,u)=>u>0&&u<=t.length?a&&(l+e[u-1][0]+e[u-1][1])%t[u-1]==0:a,!0),()=>`input spatial dimensions ${n.shape.slice(1)} with paddings ${e.toString()} must be divisible by blockShapes ${t.toString()}`);let s={x:n},o={blockShape:t,paddings:e};return Y.runKernel(ca,s,o)}var Qu=Q({spaceToBatchND_:lz});function pz(r,t,e,n,s,o){s==null&&(s=[1,1]),o==null&&(o=1),n===0&&(n="valid");let a=X(r,"x","maxPool"),l=a,u=!1;a.rank===3&&(u=!0,l=dt(a,[1,a.shape[0],a.shape[1],a.shape[2]])),tt(Vr(o,s),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${o} and dilations '${s}'`);let p=wx(l.shape,t,o,s,n),f=[p.dilationHeight,p.dilationWidth],m;n==="same"?m=cz([p.filterHeight,p.filterWidth],f):m=[[0,0],[0,0]];let d=f[0]===1&&f[1]===1,[y,_]=uz([p.inHeight,p.inWidth],f,m),v=d?n:"valid",C=d?l:Qu(l,f,y),A=(e==="avg"?()=>Wu(C,t,o,v):()=>Yu(C,t,o,v))(),B=d?A:Uu(A,f,_);return u?dt(B,[B.shape[1],B.shape[2],B.shape[3]]):B}function uz(r,t,e){let n=e.map(f=>f[0]),s=e.map(f=>f[1]),o=r.concat(n,s),a=t.map((f,m)=>(f-o[m]%f)%f),l=s.map((f,m)=>f+a[m]),u=t.map((f,m)=>[n[m],l[m]]),p=t.map((f,m)=>[0,a[m]]);return[u,p]}function cz(r,t){let n=r.map((a,l)=>a+(a-1)*(t[l]-1)).map(a=>a-1),s=n.map(a=>Math.floor(a/2)),o=n.map((a,l)=>a-s[l]);return n.map((a,l)=>[s[l],o[l]])}var bC=Q({pool_:pz});function fz(r,t){let e=X(r,"base","pow"),n=X(t,"exp","pow");[e,n]=Ne(e,n);let s={a:e,b:n};return Y.runKernel(Po,s)}var Jn=Q({pow_:fz});function hz(r,t){let e=X(r,"x","prelu"),n=X(t,"alpha","prelu"),s={x:e,alpha:n};return Y.runKernel(ra,s)}var tc=Q({prelu_:hz});function mz(r,t=null,e=!1){let n=X(r,"x","prod");n.dtype==="bool"&&(n=Vt(n,"int32"));let s={x:n},o={axis:t,keepDims:e};return Y.runKernel(ku,s,o)}var vC=Q({prod_:mz});var Ox=Wc(xp());var yp=class{constructor(t,e,n,s,o){this.mean=t,this.stdDev=e,this.dtype=n,this.nextVal=NaN,this.truncated=s,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);let a=o||Math.random();this.random=Ox.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){let s=this.nextVal;return this.nextVal=NaN,s}let t,e,n=!1;for(;!n;){let s,o,a;do s=2*this.random()-1,o=2*this.random()-1,a=s*s+o*o;while(a>=1||a===0);let l=Math.sqrt(-2*Math.log(a)/a);t=this.mean+this.stdDev*s*l,e=this.mean+this.stdDev*o*l,(!this.truncated||this.isValidTruncated(t))&&(n=!0)}return(!this.truncated||this.isValidTruncated(e))&&(this.nextVal=this.convertValue(e)),this.convertValue(t)}convertValue(t){return this.dtype==null||this.dtype==="float32"?t:Math.round(t)}isValidTruncated(t){return t<=this.upper&&t>=this.lower}};var Px=class{constructor(t=0,e=1,n,s){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=t,this.range=e-t,this.dtype=n,s==null&&(s=Math.random()),typeof s=="number"&&(s=s.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${t} - ${e} <= 1 and dtype is not float`);this.random=Ox.alea(s)}convertValue(t){return this.canReturnFloat()?t:Math.round(t)}nextValue(){return this.convertValue(this.min+this.range*this.random())}};function vz(r,t=0,e=1,n,s){if(n!=null&&n==="bool")throw new Error(`Unsupported data type ${n}`);let o=new yp(t,e,n,!1,s),a=ae(r,n);for(let l=0;l<a.values.length;l++)a.values[l]=o.nextValue();return a.toTensor()}var Lx=Q({randomNormal_:vz});function wz(r,t=0,e=1,n="float32",s){let o=ae(r,n),a=new Px(t,e,null,s);for(let l=0;l<o.values.length;l++)o.values[l]=a.nextValue();return o.toTensor()}var Sa=Q({randomUniform_:wz});function zx(r,t,e=1,n="float32"){if(e===0)throw new Error("Cannot have a step of zero");let s={start:r,stop:t,step:e,dtype:n};return Y.runKernel(Su,{},s)}function Cz(r){let e={input:X(r,"input","real")};return Y.runKernel(Iu,e)}var _p=Q({real_:Cz});function kz(r){let e={x:X(r,"x","reciprocal")};return Y.runKernel(Lo,e)}var LC=Q({reciprocal_:kz});function Sz(r){let e={x:X(r,"x","relu")};return Y.runKernel(zo,e)}var Ss=Q({relu_:Sz});function Iz(r){let e={x:X(r,"x","relu6")};return Y.runKernel(Mo,e)}var Bh=Q({relu6_:Iz});function Nz(r,t){let n={x:X(r,"x","reverse")},s={dims:t};return Y.runKernel(ia,n,s)}var Qn=Q({reverse_:Nz});function Tz(r){let e={x:X(r,"x","round")};return Y.runKernel(Bo,e)}var zC=Q({round_:Tz});function Ez(r){let e={x:X(r,"x","rsqrt")};return Y.runKernel(Vo,e)}var Vh=Q({rsqrt_:Ez});function fe(r,t){if((Dn(r)&&t!=="string"||Array.isArray(r))&&t!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(t==="string"&&Dn(r)&&!(r instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Hs(r,[],[],t)}function Az(r){let e={x:X(r,"x","selu")};return Y.runKernel(Go,e)}var Gh=Q({selu_:Az});function $z(r,t,e,n,s,o=[1,1],a="NHWC"){let l=X(r,"x","separableConv2d"),u=X(t,"depthwiseFilter","separableConv2d"),p=X(e,"pointwiseFilter","separableConv2d"),f=l,m=!1;if(l.rank===3&&(m=!0,f=dt(l,[1,l.shape[0],l.shape[1],l.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");tt(f.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${f.rank}.`),tt(u.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${u.rank}.`),tt(p.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${u.rank}.`),tt(p.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${p.shape[0]}.`),tt(p.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${p.shape[1]}.`);let d=u.shape[2],y=u.shape[3];tt(p.shape[2]===d*y,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*y}, but got ${p.shape[2]}.`);let _=va(f,u,n,s,a,o),C=Bn(_,p,1,"valid",a);return m?dt(C,[C.shape[1],C.shape[2],C.shape[3]]):C}var Wh=Q({separableConv2d_:$z});function Dz(r){let e={x:X(r,"x","sign")};return Y.runKernel(jo,e)}var MC=Q({sign_:Dz});function Rz(r){let e={x:X(r,"x","sin")};return Y.runKernel(Wo,e)}var Uh=Q({sin_:Rz});function Fz(r){let e={x:X(r,"x","sinh")};return Y.runKernel(Uo,e)}var jh=Q({sinh_:Fz});function Oz(r,t,e){let n=X(r,"x","slice1d");return tt(n.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${n.rank} tensor`),ze(n,[t],[e])}var qh=Q({slice1d_:Oz});function Pz(r,t,e){let n=X(r,"x","slice2d");return tt(n.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${n.rank} tensor`),ze(n,t,e)}var Mx=Q({slice2d_:Pz});function Lz(r,t,e){let n=X(r,"x","slice3d");return tt(n.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${n.rank} tensor`),ze(n,t,e)}var Hh=Q({slice3d_:Lz});function zz(r,t,e){let n=X(r,"x","slice4d");return tt(n.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${n.rank} tensor`),ze(n,t,e)}var bp=Q({slice4d_:zz});function Mz(r,t=-1){let e=X(r,"logits","softmax","float32");if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${e.rank} and dim was ${t}`);let n={logits:e},s={dim:t};return Y.runKernel(fa,n,s)}var ec=Q({softmax_:Mz});function Bz(r){tt(r.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${r.dtype}.`);let t={input:r};return Y.runKernel(xu,t)}var Kh=Q({fft_:Bz});function Vz(r){tt(r.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${r.dtype}.`);let t={input:r};return Y.runKernel(_u,t)}var vp=Q({ifft_:Vz});function Gz(r){let t=r.shape[r.shape.length-1],e=r.size/t,n;if(t<=2){let s=dt(r,[e,t]);n=vp(s)}else{let s=[e,2*(t-1)],o=dt(_p(r),[e,t]),a=dt(Oh(r),[e,t]),l=Qn(ze(o,[0,1],[e,t-2]),1),u=ft(Qn(ze(a,[0,1],[e,t-2]),1),fe(-1)),p=ar([o,l],1),f=ar([a,u],1),m=dt(vs(p,f),[s[0],s[1]]);n=vp(m)}if(n=_p(n),r.rank===3&&r.shape[0]!==0){let s=n,o=r.shape[0];n=dt(n,[o,n.shape[0]/o,n.shape[1]]),s.dispose()}return n}var BC=Q({irfft_:Gz});function Wz(r,t,e=0){let s={x:X(r,"x","split")},o={numOrSizeSplits:t,axis:e};return Y.runKernel(pa,s,o)}var Yr=Q({split_:Wz});function Uz(r,t){tt(r.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${r.dtype}`);let e=r.shape[r.shape.length-1],n=r.size/e,s;if(t!=null&&t<e){let _=r.shape.map(C=>0),v=r.shape.map(C=>C);v[r.shape.length-1]=t,s=ze(r,_,v),e=t}else if(t!=null&&t>e){let _=r.shape.map(v=>v);_[r.shape.length-1]=t-e,s=ar([r,lr(_)],r.shape.length-1),e=t}else s=r;let o=le(s),a=dt(vs(s,o),[n,e]),l=Kh(a),u=Math.floor(e/2)+1,p=_p(l),f=Oh(l),m=Yr(p,[u,e-u],p.shape.length-1),d=Yr(f,[u,e-u],f.shape.length-1),y=s.shape.slice();return y[s.shape.length-1]=u,dt(vs(m[0],d[0]),y)}var VC=Q({rfft_:Uz});function jz(r){let e={x:X(r,"x","sqrt")};return Y.runKernel(Ko,e)}var ur=Q({sqrt_:jz});function qz(r,t){let e=X(r,"a","squaredDifference"),n=X(t,"b","squaredDifference");[e,n]=Ne(e,n),ve(e.shape,n.shape);let s={a:e,b:n},o={};return Y.runKernel(Xo,s,o)}var GC=Q({squaredDifference_:qz});function Hz(r,t){let e=X(r,"x","squeeze");return dt(e,Gg(e.shape,t).newShape)}var rc=Q({squeeze_:Hz});function Kz(r,t=0){let e=mh(r,"tensors","stack","string_or_numeric");tt(e.length>=1,()=>"Pass at least one tensor to tf.stack"),e.length>0&&tt(t<=e[0].rank,()=>"Axis must be <= rank of the tensor");let n=e,s={axis:t};return Y.runKernel(ta,n,s)}var Zr=Q({stack_:Kz});function Xz(r,t=0){let n={x:X(r,"x","step")},s={alpha:t};return Y.runKernel(Qo,n,s)}var Js=Q({step_:Xz});function Yz(r,t,e,n,s=0,o=0,a=0,l=0,u=0){let f={x:X(r,"x","stridedSlice")},m={begin:t,end:e,strides:n,beginMask:s,endMask:o,ellipsisMask:a,newAxisMask:l,shrinkAxisMask:u};return Y.runKernel(Au,f,m)}var WC=Q({stridedSlice_:Yz});function Zz(r){let e={x:X(r,"x","tan")};return Y.runKernel(Zo,e)}var UC=Q({tan_:Zz});function Is(r,t){Xa(r);let e=ti(r,t);if(e.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Hs(r,null,e,t)}function wp(r,t,e){if(Xa(r),t!=null&&t.length!==2)throw new Error("tensor2d() requires shape to have two numbers");let n=ti(r,e);if(n.length!==2&&n.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(n.length===1&&t==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Hs(r,t,n,e)}function Jz(r,t=1,e=!0){let n=X(r,"x","topk");if(n.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");let s=n.shape[n.shape.length-1];if(t>s)throw new Error(`'k' passed to topk() must be <= the last dimension (${s}) but got ${t}`);let o={x:n},a={k:t,sorted:e},[l,u]=Y.runKernel($u,o,a);return{values:l,indices:u}}var jC=Q({topk_:Jz});function Qz(r,t=0,e=1,n,s){if(n!=null&&n==="bool")throw new Error("Unsupported data type $ { dtype }");let o=new yp(t,e,n,!0,s),a=ae(r,n);for(let l=0;l<a.values.length;l++)a.values[l]=o.nextValue();return a.toTensor()}var Xh=Q({truncatedNormal_:Qz});function t3(r,t=0){let e=X(r,"x","unique","string_or_numeric");tt(e.rank>0,()=>"The input tensor must be at least 1D");let n={x:e},s={axis:t},[o,a]=Y.runKernel(Du,n,s);return{values:o,indices:a}}var qC=Q({unique_:t3});function e3(r,t,e){let n=X(r,"x","unsortedSegmentSum"),s=X(t,"segmentIds","unsortedSegmentSum","int32");tt(Be(e),()=>"numSegments must be of dtype int");let o={x:n,segmentIds:s},a={numSegments:e};return Y.runKernel(da,o,a)}var Yh=Q({unsortedSegmentSum_:e3});function r3(r,t=0){let e=X(r,"x","unstack","string_or_numeric");tt(t>=-e.shape.length&&t<e.shape.length,()=>`Axis = ${t} is not in [-${e.shape.length}, ${e.shape.length})`);let n={value:e},s={axis:t};return Y.runKernel(ma,n,s)}var Rn=Q({unstack_:r3});function HC(r,t=!0,e,n){return Y.makeVariable(r,t,e,n)}function n3(r,t){let e=[];for(let o=0;o<t.length;o++)t[o]&&e.push(o);let n=ae(r,"int32"),s=ae([e.length,r.length],"int32");for(let o=0;o<e.length;o++){let a=n.indexToLoc(e[o]),l=o*r.length;s.values.set(a,l)}return s.toTensor()}function s3(r,t="euclidean",e=null,n=!1){r=X(r,"x","norm");let s=KC(r,t,e),o=s.shape;if(n){let a=Ir(e,r.shape);o=Zs(s.shape,a)}return dt(s,o)}function KC(r,t,e=null){if(r.rank===0)return Ar(r);if(r.rank!==1&&e===null)return KC(dt(r,[-1]),t,e);if(r.rank===1||typeof e=="number"||Array.isArray(e)&&e.length===1){if(t===1)return ee(Ar(r),e);if(t===Infinity)return Xr(Ar(r),e);if(t===-Infinity)return ml(Ar(r),e);if(t==="euclidean"||t===2)return ur(ee(Jn(Ar(r),fe(2,"int32")),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}if(Array.isArray(e)&&e.length===2){if(t===1)return Xr(ee(Ar(r),e[0]),e[1]-1);if(t===Infinity)return Xr(ee(Ar(r),e[1]),e[0]);if(t===-Infinity)return ml(ee(Ar(r),e[1]),e[0]);if(t==="fro"||t==="euclidean")return ur(ee(Te(r),e));throw new Error(`Error in norm: invalid ord value: ${t}`)}throw new Error(`Error in norm: invalid axis: ${e}`)}var nc=Q({norm_:s3});function XC(r,t){if(t==null)return r.shape.slice();if(Vs(r.shape,t))return t;if(r.shape.length===t.length){let e=[];for(let n=0;n<r.shape.length;n++)t[n]==null&&r.shape[n]!=null?e.push(r.shape[n]):e.push(t[n]);return e}return t}function o3(r,t,e,n){let s=X(r,"x","dropout");if(tt(s.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${s.dtype} tensor instead.`),tt(t>=0&&t<1,()=>`rate must be a float in the range [0, 1), but got ${t}.`),t===0)return r instanceof Ae?s.clone():s;let o=XC(s,e),a=1-t,l=Xt(Ca(Ot(Sa(o,0,1,"float32",n),a)),a);return ft(s,l)}var YC=Q({dropout_:o3});var oc={};Yn(oc,{conv2d:()=>l3,depthwiseConv2d:()=>f3,matMul:()=>m3});function i3(r,t,e,n,s,o="NHWC",a){let l=r;r.rank===3&&(l=dt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=dt(t,[1,t.shape[0],t.shape[1],t.shape[2]])),tt(l.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${l.shape}.`),tt(u.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${u.shape}.`),tt(e.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${e}.`);let p=o==="NHWC"?l.shape[3]:l.shape[1],f=o==="NHWC"?u.shape[3]:u.shape[1];tt(p===e[2],()=>`Error in conv2dDerFilter: depth of input ${p}) must match input depth in filter (${e[2]}.`),tt(f===e[3],()=>`Error in conv2dDerFilter: depth of dy (${f}) must match output depth for filter (${e[3]}).`),a!=null&&tt(Be(s),()=>`Error in conv2dDerFilter: pad must be an integer when using, dimRoundingMode ${a} but got pad ${s}.`);let m={x:l,dy:u},d={strides:n,pad:s,dataFormat:o,dimRoundingMode:a,filterShape:e};return Y.runKernel(cu,m,d)}var sc=Q({conv2DBackpropFilter_:i3});function xl(r,t,e){if(e==null||e==="linear")return r;if(e==="relu")return ft(r,Js(t));throw new Error(`Cannot compute gradient for fused activation ${e}.`)}function yl(r,t){let e=t,n=Qe(r.shape,t.shape);return n.length>0&&(e=ee(e,n)),dt(e,r.shape)}function _l(r,t,e,n){if(t==="linear")return r;if(t==="relu")return Ss(r);if(t==="elu")return wa(r);if(t==="relu6")return Bh(r);if(t==="prelu")return tc(r,e);if(t==="leakyrelu")return Ku(r,n);throw new Error(`Unknown fused activation ${t}.`)}var bl=(r,t)=>!(r>0)||t==="linear";function a3({x:r,filter:t,strides:e,pad:n,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:l,activation:u="linear",preluActivationWeights:p,leakyreluAlpha:f}){if(u=u||"linear",bl(Y.state.gradientDepth,u)===!1){let L=Bn(r,t,e,n,s,o,a);return l!=null&&(L=Ot(L,l)),_l(L,u,p,f)}let m=X(r,"x","conv2d"),d=X(t,"filter","conv2d"),y=m,_=!1;m.rank===3&&(_=!0,y=dt(m,[1,m.shape[0],m.shape[1],m.shape[2]])),tt(y.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${y.rank}.`),tt(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),a!=null&&tt(Be(n),()=>`Error in fused conv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${n}.`),tt(y.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${y.shape[3]}) must match input depth for filter ${d.shape[2]}.`),tt(Vr(e,o),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),tt(s==="NHWC",()=>`Error in conv2d: got dataFormat of ${s} but only NHWC is currently supported.`);let v=fl(y.shape,d.shape,e,o,n,a),C;l!=null&&(C=X(l,"bias","fused conv2d"),[C]=Ne(C,m),ve(v.outShape,C.shape));let N;p!=null&&(N=X(p,"prelu weights","fused conv2d"));let A=(L,Z)=>{let[K,et,it,xt]=Z,wt=xl(L,it,u);tt(Mn(o),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`);let St=ju(et.shape,wt,K,e,n),yt=sc(et,wt,K.shape,e,n),Nt=[St,yt];if(xt!=null){let ht=yl(xt,wt);Nt.push(ht)}return Nt},B={x:y,filter:d,bias:C,preluActivationWeights:N},P={strides:e,pad:n,dataFormat:s,dilations:o,dimRoundingMode:a,activation:u,leakyreluAlpha:f};return l==null?Vn((Z,K,et)=>{let it=Y.runKernel(al,B,P);return et([K,Z,it]),_&&(it=dt(it,[it.shape[1],it.shape[2],it.shape[3]])),{value:it,gradFunc:A}})(y,d):Vn((Z,K,et,it)=>{let xt=Y.runKernel(al,B,P);return it([K,Z,xt,et]),_&&(xt=dt(xt,[xt.shape[1],xt.shape[2],xt.shape[3]])),{value:xt,gradFunc:A}})(y,d,C)}var l3=Q({fusedConv2d_:a3});function u3(r,t,e,n,s,o=[1,1],a){let l=r;r.rank===3&&(l=dt(r,[1,r.shape[0],r.shape[1],r.shape[2]]));let u=t;u.rank===3&&(u=dt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let p={x:l,dy:u},f={strides:n,pad:s,dimRoundingMode:a,dilations:o,filterShape:e};return Y.runKernel(mu,p,f)}var Zh=Q({depthwiseConv2dNativeBackpropFilter_:u3});function c3(r,t,e,n,s,o=[1,1],a){let l=t,u=!1;t.rank===3&&(u=!0,l=dt(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let p={dy:l,filter:e},f={strides:n,pad:s,dimRoundingMode:a,dilations:o,inputShape:r},m=Y.runKernel(du,p,f);return u?dt(m,[m.shape[1],m.shape[2],m.shape[3]]):m}var Jh=Q({depthwiseConv2dNativeBackpropInput_:c3});function p3({x:r,filter:t,strides:e,pad:n,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:a,bias:l,activation:u="linear",preluActivationWeights:p,leakyreluAlpha:f}){if(bl(Y.state.gradientDepth,u)===!1){let L=va(r,t,e,n,s,o,a);return l!=null&&(L=Ot(L,l)),_l(L,u,p,f)}let m=X(r,"x","depthwiseConv2d"),d=X(t,"filter","depthwiseConv2d"),y=m,_=!1;m.rank===3&&(_=!0,y=dt(m,[1,m.shape[0],m.shape[1],m.shape[2]])),tt(y.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${y.rank}.`),tt(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),tt(y.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${y.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),o==null&&(o=[1,1]),tt(Vr(e,o),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${e} and dilations '${o}'`),a!=null&&tt(Be(n),()=>`Error in fused depthwiseConv2d: pad must be an integer when using dimRoundingMode ${a} but got pad ${n}.`);let v=fl(y.shape,d.shape,e,o,n,a,!0),C;l!=null&&(C=X(l,"bias","fused conv2d"),[C]=Ne(C,m),ve(v.outShape,C.shape));let N;p!=null&&(N=X(p,"prelu weights","fused depthwiseConv2d"));let A=(L,Z)=>{tt(Mn(o),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);let[K,et,it,xt]=Z,wt=xl(L,it,u),St=Jh(et.shape,wt,K,e,n,o,a),yt=Zh(et,wt,K.shape,e,n,o,a);if(xt!=null){let Nt=yl(C,wt);return[St,yt,Nt]}return[St,yt]},B={x:y,filter:d,bias:C,preluActivationWeights:N},P={strides:e,pad:n,dataFormat:s,dilations:o,dimRoundingMode:a,activation:u,leakyreluAlpha:f};return l==null?Vn((Z,K,et)=>{let it=Y.runKernel(ll,B,P);return et([K,Z,it]),_&&(it=dt(it,[it.shape[1],it.shape[2],it.shape[3]])),{value:it,gradFunc:A}})(y,d):Vn((Z,K,et,it)=>{let xt=Y.runKernel(ll,B,P);return it([K,Z,xt,et]),_&&(xt=dt(xt,[xt.shape[1],xt.shape[2],xt.shape[3]])),{value:xt,gradFunc:A}})(y,d,C)}var f3=Q({fusedDepthwiseConv2d_:p3});function h3({a:r,b:t,transposeA:e=!1,transposeB:n=!1,bias:s,activation:o="linear",preluActivationWeights:a,leakyreluAlpha:l}){if(bl(Y.state.gradientDepth,o)===!1){let xt=Ve(r,t,e,n);return s!=null&&(xt=Ot(xt,s)),_l(xt,o,a,l)}let u=X(r,"a","fused matMul"),p=X(t,"b","fused matMul");[u,p]=Ne(u,p);let f=e?u.shape[u.rank-2]:u.shape[u.rank-1],m=n?p.shape[p.rank-1]:p.shape[p.rank-2],d=e?u.shape[u.rank-1]:u.shape[u.rank-2],y=n?p.shape[p.rank-2]:p.shape[p.rank-1],_=u.shape.slice(0,-2),v=p.shape.slice(0,-2),C=Je(_),N=Je(v);tt(u.rank>=2&&p.rank>=2&&u.rank===p.rank,()=>`Error in fused matMul: inputs must have the same rank of at least 2, got ranks ${u.rank} and ${p.rank}.`),tt(Vs(_,v),()=>`Error in fused matMul: outer dimensions (${_}) and (${v}) of Tensors with shapes ${u.shape} and ${p.shape} must match.`),tt(f===m,()=>`Error in fused matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${u.shape} and ${p.shape} and transposeA=${e} and transposeB=${n} must match.`);let A=u.shape.slice(0,-2).concat([d,y]),B=e?dt(u,[C,f,d]):dt(u,[C,d,f]),P=n?dt(p,[N,y,m]):dt(p,[N,m,y]),L;s!=null&&(L=X(s,"bias","fused matMul"),[L]=Ne(L,u),ve(A,L.shape));let Z;a!=null&&(Z=X(a,"prelu weights","fused matMul"));let K=(xt,wt)=>{let[St,yt,Nt,ht]=wt,It=xl(dt(xt,Nt.shape),Nt,o),Ft,Ct;if(!e&&!n?(Ft=Ve(It,yt,!1,!0),Ct=Ve(St,It,!0,!1)):!e&&n?(Ft=Ve(It,yt,!1,!1),Ct=Ve(It,St,!0,!1)):e&&!n?(Ft=Ve(yt,It,!1,!0),Ct=Ve(St,It,!1,!1)):(Ft=Ve(yt,It,!0,!0),Ct=Ve(It,St,!0,!0)),s!=null){let Dt=yl(ht,It);return[Ft,Ct,Dt]}else return[Ft,Ct]},et={a:B,b:P,bias:L,preluActivationWeights:Z},it={transposeA:e,transposeB:n,activation:o,leakyreluAlpha:l};return s==null?Vn((wt,St,yt)=>{let Nt=Y.runKernel(il,et,it);return yt([wt,St,Nt]),{value:dt(Nt,A),gradFunc:K}})(B,P):Vn((wt,St,yt,Nt)=>{let ht=Y.runKernel(il,et,it);return Nt([wt,St,ht,yt]),{value:dt(ht,A),gradFunc:K}})(B,P,L)}var m3=Q({fusedMatMul_:h3});function ZC(r,t,e){let n=d3(r,t,e),s=n<0?-(n+1):n;r.splice(s,0,t)}function d3(r,t,e){return x3(r,t,e||g3)}function g3(r,t){return r>t?1:r<t?-1:0}function x3(r,t,e){let n=0,s=r.length,o=0,a=!1;for(;n<s;){o=n+(s-n>>>1);let l=e(t,r[o]);l>0?n=o+1:(s=o,a=!l)}return a?n:-n-1}function y3(r,t,e,n,s){return Bx(r,t,e,n,s,0)}function _3(r,t,e,n,s,o){return Bx(r,t,e,n,s,0,!1,o,!0)}function b3(r,t,e,n,s,o){return Bx(r,t,e,n,s,o,!0)}function Bx(r,t,e,n,s,o,a=!1,l=!1,u=!1){let p=[];for(let C=0;C<t.length;C++)t[C]>s&&p.push({score:t[C],boxIndex:C,suppressBeginIndex:0});p.sort(JC);let f=o>0?-.5/o:0,m=[],d=[];for(;m.length<e&&p.length>0;){let C=p.pop(),{score:N,boxIndex:A,suppressBeginIndex:B}=C;if(N<s)break;let P=!1;for(let L=m.length-1;L>=B;--L){let Z=v3(r,A,m[L]);if(Z>=n){P=!0;break}if(C.score=C.score*w3(n,f,Z),C.score<=s)break}C.suppressBeginIndex=m.length,P||(C.score===N?(m.push(A),d.push(C.score)):C.score>s&&ZC(p,C,JC))}let y=m.length,_=e-y;l&&_>0&&(m.push(...new Array(_).fill(0)),d.push(...new Array(_).fill(0)));let v={selectedIndices:m};return a&&(v.selectedScores=d),u&&(v.validOutputs=y),v}function v3(r,t,e){let n=r.subarray(t*4,t*4+4),s=r.subarray(e*4,e*4+4),o=Math.min(n[0],n[2]),a=Math.min(n[1],n[3]),l=Math.max(n[0],n[2]),u=Math.max(n[1],n[3]),p=Math.min(s[0],s[2]),f=Math.min(s[1],s[3]),m=Math.max(s[0],s[2]),d=Math.max(s[1],s[3]),y=(l-o)*(u-a),_=(m-p)*(d-f);if(y<=0||_<=0)return 0;let v=Math.max(o,p),C=Math.max(a,f),N=Math.min(l,m),A=Math.min(u,d),B=Math.max(N-v,0)*Math.max(A-C,0);return B/(y+_-B)}function w3(r,t,e){let n=Math.exp(t*e*e);return e<=r?n:0}function JC(r,t){return r.score-t.score||r.score===t.score&&t.boxIndex-r.boxIndex}function C3(r,t,e=!1,n=!1){let s=X(r,"images","resizeBilinear");tt(s.rank===3||s.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${s.rank}.`),tt(t.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${t}.`),tt(n===!1||e===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let o=s,a=!1;s.rank===3&&(a=!0,o=dt(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let[]=t,l={images:o},u={alignCorners:e,halfPixelCenters:n,size:t},p=Y.runKernel(oa,l,u);return a?dt(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var QC=Q({resizeBilinear_:C3});function k3(r,t,e=!1,n=!1){let s=X(r,"images","resizeNearestNeighbor");tt(s.rank===3||s.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${s.rank}.`),tt(t.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${t}.`),tt(s.dtype==="float32"||s.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),tt(n===!1||e===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let o=s,a=!1;s.rank===3&&(a=!0,o=dt(s,[1,s.shape[0],s.shape[1],s.shape[2]]));let[]=t,l={images:o},u={alignCorners:e,halfPixelCenters:n,size:t},p=Y.runKernel(sa,l,u);return a?dt(p,[p.shape[1],p.shape[2],p.shape[3]]):p}var tk=Q({resizeNearestNeighbor_:k3});function S3(r,t,e){tt(t%1==0,()=>`bandPart(): numLower must be an integer, got ${t}.`),tt(e%1==0,()=>`bandPart(): numUpper must be an integer, got ${e}.`);let n=X(r,"a","bandPart");tt(n.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${n.rank}.`);let s=n.shape,[o,a]=n.shape.slice(-2);if(!(t<=o))throw new Error(`bandPart(): numLower (${t}) must not be greater than the number of rows (${o}).`);if(!(e<=a))throw new Error(`bandPart(): numUpper (${e}) must not be greater than the number of columns (${a}).`);t<0&&(t=o),e<0&&(e=a);let l=dt(zx(0,o,1,"int32"),[-1,1]),u=zx(0,a,1,"int32"),p=ie(l,u),f=fn(Ys(p,fe(+t,"int32")),Zn(p,fe(-e,"int32"))),m=lr([o,a],n.dtype);return dt(Zr(Rn(dt(n,[-1,o,a])).map(d=>Cr(f,d,m))),s)}var ek=Q({bandPart_:S3});function I3(r){let t;if(Array.isArray(r)){t=!1,tt(r!=null&&r.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");let s=r[0].shape[0];for(let o=1;o<r.length;++o)tt(r[o].shape[0]===s,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${r[o].shape[0]} vs. ${s})`)}else t=!0,r=Yr(r,r.shape[0],0).map(s=>rc(s,[0]));tt(r.length<=r[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${r.length}) exceeds number of dimensions (${r[0].shape[0]}).`);let e=[],n=r;for(let s=0;s<r.length;++s)e.push(Y.tidy(()=>{let o=n[s];if(s>0)for(let a=0;a<s;++a){let l=ft(ee(ft(e[a],o)),e[a]);o=ie(o,l)}return Xt(o,nc(o,"euclidean"))}));return t?Zr(e,0):e}var rk=Q({gramSchmidt_:I3});function N3(r,t=!1){if(tt(r.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${r.rank}`),r.rank===2)return nk(r,t);{let e=r.shape.slice(0,r.shape.length-2).reduce((u,p)=>u*p),n=Rn(dt(r,[e,r.shape[r.shape.length-2],r.shape[r.shape.length-1]]),0),s=[],o=[];n.forEach(u=>{let[p,f]=nk(u,t);s.push(p),o.push(f)});let a=dt(Zr(s,0),r.shape),l=dt(Zr(o,0),r.shape);return[a,l]}}function nk(r,t=!1){return Y.tidy(()=>{tt(r.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${r.shape.length}D Tensor.`);let e=r.shape[0],n=r.shape[1],s=mp(e),o=ws(r),a=wp([[1]],[1,1]),l=ws(a),u=e>=n?n:e;for(let p=0;p<u;++p){let f=o,m=l,d=s;[l,o,s]=Y.tidy(()=>{let y=ze(o,[p,p],[e-p,1]),_=nc(y),v=ze(o,[p,p],[1,1]),C=Cr(Kr(v,0),wp([[-1]]),wp([[1]])),N=ie(v,ft(C,_)),A=Xt(y,N);A.shape[0]===1?l=ws(a):l=ar([a,ze(A,[1,0],[A.shape[0]-1,A.shape[1]])],0);let B=je(Xt(Ve(C,N),_)),P=ze(o,[p,0],[e-p,n]),L=ft(B,l),Z=Le(l);if(p===0)o=ie(P,Ve(L,Ve(Z,P)));else{let it=ie(P,Ve(L,Ve(Z,P)));o=ar([ze(o,[0,0],[p,n]),it],0)}let K=Le(L),et=ze(s,[0,p],[e,s.shape[1]-p]);if(p===0)s=ie(et,Ve(Ve(et,l),K));else{let it=ie(et,Ve(Ve(et,l),K));s=ar([ze(s,[0,0],[e,p]),it],1)}return[l,o,s]}),pe([f,m,d])}return!t&&e>n&&(s=ze(s,[0,0],[e,n]),o=ze(o,[0,0],[n,n])),[s,o]})}var sk=Q({qr_:N3});var ok={bandPart:ek,gramSchmidt:rk,qr:sk};var hn=class extends kh{minimize(t,e=!1,n){let{value:s,grads:o}=this.computeGradients(t,n);if(n!=null){let a=n.map(l=>({name:l.name,tensor:o[l.name]}));this.applyGradients(a)}else this.applyGradients(o);return pe(o),e?s:(s.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(t,e){return Sx(t,e)}dispose(){this.iterations_!=null&&pe(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:fe(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(t){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(t){return this.iterations_=(await t[0].tensor.data())[0],t.slice(1)}};Object.defineProperty(hn,Symbol.hasInstance,{value:r=>r.minimize!=null&&r.computeGradients!=null&&r.applyGradients!=null});var Cp=class extends hn{constructor(t,e,n=null){super();this.learningRate=t,this.rho=e,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],n==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,s)=>{let o=Y.registeredVariables[n],a=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${n}/accum_grad`,variable:_t(()=>le(o).variable(a))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${n}/accum_var`,variable:_t(()=>le(o).variable(a))});let l=Array.isArray(t)?t[s].tensor:t[n];if(l==null)return;let u=this.accumulatedGrads[s].variable,p=this.accumulatedUpdates[s].variable;_t(()=>{let f=Ot(ft(u,this.rho),ft(Te(l),1-this.rho)),m=ft(Xt(ur(Ot(p,this.epsilon)),ur(Ot(u,this.epsilon))),l),d=Ot(ft(p,this.rho),ft(Te(m),1-this.rho));u.assign(f),p.assign(d);let y=Ot(ft(m,-this.learningRate),o);o.assign(y)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(pe(this.accumulatedGrads.map(t=>t.variable)),pe(this.accumulatedUpdates.map(t=>t.variable)))}async getWeights(){let t=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=t.length/2,n=!1;this.accumulatedGrads=t.slice(0,e).map(s=>({originalName:s.name,variable:s.tensor.variable(n)})),this.accumulatedUpdates=t.slice(e,e*2).map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.rho,e.epsilon)}};Cp.className="Adadelta";yn(Cp);var kp=class extends hn{constructor(t,e=.1){super();this.learningRate=t,this.initialAccumulatorValue=e,this.accumulatedGrads=[]}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,s)=>{let o=Y.registeredVariables[n];if(this.accumulatedGrads[s]==null){let u=!1;this.accumulatedGrads[s]={originalName:`${n}/accumulator`,variable:_t(()=>Fh(o.shape,this.initialAccumulatorValue).variable(u))}}let a=Array.isArray(t)?t[s].tensor:t[n];if(a==null)return;let l=this.accumulatedGrads[s].variable;_t(()=>{let u=Ot(l,Te(a));l.assign(u);let p=Ot(ft(Xt(a,ur(Ot(u,Y.backend.epsilon()))),-this.learningRate),o);o.assign(p)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&pe(this.accumulatedGrads.map(t=>t.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulatedGrads=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(t,e){return new t(e.learningRate,e.initialAccumulatorValue)}};kp.className="Adagrad";yn(kp);var Sp=class extends hn{constructor(t,e,n,s=null){super();this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=s,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],_t(()=>{this.accBeta1=fe(e).variable(),this.accBeta2=fe(n).variable()}),s==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);_t(()=>{let n=ie(1,this.accBeta1),s=ie(1,this.accBeta2);e.forEach((o,a)=>{let l=Y.registeredVariables[o],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:_t(()=>le(l).variable(u))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${o}/v`,variable:_t(()=>le(l).variable(u))});let p=Array.isArray(t)?t[a].tensor:t[o];if(p==null)return;let f=this.accumulatedFirstMoment[a].variable,m=this.accumulatedSecondMoment[a].variable,d=Ot(ft(f,this.beta1),ft(p,1-this.beta1)),y=Ot(ft(m,this.beta2),ft(Te(p),1-this.beta2)),_=Xt(d,n),v=Xt(y,s);f.assign(d),m.assign(y);let C=Ot(ft(Xt(_,Ot(ur(v),this.epsilon)),-this.learningRate),l);l.assign(C)}),this.accBeta1.assign(ft(this.accBeta1,this.beta1)),this.accBeta2.assign(ft(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&pe(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedSecondMoment!=null&&pe(this.accumulatedSecondMoment.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t),_t(()=>{this.accBeta1.assign(Jn(this.beta1,this.iterations_+1)),this.accBeta2.assign(Jn(this.beta2,this.iterations_+1))});let e=t.length/2,n=!1;this.accumulatedFirstMoment=t.slice(0,e).map(s=>({originalName:s.name,variable:s.tensor.variable(n)})),this.accumulatedSecondMoment=t.slice(e,e*2).map(s=>({originalName:s.name,variable:s.tensor.variable(n)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon)}};Sp.className="Adam";yn(Sp);var Ip=class extends hn{constructor(t,e,n,s=null,o=0){super();this.learningRate=t,this.beta1=e,this.beta2=n,this.epsilon=s,this.decay=o,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],_t(()=>{this.iteration=fe(0).variable(),this.accBeta1=fe(e).variable()}),s==null&&(this.epsilon=Y.backend.epsilon())}applyGradients(t){let e=Array.isArray(t)?t.map(n=>n.name):Object.keys(t);_t(()=>{let n=ie(1,this.accBeta1),s=Xt(-this.learningRate,Ot(ft(this.iteration,this.decay),1));e.forEach((o,a)=>{let l=Y.registeredVariables[o],u=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${o}/m`,variable:le(l).variable(u)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${o}/v`,variable:le(l).variable(u)});let p=Array.isArray(t)?t[a].tensor:t[o];if(p==null)return;let f=this.accumulatedFirstMoment[a].variable,m=this.accumulatedWeightedInfNorm[a].variable,d=Ot(ft(f,this.beta1),ft(p,1-this.beta1)),y=ft(m,this.beta2),_=Ar(p),v=Gn(y,_);f.assign(d),m.assign(v);let C=Ot(ft(Xt(s,n),Xt(d,Ot(v,this.epsilon))),l);l.assign(C)}),this.iteration.assign(Ot(this.iteration,1)),this.accBeta1.assign(ft(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&pe(this.accumulatedFirstMoment.map(t=>t.variable)),this.accumulatedWeightedInfNorm!=null&&pe(this.accumulatedWeightedInfNorm.map(t=>t.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(t){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(t,e){return new t(e.learningRate,e.beta1,e.beta2,e.epsilon,e.decay)}};Ip.className="Adamax";yn(Ip);var vl=class extends hn{constructor(t){super();this.learningRate=t,this.setLearningRate(t)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,s)=>{let o=Array.isArray(t)?t[s].tensor:t[n];if(o==null)return;let a=Y.registeredVariables[n];_t(()=>{let l=Ot(ft(this.c,o),a);a.assign(l)})}),this.incrementIterations()}setLearningRate(t){this.learningRate=t,this.c!=null&&this.c.dispose(),this.c=Fr(fe(-t))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(t){if(t=await this.extractIterations(t),t.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(t,e){return new t(e.learningRate)}};vl.className="SGD";yn(vl);var Np=class extends vl{constructor(t,e,n=!1){super(t);this.learningRate=t,this.momentum=e,this.useNesterov=n,this.accumulations=[],this.m=fe(this.momentum)}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,s)=>{let o=Y.registeredVariables[n];if(this.accumulations[s]==null){let u=!1;this.accumulations[s]={originalName:`${n}/momentum`,variable:_t(()=>le(o).variable(u))}}let a=this.accumulations[s].variable,l=Array.isArray(t)?t[s].tensor:t[n];l!=null&&_t(()=>{let u,p=Ot(ft(this.m,a),l);this.useNesterov?u=Ot(ft(this.c,Ot(l,ft(p,this.m))),o):u=Ot(ft(this.c,p),o),a.assign(p),o.assign(u)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&pe(this.accumulations.map(t=>t.variable))}setMomentum(t){this.momentum=t}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=!1;this.accumulations=t.map(n=>({originalName:n.name,variable:n.tensor.variable(e)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(t,e){return new t(e.learningRate,e.momentum,e.useNesterov)}};Np.className="Momentum";yn(Np);var Tp=class extends hn{constructor(t,e=.9,n=0,s=null,o=!1){super();if(this.learningRate=t,this.decay=e,this.momentum=n,this.epsilon=s,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=o,s==null&&(this.epsilon=Y.backend.epsilon()),t==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(t){(Array.isArray(t)?t.map(n=>n.name):Object.keys(t)).forEach((n,s)=>{let o=Y.registeredVariables[n],a=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${n}/rms`,variable:_t(()=>le(o).variable(a))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${n}/momentum`,variable:_t(()=>le(o).variable(a))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${n}/mg`,variable:_t(()=>le(o).variable(a))});let l=Array.isArray(t)?t[s].tensor:t[n];if(l==null)return;let u=this.accumulatedMeanSquares[s].variable,p=this.accumulatedMoments[s].variable;_t(()=>{let f=Ot(ft(u,this.decay),ft(Te(l),1-this.decay));if(this.centered){let m=this.accumulatedMeanGrads[s].variable,d=Ot(ft(m,this.decay),ft(l,1-this.decay)),y=Xt(ft(l,this.learningRate),ur(ie(f,Ot(Te(d),this.epsilon)))),_=Ot(ft(p,this.momentum),y);u.assign(f),m.assign(d),p.assign(_);let v=ie(o,_);o.assign(v)}else{let m=Ot(ft(u,this.decay),ft(Te(l),1-this.decay)),d=Ot(ft(p,this.momentum),Xt(ft(l,this.learningRate),ur(Ot(m,this.epsilon))));u.assign(m),p.assign(d);let y=ie(o,d);o.assign(y)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&pe(this.accumulatedMeanSquares.map(t=>t.variable)),this.accumulatedMeanGrads!=null&&this.centered&&pe(this.accumulatedMeanGrads.map(t=>t.variable)),this.accumulatedMoments!=null&&pe(this.accumulatedMoments.map(t=>t.variable))}async getWeights(){let t=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&t.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(t.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(t){t=await this.extractIterations(t);let e=this.centered?t.length/3:t.length/2,n=!1;this.accumulatedMeanSquares=t.slice(0,e).map(s=>({originalName:s.name,variable:s.tensor.variable(n)})),this.accumulatedMoments=t.slice(e,e*2).map(s=>({originalName:s.name,variable:s.tensor.variable(n)})),this.centered&&(this.accumulatedMeanGrads=t.slice(e*2,e*3).map(s=>({originalName:s.name,variable:s.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(t,e){return new t(e.learningRate,e.decay,e.momentum,e.epsilon,e.centered)}};Tp.className="RMSProp";yn(Tp);var ai=class{static sgd(t){return new vl(t)}static momentum(t,e,n=!1){return new Np(t,e,n)}static rmsprop(t,e=.9,n=0,s=null,o=!1){return new Tp(t,e,n,s,o)}static adam(t=.001,e=.9,n=.999,s=null){return new Sp(t,e,n,s)}static adadelta(t=.001,e=.95,n=null){return new Cp(t,e,n)}static adamax(t=.002,e=.9,n=.999,s=null,o=0){return new Ip(t,e,n,s,o)}static adagrad(t,e=.1){return new kp(t,e)}};var wl={sgd:ai.sgd,momentum:ai.momentum,adadelta:ai.adadelta,adagrad:ai.adagrad,rmsprop:ai.rmsprop,adamax:ai.adamax,adam:ai.adam};var T3=(()=>typeof requestAnimationFrame!="undefined"?requestAnimationFrame:typeof setImmediate!="undefined"?setImmediate:r=>r())();function Qh(){return new Promise(r=>T3(()=>r()))}var H={};Yn(H,{ERF_A1:()=>M3,ERF_A2:()=>B3,ERF_A3:()=>V3,ERF_A4:()=>G3,ERF_A5:()=>W3,ERF_P:()=>z3,PARALLELIZE_THRESHOLD:()=>tm,SELU_SCALE:()=>Gx,SELU_SCALEALPHA:()=>Vx,applyActivation:()=>_l,assertAndGetBroadcastShape:()=>ve,assertAxesAreInnerMostDims:()=>GL,assertParamsConsistent:()=>E3,assignToTypedArray:()=>Z3,axesAreInnerMostDims:()=>Ix,calculateShapes:()=>nP,combineLocations:()=>mC,complexWithEvenIndex:()=>K3,complexWithOddIndex:()=>X3,computeConv2DInfo:()=>fl,computeConv3DInfo:()=>Ww,computeDefaultPad:()=>kx,computeDilation2DInfo:()=>SP,computeOptimalWindowSize:()=>$3,computeOutAndReduceShapes:()=>Nx,computeOutShape:()=>A3,computePool2DInfo:()=>wx,computePool3DInfo:()=>IP,convertConv2DDataFormat:()=>Gw,eitherStridesOrDilationsAreOne:()=>Vr,expandShapeToKeepDim:()=>Zs,exponent:()=>Q3,exponents:()=>J3,fromStringArrayToUint8:()=>oM,fromUint8ToStringArray:()=>sM,getAxesPermutation:()=>Tx,getBroadcastDims:()=>lL,getComplexWithIndex:()=>Y3,getFusedBiasGradient:()=>yl,getFusedDyActivation:()=>xl,getImageCenter:()=>D3,getInnerMostAxes:()=>WL,getPermuted:()=>F3,getReductionAxes:()=>Qe,getReshaped:()=>R3,getReshapedPermuted:()=>O3,getSliceBeginCoords:()=>P3,getSliceSize:()=>L3,getUndoAxesPermutation:()=>dp,log:()=>j3,mergeRealAndImagArrays:()=>q3,prepareAndValidate:()=>eP,prepareSplitSize:()=>tM,segment_util:()=>ik,shouldFuse:()=>bl,slice_util:()=>pn,splitRealAndImagArrays:()=>H3,tupleValuesAreOne:()=>Mn,upcastType:()=>Br,validateInput:()=>rP,validateUpdateShape:()=>ww,warn:()=>U3});function E3(r,t){let e=r[0].length;r.forEach((s,o)=>{tt(s.length===e,()=>`Error in concat${e}D: rank of tensors[${o}] must be the same as the rank of the rest (${e})`)}),tt(t>=0&&t<e,()=>`Error in concat${e}D: axis must be between 0 and ${e-1}.`);let n=r[0];r.forEach((s,o)=>{for(let a=0;a<e;a++)tt(a===t||s[a]===n[a],()=>`Error in concat${e}D: Shape of tensors[${o}] (${s}) does not match the shape of the rest (${n}) along the non-concatenated axis ${o}.`)})}function A3(r,t){let e=r[0].slice();for(let n=1;n<r.length;n++)e[t]+=r[n][t];return e}var tm=30;function $3(r){return r<=tm?r:ru(r,Math.floor(Math.sqrt(r)))}function D3(r,t,e){let n=e*(typeof r=="number"?r:r[0]),s=t*(typeof r=="number"?r:r[1]);return[n,s]}function R3(r,t,e,n=!0){let s=[];if(n)s=s.concat(t.slice(0)),s.push(r[0]/e),s=s.concat(r.slice(1));else{s=s.concat(r[0]);let o=t.length;for(let a=0;a<o;++a)s=s.concat([r[a+1]/t[a],t[a]]);s=s.concat(r.slice(o+1))}return s}function F3(r,t,e=!0){let n=[];if(e){n.push(t);for(let s=t+1;s<r;++s)s<=2*t?(n.push(s),n.push(s-(t+1))):n.push(s)}else{let s=[],o=[];for(let a=1;a<r;++a)a>=t*2+1||a%2==1?o.push(a):s.push(a);n.push(...s),n.push(0),n.push(...o)}return n}function O3(r,t,e,n=!0){let s=[];n?s.push(r[0]/e):s.push(r[0]*e);for(let o=1;o<r.length;++o)o<=t.length?n?s.push(t[o-1]*r[o]):s.push(r[o]/t[o-1]):s.push(r[o]);return s}function P3(r,t){let e=[0];for(let n=0;n<t;++n)e.push(r[n][0]);return e}function L3(r,t,e){let n=r.slice(0,1);for(let s=0;s<e;++s)n.push(r[s+1]-t[s][0]-t[s][1]);return n}var Vx=1.7580993408473768,Gx=1.0507009873554805;var z3=.3275911,M3=.254829592,B3=-.284496736,V3=1.421413741,G3=-1.453152027,W3=1.061405429;function U3(...r){vt().getBool("IS_TEST")||console.warn(...r)}function j3(...r){vt().getBool("IS_TEST")||console.log(...r)}function q3(r,t){if(r.length!==t.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${r.length}, imag: ${t.length}.`);let e=new Float32Array(r.length*2);for(let n=0;n<e.length;n+=2)e[n]=r[n/2],e[n+1]=t[n/2];return e}function H3(r){let t=new Float32Array(r.length/2),e=new Float32Array(r.length/2);for(let n=0;n<r.length;n+=2)t[n/2]=r[n],e[n/2]=r[n+1];return{real:t,imag:e}}function K3(r){let t=Math.ceil(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let s=0;s<r.length;s+=4)e[Math.floor(s/4)]=r[s],n[Math.floor(s/4)]=r[s+1];return{real:e,imag:n}}function X3(r){let t=Math.floor(r.length/4),e=new Float32Array(t),n=new Float32Array(t);for(let s=2;s<r.length;s+=4)e[Math.floor(s/4)]=r[s],n[Math.floor(s/4)]=r[s+1];return{real:e,imag:n}}function Y3(r,t){let e=r[t*2],n=r[t*2+1];return{real:e,imag:n}}function Z3(r,t,e,n){r[n*2]=t,r[n*2+1]=e}function J3(r,t){let e=new Float32Array(r/2),n=new Float32Array(r/2);for(let s=0;s<Math.ceil(r/2);s++){let o=(t?2:-2)*Math.PI*(s/r);e[s]=Math.cos(o),n[s]=Math.sin(o)}return{real:e,imag:n}}function Q3(r,t,e){let n=(e?2:-2)*Math.PI*(r/t),s=Math.cos(n),o=Math.sin(n);return{real:s,imag:o}}function tM(r,t,e=0){let n=[];if(typeof t=="number")tt(r.shape[e]%t==0,()=>"Number of splits must evenly divide the axis."),n=new Array(t).fill(r.shape[e]/t);else{let s=t.reduce((a,l)=>(l===-1&&(a+=1),a),0);tt(s<=1,()=>"There should be only one negative value in split array.");let o=t.indexOf(-1);if(o!==-1){let a=t.reduce((l,u)=>u>0?l+u:l);t[o]=r.shape[e]-a}tt(r.shape[e]===t.reduce((a,l)=>a+l),()=>"The sum of sizes must match the size of the axis dimension."),n=t}return n}var ik={};Yn(ik,{collectGatherOpShapeInfo:()=>nM,computeOutShape:()=>rM,segOpComputeOptimalWindowSize:()=>eM});function eM(r,t){let e=!1,n;for(r<=tm?(n=r,e=!0):n=ru(r,Math.floor(Math.sqrt(r)));!e;)n>t||n===r?e=!0:n=ru(r,n+1);return n}function rM(r,t,e){let n=[],s=r.length;for(let o=0;o<s;o++)o!==t?n.push(r[o]):n.push(e);return n}function nM(r,t,e,n){let s=t.shape.length,o=r.shape.length;if(n!==0&&(n<-s||n>s))throw new Error(`Expect batchDims in the range of [-${s}, ${s}], but got ${n}`);if(n<0&&(n+=s),n>o)throw new Error(`batchDims (${n}) must be less than rank(x) (
    ${o}).`);if(e<n)throw new Error(`batchDims (${n}) must be less than or equal to axis (${e}).`);for(let m=0;m<n;++m)if(r.shape[m]!==t.shape[m])throw new Error(`x.shape[${m}]: ${r.shape[m]} should be equal to indices.shape[${m}]: ${t.shape[m]}.`);let a=r.shape[e],l=[],u=1,p=1,f=1;for(let m=0;m<n;++m)l.push(r.shape[m]),u*=r.shape[m];for(let m=n;m<e;m++)l.push(r.shape[m]),p*=r.shape[m];for(let m=n;m<s;m++)l.push(t.shape[m]);for(let m=e+1;m<o;m++)l.push(r.shape[m]),f*=r.shape[m];return{batchSize:u,sliceSize:f,outerSize:p,dimSize:a,outputShape:l}}function sM(r){try{return r.map(t=>Ou(t))}catch(t){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${t}`)}}function oM(r){return r.map(t=>Fu(t))}var sn={};Yn(sn,{nonMaxSuppressionV3Impl:()=>y3,nonMaxSuppressionV4Impl:()=>_3,nonMaxSuppressionV5Impl:()=>b3,whereImpl:()=>n3});var em={kernelName:ki,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(r,Js(Vt(e,"float32"),-1))}}};var ak={kernelName:ao,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Te(Vt(e,"float32")),s=ur(ie(fe(1),n));return je(Xt(r,s))}}}};var lk={kernelName:lo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=ur(ie(Te(Vt(e,"float32")),1));return Xt(r,n)}}}};var uk={kernelName:_s,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,s=ve(e.shape,n.shape);return{a:()=>{let l=r,u=Qe(e.shape,s);return u.length>0&&(l=ee(l,u)),dt(l,e.shape)},b:()=>{let l=r,u=Qe(n.shape,s);return u.length>0&&(l=ee(l,u)),dt(l,n.shape)}}}};var ck={kernelName:su,saveAllInputs:!0,gradFunc:(r,t)=>{let e={};return t.forEach((n,s)=>{e[s]=()=>r.clone()}),e}};var pk={kernelName:Si,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>le(e)}}};var fk={kernelName:Ii,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>le(e)}}};var hk={kernelName:uo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Xt(r,ur(ie(fe(1),Te(Vt(e,"float32")))))}}};var mk={kernelName:co,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=ur(Ot(fe(1),Te(Vt(e,"float32"))));return Xt(r,n)}}}};var dk={kernelName:ho,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,s=ve(e.shape,n.shape);return{a:()=>{let l=Ot(Te(e),Te(n)),u=ft(r,Xt(n,l)),p=Qe(e.shape,s);return p.length>0&&(u=ee(u,p)),dt(u,e.shape)},b:()=>{let l=Ot(Te(e),Te(n)),u=je(ft(r,Xt(e,l))),p=Qe(n.shape,s);return p.length>0&&(u=ee(u,p)),dt(u,n.shape)}}}};var gk={kernelName:po,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Xt(r,Ot(Te(Vt(e,"float32")),1))}}};var xk={kernelName:fo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Xt(r,ie(fe(1),Te(Vt(e,"float32"))))}}};function iM(r,t,e,n,s,o){let a=X(r,"dy","avgPool3dGrad"),l=X(t,"input","avgPool3dGrad"),u=a,p=l,f=!1;l.rank===4&&(f=!0,u=dt(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),p=dt(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),tt(u.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),tt(p.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${p.rank}.`),o!=null&&tt(Be(s),()=>`Error in avgPool3dGrad: pad must be an integer when using, dimRoundingMode ${o} but got pad ${s}.`);let m={dy:u,input:p},d={filterSize:e,strides:n,pad:s,dimRoundingMode:o},y=Y.runKernel(lu,m,d);return f?dt(y,[y.shape[1],y.shape[2],y.shape[3],y.shape[4]]):y}var yk=Q({avgPool3dGrad_:iM});var _k={kernelName:Ti,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=e;return{x:()=>yk(r,n,s,o,a,l)}}};function aM(r,t,e,n,s){let o=X(r,"dy","avgPoolGrad"),a=X(t,"input","avgPoolGrad");tt(a.rank===o.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${o.rank})`);let l=a,u=o,p=!1;a.rank===3&&(p=!0,l=dt(a,[1,a.shape[0],a.shape[1],a.shape[2]]),u=dt(o,[1,o.shape[0],o.shape[1],o.shape[2]])),tt(u.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${u.rank}.`),tt(l.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${l.rank}.`);let f={dy:u,input:l},m={filterSize:e,strides:n,pad:s},d=Y.runKernel(au,f,m);return p?dt(d,[d.shape[1],d.shape[2],d.shape[3]]):d}var bk=Q({avgPoolGrad_:aM});var vk={kernelName:Ni,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{filterSize:s,strides:o,pad:a}=e;return{x:()=>bk(r,n,s,o,a)}}};var wk={kernelName:Ei,inputsToSave:["a","b"],gradFunc:(r,t,e)=>{let[n,s]=t,{transposeA:o,transposeB:a}=e;return!o&&!a?{a:()=>Ve(r,s,!1,!0),b:()=>Ve(n,r,!0,!1)}:!o&&a?{a:()=>Ve(r,s,!1,!1),b:()=>Ve(r,n,!0,!1)}:o&&!a?{a:()=>Ve(s,r,!1,!0),b:()=>Ve(n,r,!1,!1)}:{a:()=>Ve(s,r,!0,!0),b:()=>Ve(r,n,!0,!0)}}};var Ck={kernelName:Ai,gradFunc:(r,t,e)=>{let{blockShape:n,crops:s}=e;return{x:()=>Qu(r,n,s)}}};var kk={kernelName:Iv,gradFunc:(r,t,e)=>{let n=e,s=n.inputShape,o=n.shape,a=Array.from(o);for(let u=s.length-1;u>=0;u--)if(s[u]===o[u])a[u]=1;else if(s[u]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${o}].`);let l=[];for(let u=0;u<a.length;u++)a[u]>1&&l.push(u);return{x:()=>ee(r,l,!0)}}};var Sk={kernelName:Ws,gradFunc:r=>({x:()=>r.clone()})};var Ik={kernelName:mo,gradFunc:r=>({x:()=>le(r)})};var Nk={kernelName:go,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{clipValueMin:s,clipValueMax:o}=e;return{x:()=>Cr(fn(Zn(n,s),Ys(n,o)),r,le(r))}}};var Tk={kernelName:$i,inputsToSave:["x"],gradFunc:em.gradFunc};var Ek={kernelName:Di,saveAllInputs:!0,gradFunc:(r,t,e)=>{let n=t.map(u=>u.shape),{axis:s}=e,o=Ir(s,t[0].shape)[0],a=n.map(u=>u[o]);return Yr(r,a,o).map(u=>()=>u)}};var Ak={kernelName:Ri,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,s]=t,{dilations:o,strides:a,pad:l,dataFormat:u}=e;return tt(Mn(o),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${o}'`),{x:()=>ju(n.shape,r,s,a,l,u),filter:()=>sc(n,r,s.shape,a,l,u)}}};var $k={kernelName:Fi,inputsToSave:["dy","filter"],gradFunc:(r,t,e)=>{let[n,s]=t,{strides:o,pad:a,dataFormat:l,dimRoundingMode:u}=e;return{dy:()=>Bn(r,s,o,a,l,1,u),filter:()=>sc(r,n,s.shape,o,a,l,u)}}};function lM(r,t,e,n,s){let o=r;r.rank===4&&(o=dt(r,[1,r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));let a=t;a.rank===4&&(a=dt(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),tt(o.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${o.shape}.`),tt(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),tt(e.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${e}.`),tt(o.shape[4]===e[3],()=>`Error in conv3dDerFilter: depth of input ${o.shape[4]}) must match input depth in filter (${e[3]}.`),tt(a.shape[4]===e[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${e[4]}).`);let l={x:o,dy:a},u={strides:n,pad:s,filterShape:e};return Y.runKernel(pu,l,u)}var Dk=Q({conv3DBackpropFilter_:lM});var Rk={kernelName:Oi,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:s,pad:o}=e;tt(Mn(n),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${n}'`);let[a,l]=t;return{x:()=>eC(a.shape,r,l,s,o),filter:()=>Dk(a,r,l.shape,s,o)}}};var Fk={kernelName:xo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(je(Uh(Vt(e,"float32"))),r)}}};var Ok={kernelName:yo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(jh(Vt(e,"float32")),r)}}};var Pk={kernelName:Pi,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:s,exclusive:o,reverse:a}=e;return{x:()=>{let l=Tx([s],n.rank),u=Rh(r,s,o,!a);return l!=null&&(u=Le(u,l)),u}}}};var Lk={kernelName:Li,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let{dilations:n,strides:s,pad:o,dimRoundingMode:a}=e,l=n??[1,1];tt(Mn(l),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${l}'`);let[u,p]=t;return tt(u.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${u.rank}.`),tt(p.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${p.rank}.`),tt(u.shape[3]===p.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${u.shape[3]}) must match the inChannels dimension in filter ${p.shape[2]}.`),tt(Vr(s,l),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${s} and dilations '${l}'.`),a!=null&&tt(Be(o),()=>`Error in depthwiseConv2d: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`),{x:()=>Jh(u.shape,r,p,s,o,n,a),filter:()=>Zh(u,r,p.shape,s,o,n,a)}}};var zk={kernelName:zi,inputsToSave:["x","filter"],gradFunc:(r,t,e)=>{let[n,s]=t,o={x:n,filter:s,dy:r},a={x:n,filter:s,dy:r};return{x:()=>Y.runKernel(Qc,o,e),filter:()=>Y.runKernel(tp,a,e)}}};var Mk={kernelName:bo,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t,n={dy:r,y:e};return{x:()=>Y.runKernel(gu,n)}}};var Bk={kernelName:vo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=ft(_n(je(Te(e))),2/Math.sqrt(Math.PI));return{x:()=>ft(r,n)}}};var Vk={kernelName:wo,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(r,e)}}};var Gk={kernelName:Mi,inputsToSave:["input"],gradFunc:(r,t)=>{let[e]=t;return{input:()=>dt(r,e.shape)}}};var Wk={kernelName:Co,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(r,_n(e))}}};var Uk={kernelName:ko,gradFunc:r=>({x:()=>le(r)})};var jk={kernelName:So,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,s=ve(e.shape,n.shape);return{a:()=>{let l=Xt(r,Vt(n,"float32")),u=Qe(e.shape,s);return u.length>0?dt(ee(l,u),e.shape):l},b:()=>{let l=ft(r,Vt(e,"float32")),u=Qe(n.shape,s);u.length>0&&(l=dt(ee(l,u),n.shape));let p=Te(n);return je(Xt(l,Vt(p,"float32")))}}}};var qk={kernelName:Bi,inputsToSave:["x","mean","variance","scale"],gradFunc:(r,t,e)=>{let{varianceEpsilon:n}=e,[s,o,a,l]=t,u=l??fe(1),p=Qe(o.shape,s.shape),f=[];if(o.rank===1){for(let P=0;P<s.shape.length-1;++P)f.push(s.shape[P]);f.push(1)}let m=ie(s,o),d=ft(r,u),y=Vh(Ot(a,fe(n))),_=ft(ft(ft(y,y),y),fe(-.5));return{x:()=>o.rank===1?dt(ft(ft(r,Xs(dt(y,[1,1,1,o.shape[0]]),f)),u),s.shape):dt(ft(ft(r,y),u),s.shape),mean:()=>{let P=ft(ft(y,fe(-1)),d);return o.rank===1&&(P=ee(P,p)),dt(P,o.shape)},variance:()=>{let P=ft(ft(_,m),d);return o.rank===1&&(P=ee(P,p)),dt(P,o.shape)},scale:()=>{let P=ft(m,y),L=ft(r,P);return o.rank===1&&(L=ee(L,p)),dt(L,o.shape)},offset:()=>{let P=r;return o.rank===1&&(P=ee(P,p)),dt(P,o.shape)}}}};var Xk={kernelName:Vi,inputsToSave:["x","indices"],gradFunc:(r,t,e)=>{let[n,s]=t,{axis:o}=e,a=Ir(o,n.shape)[0];return{x:()=>{let u=n.shape,p=s.size,f=u.slice(0,a),m=f.length,d=u.slice(o,u.length).slice(1),y=d.length,_=Hk(0,m),v=Hk(m+1,m+1+y),C=Kk([f,[p],d]),N=dt(r,C),A=dt(s,[p]),B=Kk([[m],_,v]),P=Le(N,B),L=Yh(P,A,n.shape[a]),Z=dp(B);return L=Le(L,Z),L},indices:()=>s}}};function Hk(r,t){let e=[];for(let n=r;n<t;++n)e.push(n);return e}function Kk(r){let t=[];for(let e=0;e<r.length;++e)for(let n=0;n<r[e].length;++n)t.push(r[e][n]);return t}var Yk={kernelName:Io,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>le(e),b:()=>le(n)}}};var Zk={kernelName:Gi,gradFunc:r=>({x:()=>Vt(r,"float32")})};var Jk={kernelName:No,gradFunc:r=>({x:()=>le(r)})};var Qk={kernelName:To,gradFunc:r=>({x:()=>le(r)})};var t1={kernelName:Eo,gradFunc:r=>({x:()=>le(r)})};var e1={kernelName:Wi,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{alpha:s}=e,o=Kr(n,0);return{x:()=>Cr(o,r,ft(r,s))}}};var r1={kernelName:$o,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Xt(r,Ot(e,1))}}};var n1={kernelName:Ao,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Xt(r,Vt(e,"float32"))}}};var s1={kernelName:Nv,inputsToSave:[],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{axis:s}=e;return{logits:()=>{let o=!0,a=_n(n);return ie(r,ft(ee(r,s,o),a))}}}};function uM(r,t,e,n=5,s=1,o=1,a=.5){let l={x:r,y:t,dy:e},u={depthRadius:n,bias:s,alpha:o,beta:a};return Y.runKernel(vu,l,u)}var o1=Q({localResponseNormalizationBackprop_:uM});var i1={kernelName:Ui,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,s]=t,{depthRadius:o,bias:a,alpha:l,beta:u}=e;return{x:()=>o1(n,s,r,o,a,l,u)}}};function rm(r,t,e,n){return t.rank<e.rank&&(t=dt(t,Zs(t.shape,n))),r.rank<e.rank&&(r=dt(r,Zs(r.shape,n))),{x:()=>ft(r,Vt(ks(e,t),r.dtype))}}var Wx={kernelName:ji,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{reductionIndices:s}=n,o=t[0],a=t[1],l=Ir(s,o.shape),u=rm(r,a,o,l);return{x:()=>u.x()}}};var a1={kernelName:Do,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>ft(r,Vt(Zn(e,n),"float32")),b:()=>ft(r,Vt(Ph(e,n),"float32"))}}};function cM(r,t,e,n,s,o,a){let l=X(r,"dy","maxPool3dGrad"),u=X(t,"input","maxPool3dGrad"),p=X(e,"output","maxPool3dGrad"),f=l,m=u,d=p,y=!1;u.rank===4&&(y=!0,f=dt(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),m=dt(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=dt(p,[1,p.shape[0],p.shape[1],p.shape[2],p.shape[3]])),tt(f.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${f.rank}.`),tt(m.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${m.rank}.`),tt(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),a!=null&&tt(Be(o),()=>`Error in maxPool3dGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let _={dy:f,input:m,output:d},v={filterSize:n,strides:s,pad:o,dimRoundingMode:a},C=Y.runKernel(Cu,_,v);return y?dt(C,[C.shape[1],C.shape[2],C.shape[3],C.shape[4]]):C}var l1=Q({maxPool3dGrad_:cM});var u1={kernelName:Hi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,s]=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=e;return{x:()=>l1(r,n,s,o,a,l,u)}}};function pM(r,t,e,n,s,o,a){let l=X(r,"dy","maxPoolGrad"),u=X(t,"input","maxPoolGrad"),p=X(e,"output","maxPoolGrad");tt(u.rank===l.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${l.rank})`),tt(l.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),tt(u.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${u.rank}.`),a!=null&&tt(Be(o),()=>`Error in maxPoolGrad: pad must be an integer when using, dimRoundingMode ${a} but got pad ${o}.`);let f={dy:l,input:u,output:p},m={filterSize:n,strides:s,pad:o,dimRoundingMode:a};return Y.runKernel(wu,f,m)}var c1=Q({maxPoolGrad_:pM});var p1={kernelName:qi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n,s]=t,{filterSize:o,strides:a,pad:l}=e;return{x:()=>c1(r,n,s,o,a,l)}}};var f1={kernelName:Ki,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{axis:s}=e,o=Ir(s,n.shape),l=Nx(n.shape,o)[1],u=Je(l);return{x:()=>{let f=n.shape.slice();o.forEach(y=>{f[y]=1});let m=dt(r,f);return Xt(ft(m,Wn(n.shape,"float32")),u)}}}};var h1={kernelName:Xi,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(r,t,e)=>{let n=e,{axis:s}=n,[o,a]=t,l=Ir(s,o.shape),u=rm(r,a,o,l);return{x:()=>u.x()}}};var m1={kernelName:Ro,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t;return{a:()=>ft(r,Vt(Ys(e,n),"float32")),b:()=>ft(r,Vt(Kr(e,n),"float32"))}}};var d1={kernelName:Yi,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:s}=e,o=s.map(a=>a[0]);return{x:()=>ze(r,o,n.shape)}}};var g1={kernelName:Fo,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,s=ve(e.shape,n.shape);return{a:()=>{let l=Qe(e.shape,s);return l.length>0?dt(ee(r,l),e.shape):r},b:()=>{let l=ft(r,je(Ca(Xt(e,n)))),u=Qe(n.shape,s);return u.length>0?dt(ee(l,u),n.shape):l}}}};var x1={kernelName:Oo,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,s=ve(e.shape,n.shape);return{a:()=>{let l=ft(r,Vt(n,"float32")),u=Qe(e.shape,s);return u.length>0?dt(ee(l,u),e.shape):l},b:()=>{let l=ft(r,Vt(e,"float32")),u=Qe(n.shape,s);return u.length>0?dt(ee(l,u),n.shape):l}}}};var y1={kernelName:Zi,gradFunc:r=>({x:()=>je(r)})};var _1={kernelName:Qi,inputsToSave:["indices"],gradFunc:(r,t)=>{let e=t[0];return{indices:()=>lr(e.shape,"float32")}}};var b1={kernelName:Ji,gradFunc:r=>({x:()=>le(r)})};var v1={kernelName:ta,saveAllInputs:!0,gradFunc:(r,t,e)=>{let{axis:n}=e;return Rn(r,n).map(o=>()=>o)}};var Ux={kernelName:ea,inputsToSave:["x"],gradFunc:(r,t,e)=>{let n=t[0],{paddings:s}=e,o=s.map(a=>a[0]);return{x:()=>ze(r,o,n.shape)}}};var w1={kernelName:Po,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(r,t)=>{let[e,n,s]=t,o=e,a=n,l=ve(o.shape,a.shape);return{a:()=>{let f=Vt(a,"float32"),m=ft(r,ft(f,Jn(o,ie(f,fe(1))))),d=Qe(o.shape,l);return d.length>0&&(m=ee(m,d)),dt(m,o.shape)},b:()=>{let f=Kr(o,0),m=Cr(f,bn(o),le(o)),d=ft(r,ft(s,m)),y=Qe(a.shape,l);return y.length>0&&(d=ee(d,y)),dt(d,a.shape)}}}};var C1={kernelName:ra,inputsToSave:["x","alpha"],gradFunc:(r,t)=>{let[e,n]=t,s=Kr(e,0);return{x:()=>Cr(s,r,ft(r,n)),alpha:()=>{let o=Cr(s,le(r),ft(r,e)),a=Qe(n.shape,r.shape);return a.length>0&&(o=ee(o,a)),dt(o,n.shape)}}}};var k1={kernelName:_o,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,s=ve(e.shape,n.shape);return{a:()=>{let l=Xt(r,Vt(n,"float32")),u=Qe(e.shape,s);return u.length>0?dt(ee(l,u),e.shape):l},b:()=>{let l=ft(r,Vt(e,"float32")),u=Qe(n.shape,s);u.length>0&&(l=dt(ee(l,u),n.shape));let p=Te(n);return je(Xt(l,Vt(p,"float32")))}}}};var S1={kernelName:Lo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Xt(r,je(Te(e)))}}};var I1={kernelName:Mo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t,n=ft(Ys(e,6),Js(e));return{x:()=>ft(r,Vt(n,"float32"))}}};var N1={kernelName:zo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(r,Vt(Js(e),"float32"))}}};var T1={kernelName:na,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>dt(r,e.shape)}}};var E1={kernelName:oa,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,s={dy:r,images:n};return{images:()=>Y.runKernel(Tu,s,e)}}};var A1={kernelName:sa,inputsToSave:["images"],gradFunc:(r,t,e)=>{let[n]=t,s={dy:r,images:n};return{images:()=>Y.runKernel(Nu,s,e)}}};var $1={kernelName:ia,gradFunc:(r,t,e)=>{let{dims:n}=e,s=Ir(n,r.shape);return{x:()=>Qn(r,s)}}};var D1={kernelName:Bo,gradFunc:r=>({x:()=>le(r)})};var R1={kernelName:Vo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>je(Xt(r,ft(Jn(e,1.5),2)))}}};var F1={kernelName:aa,inputsToSave:["condition"],gradFunc:(r,t)=>{let[e]=t;return{condition:()=>Vt(le(e),"float32"),t:()=>ft(r,Vt(e,r.dtype)),e:()=>ft(r,Vt(Xu(e),r.dtype))}}};var O1={kernelName:Go,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>{let n=Kr(e,fe(0)),s=fe(Vx),o=fe(Gx),a=ft(r,o),l=ft(ft(r,s),_n(Vt(e,"float32")));return Cr(n,a,l)}}}};var P1={kernelName:qo,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(r,ft(e,ie(fe(1),e)))}}};var L1={kernelName:jo,gradFunc:r=>({x:()=>le(r)})};var z1={kernelName:Wo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(qu(Vt(e,"float32")),r)}}};var M1={kernelName:Uo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(Dh(Vt(e,"float32")),r)}}};var B1={kernelName:la,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{begin:s,size:o}=e,a=n.shape,[l,u]=vx(n,s,o),p=[];for(let f=0;f<r.rank;f++)p.push([l[f],a[f]-l[f]-u[f]]);return{x:()=>Ju(r,p)}}};var V1={kernelName:fa,outputsToSave:[!0],gradFunc:(r,t,e)=>{let[n]=t,{dim:s}=e,o=!0,a=ft(r,n);return{logits:()=>ie(a,ft(ee(a,[s],o),n))}}};var G1={kernelName:Ho,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(r,ii(e))}}};var jx={kernelName:ca,gradFunc:(r,t,e)=>{let{blockShape:n,paddings:s}=e;return{x:()=>Uu(r,n,s)}}};var qx={kernelName:pa,gradFunc:(r,t,e)=>{let{axis:n}=e;return{x:()=>ar(r,n)}}};var W1={kernelName:Ko,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Xt(r,ft(ur(Vt(e,"float32")),2))}}};var U1={kernelName:Eu,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(r,ft(Vt(e,"float32"),2))}}};var j1={kernelName:Xo,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,s=fe(2);return{a:()=>ft(r,ft(s,ie(e,n))),b:()=>ft(r,ft(s,ie(n,e)))}}};var q1={kernelName:Qo,gradFunc:r=>({x:()=>le(r)})};var H1={kernelName:Yo,inputsToSave:["a","b"],gradFunc:(r,t)=>{let[e,n]=t,s=ve(e.shape,n.shape);return{a:()=>{let l=r,u=Qe(e.shape,s);return u.length>0&&(l=ee(l,u)),dt(l,e.shape)},b:()=>{let l=r,u=Qe(n.shape,s);return u.length>0&&(l=ee(l,u)),dt(je(l),n.shape)}}}};var K1={kernelName:ua,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,s=n.shape.slice(),{axis:o}=e;Ir(o,n.shape).forEach(p=>{s[p]=1});let l=dt(r,s),u=ft(l,Wn(n.shape,"float32"));return{x:()=>u}}};var X1={kernelName:Zo,inputsToSave:["x"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>Xt(r,Te(qu(e)))}}};var Y1={kernelName:Jo,outputsToSave:[!0],gradFunc:(r,t)=>{let[e]=t;return{x:()=>ft(ie(fe(1),Te(e)),r)}}};var Z1={kernelName:Us,inputsToSave:["x"],gradFunc:(r,t,e)=>{let[n]=t,{reps:s}=e;return{x:()=>{let a=le(n);if(n.rank===1)for(let l=0;l<s[0];++l)a=Ot(a,ze(r,[l*n.shape[0]],[n.shape[0]]));else if(n.rank===2)for(let l=0;l<s[0];++l)for(let u=0;u<s[1];++u)a=Ot(a,ze(r,[l*n.shape[0],u*n.shape[1]],[n.shape[0],n.shape[1]]));else if(n.rank===3)for(let l=0;l<s[0];++l)for(let u=0;u<s[1];++u)for(let p=0;p<s[2];++p)a=Ot(a,ze(r,[l*n.shape[0],u*n.shape[1],p*n.shape[2]],[n.shape[0],n.shape[1],n.shape[2]]));else if(n.rank===4)for(let l=0;l<s[0];++l)for(let u=0;u<s[1];++u)for(let p=0;p<s[2];++p)for(let f=0;f<s[3];++f)a=Ot(a,ze(r,[l*n.shape[0],u*n.shape[1],p*n.shape[2],f*n.shape[3]],[n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${n.rank} tensors yet.`);return a}}}};var J1={kernelName:ha,gradFunc:(r,t,e)=>{let n=e,{perm:s}=n,o=dp(s);return{x:()=>Le(r,o)}}};var Q1={kernelName:ma,gradFunc:(r,t,e)=>{let n=e,{axis:s}=n;return{value:()=>Zr(r,s)}}};var tS={kernelName:da,inputsToSave:["segmentIds"],gradFunc:(r,t)=>{let[e]=t;return{x:()=>fM(r,e)}}};function fM(r,t){let e=Gn(t,le(t)),n=Hu(r,e),s=Zn(t,fe(0,"int32")),o=n.rank-s.rank;for(let l=0;l<o;++l)s=nn(s,l+1);s=fn(s,Wn(n.shape,"bool"));let a=le(n);return Cr(s,n,a)}var eS={kernelName:ga,gradFunc:r=>({x:()=>le(r)})};var hM=[em,ak,lk,uk,ck,pk,fk,hk,mk,dk,gk,xk,_k,vk,wk,Ck,kk,Sk,Ik,Nk,Tk,Ek,$k,Ak,Rk,Fk,Ok,Pk,Lk,zk,k1,Mk,Bk,Vk,Gk,Wk,jk,Uk,qk,Xk,Yk,Zk,Jk,Qk,t1,e1,r1,n1,s1,i1,Wx,Wx,a1,u1,p1,f1,h1,m1,d1,g1,x1,y1,_1,b1,v1,Ux,Ux,w1,C1,S1,I1,N1,T1,E1,A1,$1,D1,R1,F1,O1,P1,L1,z1,M1,B1,V1,G1,jx,jx,qx,qx,W1,j1,U1,q1,H1,K1,X1,Y1,Z1,J1,Q1,tS,eS];for(let r of hM)Ev(r);rt().prototype.abs=function(){return this.throwIfDisposed(),Ar(this)};rt().prototype.acos=function(){return this.throwIfDisposed(),Fw(this)};rt().prototype.acosh=function(){return this.throwIfDisposed(),Ow(this)};rt().prototype.add=function(r){return this.throwIfDisposed(),Ot(this,r)};rt().prototype.all=function(r,t){return this.throwIfDisposed(),Nh(this,r,t)};rt().prototype.any=function(r,t){return this.throwIfDisposed(),pp(this,r,t)};rt().prototype.argMax=function(r){return this.throwIfDisposed(),fp(this,r)};rt().prototype.argMin=function(r){return this.throwIfDisposed(),Pw(this,r)};rt().prototype.asScalar=function(){return this.throwIfDisposed(),tt(this.size===1,()=>"The array must have only 1 element."),dt(this,[])};rt().prototype.asType=function(r){return this.throwIfDisposed(),Vt(this,r)};rt().prototype.as1D=function(){return this.throwIfDisposed(),dt(this,[this.size])};rt().prototype.as2D=function(r,t){return this.throwIfDisposed(),dt(this,[r,t])};rt().prototype.as3D=function(r,t,e){return this.throwIfDisposed(),dt(this,[r,t,e])};rt().prototype.as4D=function(r,t,e,n){return this.throwIfDisposed(),dt(this,[r,t,e,n])};rt().prototype.as5D=function(r,t,e,n,s){return this.throwIfDisposed(),dt(this,[r,t,e,n,s])};rt().prototype.asin=function(){return this.throwIfDisposed(),Lw(this)};rt().prototype.asinh=function(){return this.throwIfDisposed(),zw(this)};rt().prototype.atan=function(){return this.throwIfDisposed(),Mw(this)};rt().prototype.atan2=function(r){return this.throwIfDisposed(),Bw(this,r)};rt().prototype.atanh=function(){return this.throwIfDisposed(),Vw(this)};rt().prototype.avgPool=function(r,t,e,n){return this.throwIfDisposed(),Wu(this,r,t,e,n)};rt().prototype.batchToSpaceND=function(r,t){return this.throwIfDisposed(),Uu(this,r,t)};rt().prototype.batchNorm=function(r,t,e,n,s){return this.throwIfDisposed(),ba(this,r,t,e,n,s)};rt().prototype.broadcastTo=function(r){return this.throwIfDisposed(),hp(this,r)};rt().prototype.cast=function(r){return this.throwIfDisposed(),Vt(this,r)};rt().prototype.ceil=function(){return this.throwIfDisposed(),Xw(this)};rt().prototype.clipByValue=function(r,t){return this.throwIfDisposed(),Hr(this,r,t)};rt().prototype.concat=function(r,t){return this.throwIfDisposed(),r instanceof Ae&&(r=[r]),ar([this,...r],t)};rt().prototype.conv1d=function(r,t,e,n,s,o){return this.throwIfDisposed(),Ah(this,r,t,e,n,s,o)};rt().prototype.conv2dTranspose=function(r,t,e,n,s){return this.throwIfDisposed(),$h(this,r,t,e,n,s)};rt().prototype.conv2d=function(r,t,e,n,s,o){return this.throwIfDisposed(),Bn(this,r,t,e,n,s,o)};rt().prototype.cos=function(){return this.throwIfDisposed(),qu(this)};rt().prototype.cosh=function(){return this.throwIfDisposed(),Dh(this)};rt().prototype.cumsum=function(r,t,e){return this.throwIfDisposed(),Rh(this,r,t,e)};rt().prototype.depthToSpace=function(r,t){return this.throwIfDisposed(),rC(this,r,t)};rt().prototype.depthwiseConv2d=function(r,t,e,n,s,o){return this.throwIfDisposed(),va(this,r,t,e,n,s,o)};rt().prototype.dilation2d=function(r,t,e,n,s){return this.throwIfDisposed(),nC(this,r,t,e,n,s)};rt().prototype.divNoNan=function(r){return this.throwIfDisposed(),sC(this,r)};rt().prototype.div=function(r){return this.throwIfDisposed(),Xt(this,r)};rt().prototype.dot=function(r){return this.throwIfDisposed(),oC(this,r)};rt().prototype.elu=function(){return this.throwIfDisposed(),wa(this)};rt().prototype.equal=function(r){return this.throwIfDisposed(),ks(this,r)};rt().prototype.erf=function(){return this.throwIfDisposed(),iC(this)};rt().prototype.exp=function(){return this.throwIfDisposed(),_n(this)};rt().prototype.expandDims=function(r){return this.throwIfDisposed(),nn(this,r)};rt().prototype.expm1=function(){return this.throwIfDisposed(),aC(this)};rt().prototype.fft=function(){return this.throwIfDisposed(),Kh(this)};rt().prototype.flatten=function(){return this.throwIfDisposed(),dt(this,[this.size])};rt().prototype.floor=function(){return this.throwIfDisposed(),Ca(this)};rt().prototype.floorDiv=function(r){return this.throwIfDisposed(),Ih(this,r)};rt().prototype.gather=function(r,t){return this.throwIfDisposed(),Hu(this,r,t)};rt().prototype.greaterEqual=function(r){return this.throwIfDisposed(),Zn(this,r)};rt().prototype.greater=function(r){return this.throwIfDisposed(),Kr(this,r)};rt().prototype.ifft=function(){return this.throwIfDisposed(),vp(this)};rt().prototype.irfft=function(){return this.throwIfDisposed(),BC(this)};rt().prototype.isFinite=function(){return this.throwIfDisposed(),lC(this)};rt().prototype.isInf=function(){return this.throwIfDisposed(),uC(this)};rt().prototype.isNaN=function(){return this.throwIfDisposed(),cC(this)};rt().prototype.leakyRelu=function(r){return this.throwIfDisposed(),Ku(this,r)};rt().prototype.lessEqual=function(r){return this.throwIfDisposed(),Ys(this,r)};rt().prototype.less=function(r){return this.throwIfDisposed(),Ph(this,r)};rt().prototype.localResponseNormalization=function(r,t,e,n){return this.throwIfDisposed(),pC(this,r,t,e,n)};rt().prototype.logSigmoid=function(){return this.throwIfDisposed(),hC(this)};rt().prototype.logSoftmax=function(r){return this.throwIfDisposed(),Lh(this,r)};rt().prototype.logSumExp=function(r,t){return this.throwIfDisposed(),dC(this,r,t)};rt().prototype.log=function(){return this.throwIfDisposed(),bn(this)};rt().prototype.log1p=function(){return this.throwIfDisposed(),fC(this)};rt().prototype.logicalAnd=function(r){return this.throwIfDisposed(),fn(this,r)};rt().prototype.logicalNot=function(){return this.throwIfDisposed(),Xu(this)};rt().prototype.logicalOr=function(r){return this.throwIfDisposed(),zh(this,r)};rt().prototype.logicalXor=function(r){return this.throwIfDisposed(),gC(this,r)};rt().prototype.matMul=function(r,t,e){return this.throwIfDisposed(),Ve(this,r,t,e)};rt().prototype.maxPool=function(r,t,e,n){return this.throwIfDisposed(),Yu(this,r,t,e,n)};rt().prototype.max=function(r,t){return this.throwIfDisposed(),Xr(this,r,t)};rt().prototype.maximum=function(r){return this.throwIfDisposed(),Gn(this,r)};rt().prototype.mean=function(r,t){return this.throwIfDisposed(),hr(this,r,t)};rt().prototype.min=function(r,t){return this.throwIfDisposed(),ml(this,r,t)};rt().prototype.minimum=function(r){return this.throwIfDisposed(),Zu(this,r)};rt().prototype.mirrorPad=function(r,t){return this.throwIfDisposed(),yC(this,r,t)};rt().prototype.mod=function(r){return this.throwIfDisposed(),_C(this,r)};rt().prototype.mul=function(r){return this.throwIfDisposed(),ft(this,r)};rt().prototype.neg=function(){return this.throwIfDisposed(),je(this)};rt().prototype.norm=function(r,t,e){return this.throwIfDisposed(),nc(this,r,t,e)};rt().prototype.notEqual=function(r){return this.throwIfDisposed(),dl(this,r)};rt().prototype.oneHot=function(r,t=1,e=0){return this.throwIfDisposed(),up(this,r,t,e)};rt().prototype.onesLike=function(){return this.throwIfDisposed(),Gr(this)};rt().prototype.pad=function(r,t){return this.throwIfDisposed(),Ju(this,r,t)};rt().prototype.pool=function(r,t,e,n,s){return this.throwIfDisposed(),bC(this,r,t,e,n,s)};rt().prototype.pow=function(r){return this.throwIfDisposed(),Jn(this,r)};rt().prototype.prelu=function(r){return this.throwIfDisposed(),tc(this,r)};rt().prototype.prod=function(r,t){return this.throwIfDisposed(),vC(this,r,t)};rt().prototype.reciprocal=function(){return this.throwIfDisposed(),LC(this)};rt().prototype.relu=function(){return this.throwIfDisposed(),Ss(this)};rt().prototype.relu6=function(){return this.throwIfDisposed(),Bh(this)};rt().prototype.reshapeAs=function(r){return this.throwIfDisposed(),dt(this,r.shape)};rt().prototype.reshape=function(r){return this.throwIfDisposed(),dt(this,r)};rt().prototype.resizeBilinear=function(r,t,e){return this.throwIfDisposed(),QC(this,r,t,e)};rt().prototype.resizeNearestNeighbor=function(r,t,e){return this.throwIfDisposed(),tk(this,r,t,e)};rt().prototype.reverse=function(r){return this.throwIfDisposed(),Qn(this,r)};rt().prototype.rfft=function(){return this.throwIfDisposed(),VC(this)};rt().prototype.round=function(){return this.throwIfDisposed(),zC(this)};rt().prototype.rsqrt=function(){return this.throwIfDisposed(),Vh(this)};rt().prototype.selu=function(){return this.throwIfDisposed(),Gh(this)};rt().prototype.separableConv2d=function(r,t,e,n,s,o){return this.throwIfDisposed(),Wh(this,r,t,e,n,s,o)};rt().prototype.sigmoid=function(){return this.throwIfDisposed(),ii(this)};rt().prototype.sign=function(){return this.throwIfDisposed(),MC(this)};rt().prototype.sin=function(){return this.throwIfDisposed(),Uh(this)};rt().prototype.sinh=function(){return this.throwIfDisposed(),jh(this)};rt().prototype.slice=function(r,t){return this.throwIfDisposed(),ze(this,r,t)};rt().prototype.softmax=function(r){return this.throwIfDisposed(),ec(this,r)};rt().prototype.softplus=function(){return this.throwIfDisposed(),ka(this)};rt().prototype.spaceToBatchND=function(r,t){return this.throwIfDisposed(),Qu(this,r,t)};rt().prototype.split=function(r,t){return this.throwIfDisposed(),Yr(this,r,t)};rt().prototype.sqrt=function(){return this.throwIfDisposed(),ur(this)};rt().prototype.square=function(){return this.throwIfDisposed(),Te(this)};rt().prototype.squaredDifference=function(r){return this.throwIfDisposed(),GC(this,r)};rt().prototype.squeeze=function(r){return this.throwIfDisposed(),rc(this,r)};rt().prototype.stack=function(r,t){this.throwIfDisposed();let e=r instanceof Ae?[this,r]:[this,...r];return Zr(e,t)};rt().prototype.step=function(r){return this.throwIfDisposed(),Js(this,r)};rt().prototype.stridedSlice=function(r,t,e,n,s,o,a,l){return this.throwIfDisposed(),WC(this,r,t,e,n,s,o,a,l)};rt().prototype.sub=function(r){return this.throwIfDisposed(),ie(this,r)};rt().prototype.sum=function(r,t){return this.throwIfDisposed(),ee(this,r,t)};rt().prototype.tan=function(){return this.throwIfDisposed(),UC(this)};rt().prototype.tanh=function(){return this.throwIfDisposed(),Eh(this)};rt().prototype.tile=function(r){return this.throwIfDisposed(),Xs(this,r)};rt().prototype.toBool=function(){return this.throwIfDisposed(),Vt(this,"bool")};rt().prototype.toFloat=function(){return this.throwIfDisposed(),Vt(this,"float32")};rt().prototype.toInt=function(){return this.throwIfDisposed(),Vt(this,"int32")};rt().prototype.topk=function(r,t){return this.throwIfDisposed(),jC(this,r,t)};rt().prototype.transpose=function(r){return this.throwIfDisposed(),Le(this,r)};rt().prototype.unique=function(r){return this.throwIfDisposed(),qC(this,r)};rt().prototype.unsortedSegmentSum=function(r,t){return this.throwIfDisposed(),Yh(this,r,t)};rt().prototype.unstack=function(r){return this.throwIfDisposed(),Rn(this,r)};rt().prototype.where=function(r,t){return this.throwIfDisposed(),Cr(r,this,t)};rt().prototype.zerosLike=function(){return this.throwIfDisposed(),le(this)};var Hx;function Sr(){return Hx==null&&(Hx=Rw().epsilon()),Hx}function mn(){return"channelsLast"}var Fn=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Fn.prototype)}},on=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,on.prototype)}},ct=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,ct.prototype)}},ue=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,ue.prototype)}},Ep=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Ep.prototype)}},Kx=class extends Error{constructor(t){super(t);Object.setPrototypeOf(this,Kx.prototype)}};function ts(r,t){if(Array.isArray(r)){let e=[];for(let n=0;n<t;n++)e=e.concat(r);return e}else{let e=new Array(t);return e.fill(r),e}}function Un(r,t){if(!r)throw new Ep(t)}function Xx(r,t){let e=0;for(let n of r)n===t&&e++;return e}function Or(r){return r.length===1?r[0]:r}function Xe(r){return Array.isArray(r)?r:[r]}function es(r){let e=r.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function li(r){return r.length<=1||r.indexOf("_")===-1?r:r.replace(/[_]+(\w|$)/g,(t,e)=>e.toUpperCase())}var rs={};function ic(r){if(r==null)return null;let t={};return t.className=r.getClassName(),t.config=r.getConfig(),t}function Yx(r){if(!(r==null||typeof r!="object"))if(Array.isArray(r))r.forEach(t=>Yx(t));else{let t=Object.keys(r);for(let e of t){let n=r[e];n!=null&&typeof n=="object"&&(!Array.isArray(n)&&n.type==="ndarray"&&typeof n.value=="number"?r[e]=n.value:Yx(n))}}}function Qs(r,t={},e={},n="object",s=!1){if(typeof r=="string"){let o=r,a;if(o in e)a=e[o];else if(o in rs)a=rs[o];else if(a=t[o],a==null)throw new ct(`Unknown ${n}: ${r}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{let o=r;if(o.className==null||o.config==null)throw new ct(`${n}: Improper config format: ${JSON.stringify(o)}.
'className' and 'config' must set.`);let a=o.className,l,u;if(a in e?[l,u]=e[a]:a in rs?[l,u]=rs.className:a in t&&([l,u]=t[a]),l==null)throw new ct(`Unknown ${n}: ${a}. This may be due to one of the following reasons:
1. The ${n} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${n} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(u!=null){let p={};for(let y of Object.keys(rs))p[y]=rs[y];for(let y of Object.keys(e))p[y]=e[y];let f=o.config;f.customObjects=p;let m=Object.assign({},rs);for(let y of Object.keys(e))rs[y]=e[y];Yx(o.config);let d=u(l,o.config,e,s);return rs=Object.assign({},m),d}else{let p=Object.assign({},rs);for(let m of Object.keys(e))rs[m]=e[m];let f=new l(o.config);return rs=Object.assign({},p),f}}}function mM(r,t){return r<t?-1:r>t?1:0}function Ap(r,t){return-1*mM(r,t)}function ns(r){if(r==null)return r;let t=[];for(let e of r)t.indexOf(e)===-1&&t.push(e);return t}function rS(r){if(r==null)throw new ct(`Invalid value in obj: ${JSON.stringify(r)}`);for(let t in r)if(r.hasOwnProperty(t))return!1;return!0}function to(r,t,e){if(e!=null&&r.indexOf(e)<0)throw new ct(`${e} is not a valid ${t}.  Valid values are ${r} or null/undefined.`)}function nm(r,t,e=0,n=Infinity){return Un(e>=0),Un(n>=e),Array.isArray(r)&&r.length>=e&&r.length<=n&&r.every(s=>typeof s===t)}function _r(r,t){Array.isArray(r)?(E.assert(r.length>0,()=>`${t} is unexpectedly an empty array.`),r.forEach((e,n)=>_r(e,`element ${n+1} of ${t}`))):E.assert(Number.isInteger(r)&&r>0,()=>`Expected ${t} to be a positive integer, but got ${nS(r)}.`)}function nS(r){return r===null?"null":Array.isArray(r)?"["+r.map(t=>nS(t)).join(",")+"]":typeof r=="string"?`"${r}"`:`${r}`}function sS(r,t){let e=E.now(),n;return(...o)=>{let a=E.now();return a-e<t||(e=a,n=r(...o)),n}}function sm(r){return r==="relu"?"relu":r==="linear"?"linear":r==="elu"?"elu":null}function Zx(r,t){return _t(()=>ur(ee(ft(r,r),t,!0)))}var ac=class extends At.Serializable{getConfig(){return{}}},om=class extends ac{constructor(t){super();this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return _t(()=>{let e=Zx(t,this.axis),n=Hr(e,0,this.maxValue);return ft(t,Xt(n,Ot(Sr(),e)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}};om.className="MaxNorm";At.registerClass(om);var im=class extends ac{constructor(t){super();this.defaultAxis=0,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return _t(()=>Xt(t,Ot(Sr(),Zx(t,this.axis))))}getConfig(){return{axis:this.axis}}};im.className="UnitNorm";At.registerClass(im);var am=class extends ac{apply(t){return Ss(t)}};am.className="NonNeg";At.registerClass(am);var lm=class extends ac{constructor(t){super();this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=t.minValue!=null?t.minValue:this.defaultMinValue,this.maxValue=t.maxValue!=null?t.maxValue:this.defaultMaxValue,this.rate=t.rate!=null?t.rate:this.defaultRate,this.axis=t.axis!=null?t.axis:this.defaultAxis}apply(t){return _t(()=>{let e=Zx(t,this.axis),n=Ot(ft(this.rate,Hr(e,this.minValue,this.maxValue)),ft(1-this.rate,e));return ft(t,Xt(n,Ot(Sr(),e)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}};lm.className="MinMaxNorm";At.registerClass(lm);var oS={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function mr(r){return ic(r)}function iS(r,t={}){return Qs(r,At.SerializationMap.getMap().classNameMap,t,"constraint")}function dr(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in oS?oS[r]:r,config:{}};return iS(e)}else return r instanceof ac?r:iS(r)}var aS=["channelsFirst","channelsLast"],lS=["nearest","bilinear"],uS=["valid","same","causal"],cS=["max","avg"],pS=["sum","mul","concat","ave"];var lc=new Map;function fr(r){to(aS,"DataFormat",r)}function fS(r){to(lS,"InterpolationFormat",r)}function dn(r){to(uS,"PaddingMode",r)}function Jx(r){to(cS,"PoolMode",r)}var $p=[],hS="/";function Ns(r,t){$p.push(r);try{let e=t();return $p.pop(),e}catch(e){throw $p.pop(),e}}function gM(){return $p.length===0?"":$p.join(hS)+hS}function um(r){if(!mS(r))throw new Error("Not a valid tensor name: '"+r+"'");return gM()+r}function cm(r){if(!mS(r))throw new Error("Not a valid tensor name: '"+r+"'");lc.has(r)||lc.set(r,0);let t=lc.get(r);if(lc.set(r,lc.get(r)+1),t>0){let e=`${r}_${t}`;return lc.set(e,1),e}else return r}var xM=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function mS(r){return!!r.match(xM)}function dS(r){return r===parseInt(r.toString(),10)}function ss(r,t,e){t==null&&(t=0),e==null&&(e=r.length);let n=1;for(let s=t;s<e;++s)n*=r[s];return n}function gS(r){return r=Array.isArray(r)?new Float32Array(r):r,Is(r)}function Cl(r){return ml(gS(r)).dataSync()[0]}function Ts(r){return Xr(gS(r)).dataSync()[0]}function an(r,t){if(t<r)throw new ct(`end (${t}) < begin (${r}) is forbidden.`);let e=[];for(let n=r;n<t;++n)e.push(n);return e}function ui(r,t){return r.asType(t)}function ci(r,t=-1){let e=r.shape.slice();return t<0&&(t=e.length+t+1),e.splice(t,0,1),r.reshape(e)}function xS(r,t){return _t(()=>{if(r.shape.length!==2)throw new ct(`repeat() expects a rank-2 tensor, but received a rank-${r.shape.length} tensor.`);let e=ci(r,1);return pm(e,[1,t,1])})}function yS(r){let t=[ss(r.shape)];return r.reshape(t)}function _S(r){if(r.rank<=1)throw new ct(`batchFlatten requires a minimum rank of 2. Got rank: ${r.rank}.`);let t=[r.shape[0],ss(r.shape,1)];return r.reshape(t)}function pi(r,t,e){return _t(()=>{switch(r.rank){case 1:return qh(r,t,e);case 2:return Mx(r,[t,0],[e,r.shape[1]]);case 3:return Hh(r,[t,0,0],[e,r.shape[1],r.shape[2]]);case 4:return bp(r,[t,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3]]);case 5:return ze(r,[t,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4]]);case 6:return ze(r,[t,0,0,0,0,0],[e,r.shape[1],r.shape[2],r.shape[3],r.shape[4],r.shape[5]]);default:throw new ct(`sliceAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Qx(r,t,e){return _t(()=>{switch(r.rank){case 1:return qh(r,t,e);case 2:return Mx(r,[0,t],[r.shape[0],e]);case 3:return Hh(r,[0,0,t],[r.shape[0],r.shape[1],e]);case 4:return bp(r,[0,0,0,t],[r.shape[0],r.shape[1],r.shape[2],e]);default:throw new ct(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function Dp(r,t,e,n){return _t(()=>{switch(r.rank){case 1:return qh(r,t,e);case 2:switch(n){case 1:return pi(r,t,e);case 2:return Qx(r,t,e);default:throw new ct(`The axis is not within the rank of the tensor ${n}`)}case 3:switch(n){case 1:return pi(r,t,e);case 2:return Hh(r,[0,t,0],[r.shape[0],e,r.shape[2]]);case 3:return Qx(r,t,e);default:throw new ct(`The axis is not within the rank of the tensor ${n}`)}case 4:switch(n){case 1:return pi(r,t,e);case 2:return bp(r,[0,t,0,0],[r.shape[0],e,r.shape[2],r.shape[3]]);case 3:return bp(r,[0,0,t,0],[r.shape[0],r.shape[1],e,r.shape[3]]);case 4:return Qx(r,t,e);default:throw new ct(`The axis is not within the rank of the tensor ${n}`)}default:throw new ct(`sliceAlongLastAxis() received an unsupported tensor rank: ${r.rank}`)}})}function uc(r,t=-1){let e;return t<0&&(e=r[0].rank,e!==0?t=e:t=0),t===r[0].rank&&(t=-1),ar(r,t)}function ty(r,t){switch(r.rank){case 1:return Yw([r,t]);case 2:return Zw([r,t],0);case 3:return Jw([r,t],0);case 4:return Qw([r,t],0);default:throw new ct(`concatAlongFirstAxis() received an unsupported tensor rank: ${r.rank}`)}}function pm(r,t){if(Array.isArray(t)||(t=[t]),r.rank!==t.length)throw new ct(`The length of input n (${t.length}) does not match the number of dimensions in input x (${r.rank})`);return Xs(r,t)}function cc(r,t=0,e=1,n,s){return Lx(r,t,e,n,s)}function os(r,t,e,n){if(r.rank<2||t.rank<2)throw new ue(`dot requires both inputs to be rank >= 2 but got x shape = ${r.shape} and y shape = ${t.shape}`);if(t.rank>=3){let s=r.shape.slice(-1)[0],o=t.shape.slice(-2)[0];if(s!==o)throw new ue(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${r.shape} and  y shape = ${t.shape}`)}if(r.rank===2&&t.rank===2){let s=!1,o=!1;return oc.matMul({a:r,b:t,transposeA:s,transposeB:o,bias:n?ey(r.rank,n,mn()):null,activation:e})}else{let s=r.shape.slice(),o=s.pop();r=r.reshape([-1,o]);let a=t.shape.slice(),l=a.pop(),u=a.pop(),p=[...a,l],f=Array.from({length:t.rank},(_,v)=>v===0?t.rank-2:v<=t.rank-2?v-1:v);t=t.transpose(f).reshape([u,-1]);let m=[...s,...p],d=!1,y=!1;return oc.matMul({a:r,b:t,transposeA:d,transposeB:y,bias:n?ey(r.rank,n,mn()):null,activation:e}).reshape(m)}}function fm(r,t,e){return _t(()=>(Array.isArray(t)?t=Is(t,"int32"):t=t.toInt(),Hu(r,t,e)))}function kl(r){return ft(r,r)}function ey(r,t,e){let n=t.shape;if(t.rank!==1&&t.rank!==r)throw new ct(`Unexpected bias dimensions: ${t.rank}; expected it to be 1 or ${r}`);if(r===5){if(e==="channelsFirst")return n.length===1?t.reshape([1,n[0],1,1,1]):t.reshape([1,n[3],n[0],n[1],n[2]]);if(e==="channelsLast")return n.length===1?t.reshape([1,1,1,1,n[0]]):t.reshape([1].concat(n))}else if(r===4){if(e==="channelsFirst")return n.length===1?t.reshape([1,n[0],1,1]):t.reshape([1,n[2],n[0],n[1]]);if(e==="channelsLast")return n.length===1?t.reshape([1,1,1,n[0]]):t.reshape([1].concat(n))}else if(r===3){if(e==="channelsFirst")return n.length===1?t.reshape([1,n[0],1]):t.reshape([1,n[1],n[0]]);if(e==="channelsLast")return n.length===1?t.reshape([1,1,n[0]]):t.reshape([1].concat(n))}else if(r<3)return t;throw new ct(`Unsupported input rank by biasAdd: ${t.rank}`)}function vn(r,t,e){return _t(()=>(e==null&&(e=mn()),fr(e),r.add(ey(r.rank,t,e))))}function bS(r,t=1){if(t!==1)throw new ue(`Support for alpha values other than 1 (${t}) is not implemented yet.`);return wa(r)}function vS(r){return _t(()=>Xt(r,Ar(r).add(1)))}function hm(r,t,e,n){return _t(()=>YC(r,t,e,n))}function wS(r){return _t(()=>{let t=Ot(.5,ft(.2,r));return Hr(t,0,1)})}function Ia(r,t,e=!1){return e?r():t()}var CS=["fanIn","fanOut","fanAvg"],kS=["normal","uniform","truncatedNormal"];function yM(r){to(CS,"FanMode",r)}function _M(r){to(kS,"Distribution",r)}var wn=class extends At.Serializable{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}},mm=class extends wn{apply(t,e){return lr(t,e)}};mm.className="Zeros";At.registerClass(mm);var pc=class extends wn{apply(t,e){return Wn(t,e)}};pc.className="Ones";At.registerClass(pc);var dm=class extends wn{constructor(t){super();if(typeof t!="object")throw new ct(`Expected argument of type ConstantConfig but got ${t}`);if(t.value===void 0)throw new ct(`config must have value set but got ${t}`);this.value=t.value}apply(t,e){return _t(()=>ft(fe(this.value),Wn(t,e)))}getConfig(){return{value:this.value}}};dm.className="Constant";At.registerClass(dm);var gm=class extends wn{constructor(t){super();this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=t.minval||this.DEFAULT_MINVAL,this.maxval=t.maxval||this.DEFAULT_MAXVAL,this.seed=t.seed}apply(t,e){return Sa(t,this.minval,this.maxval,e)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}};gm.className="RandomUniform";At.registerClass(gm);var xm=class extends wn{constructor(t){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new ue(`randomNormal does not support dType ${e}.`);return cc(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};xm.className="RandomNormal";At.registerClass(xm);var ym=class extends wn{constructor(t){super();this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=t.mean||this.DEFAULT_MEAN,this.stddev=t.stddev||this.DEFAULT_STDDEV,this.seed=t.seed}apply(t,e){if(e=e||"float32",e!=="float32"&&e!=="int32")throw new ue(`truncatedNormal does not support dType ${e}.`);return Xh(t,this.mean,this.stddev,e,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}};ym.className="TruncatedNormal";At.registerClass(ym);var _m=class extends wn{constructor(t){super();this.gain=t.gain!=null?t.gain:1}apply(t,e){return _t(()=>{if(t.length!==2||t[0]!==t[1])throw new ct("Identity matrix initializer can only be used for 2D square matrices.");return ft(this.gain,mp(t[0]))})}getConfig(){return{gain:this.gain}}};_m.className="Identity";At.registerClass(_m);function bM(r,t="channelsLast"){let e,n;if(fr(t),r.length===2)e=r[0],n=r[1];else if([3,4,5].indexOf(r.length)!==-1){if(t==="channelsFirst"){let s=ss(r,2);e=r[1]*s,n=r[0]*s}else if(t==="channelsLast"){let s=ss(r,0,r.length-2);e=r[r.length-2]*s,n=r[r.length-1]*s}}else{let s=ss(r);e=Math.sqrt(s),n=Math.sqrt(s)}return[e,n]}var gn=class extends wn{constructor(t){super();if(t.scale<0)throw new ct(`scale must be a positive float. Got: ${t.scale}`);this.scale=t.scale==null?1:t.scale,this.mode=t.mode==null?"fanIn":t.mode,yM(this.mode),this.distribution=t.distribution==null?"normal":t.distribution,_M(this.distribution),this.seed=t.seed}apply(t,e){let n=bM(t),s=n[0],o=n[1],a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,s):this.mode==="fanOut"?a/=Math.max(1,o):a/=Math.max(1,(s+o)/2),this.distribution==="normal"){let l=Math.sqrt(a);if(e=e||"float32",e!=="float32"&&e!=="int32")throw new ue(`${this.getClassName()} does not support dType ${e}.`);return Xh(t,0,l,e,this.seed)}else{let l=Math.sqrt(3*a);return Sa(t,-l,l,e)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};gn.className="VarianceScaling";At.registerClass(gn);var Rp=class extends gn{constructor(t){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return gn.className}};Rp.className="GlorotUniform";At.registerClass(Rp);var Fp=class extends gn{constructor(t){super({scale:1,mode:"fanAvg",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return gn.className}};Fp.className="GlorotNormal";At.registerClass(Fp);var Op=class extends gn{constructor(t){super({scale:2,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return gn.className}};Op.className="HeNormal";At.registerClass(Op);var Pp=class extends gn{constructor(t){super({scale:2,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return gn.className}};Pp.className="HeUniform";At.registerClass(Pp);var Lp=class extends gn{constructor(t){super({scale:1,mode:"fanIn",distribution:"normal",seed:t==null?null:t.seed})}getClassName(){return gn.className}};Lp.className="LeCunNormal";At.registerClass(Lp);var zp=class extends gn{constructor(t){super({scale:1,mode:"fanIn",distribution:"uniform",seed:t==null?null:t.seed})}getClassName(){return gn.className}};zp.className="LeCunNormal";At.registerClass(zp);var bm=class extends wn{constructor(t){super();if(this.DEFAULT_GAIN=1,this.gain=t.gain==null?this.DEFAULT_GAIN:t.gain,this.seed=t.seed,this.seed!=null)throw new ue("Random seed is not implemented for Orthogonal Initializer yet.")}apply(t,e){return _t(()=>{if(t.length<2)throw new ue("Shape must be at least 2D.");t[0]*t[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${t[0]*t[1]}) elements: Slowness may result.`);let n=t[0]>t[1]?[t[1],t[0]]:t,s=cc(n,0,1,"float32"),o=ok.gramSchmidt(s);return t[0]>t[1]&&(o=o.transpose()),ft(this.gain,o)})}getConfig(){return{gain:this.gain,seed:this.seed}}};bm.className="Orthogonal";At.registerClass(bm);var SS={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function IS(r,t={}){return Qs(r,At.SerializationMap.getMap().classNameMap,t,"initializer")}function tr(r){return ic(r)}function Ke(r){if(typeof r=="string"){let t=r in SS?SS[r]:r;if(t==="GlorotNormal")return new Fp;if(t==="GlorotUniform")return new Rp;if(t==="HeNormal")return new Op;if(t==="HeUniform")return new Pp;if(t==="LeCunNormal")return new Lp;if(t==="LeCunUniform")return new zp;{let e={};return e.className=t,e.config={},IS(e)}}else return r instanceof wn?r:IS(r)}var wM=0;function vm(){return wM++}var wm={};function Na(r=""){return r in wm||(wm[r]=0),wm[r]+=1,r+wm[r].toString()}function Cm(r){return Array.isArray(r)&&Array.isArray(r[0])}function fc(r){return r.length===0?[]:Array.isArray(r[0])?r:[r]}function xe(r){let t;if(Array.isArray(r)){if(r.length!==1)throw new ct(`Expected Tensor length to be 1; got ${r.length}`);t=r[0]}else t=r;return t}function De(r){if(Array.isArray(r)&&Array.isArray(r[0])){if(r.length===1)return r=r,r[0];throw new ct(`Expected exactly 1 Shape; got ${r.length}`)}else return r}function hc(r){let t=0;for(let e of r)e.shape.length===0?t+=1:t+=e.shape.reduce((n,s)=>n*s);return t}var NS="Variable",km=class{constructor(t,e="float32",n=NS,s=!0,o=null){this.dtype=e??"float32",this.shape=t.shape,this.id=vm(),n=n??NS,this.originalName=um(n),this.name=cm(this.originalName),this.trainable_=s,this.constraint=o,this.val=HC(t,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(t){return this.assertNotDisposed(),CM(this.val,t),this.val.id!==t.id&&(this.val.assign(t),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(t){this.trainable_=t,this.val.trainable=t}};function CM(r,t){if(r.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(r.shape)+" vs. "+JSON.stringify(t.shape))}function Mp(r){return r.map(t=>t.read())}function mc(r){r.forEach(t=>{t[0].write(t[1])})}var cr=class{constructor(t){this.dtype=t.dtype,this.shape=t.shape,t.shape!=null?this.ndim=t.shape.length:this.ndim=t.ndim,this.maxNDim=t.maxNDim,this.minNDim=t.minNDim,this.axes=t.axes||{}}},xn=class{constructor(t,e,n,s,o,a,l){this.dtype=t,this.shape=e,this.sourceLayer=n,this.inputs=s,this.callArgs=o,this.outputTensorIndex=l,this.id=vm(),a!=null&&(this.originalName=um(a),this.name=cm(this.originalName)),this.rank=e.length}},kM=0,Ta=class{constructor(t,e){this.callArgs=e,this.id=kM++,this.outboundLayer=t.outboundLayer,this.inboundLayers=t.inboundLayers,this.nodeIndices=t.nodeIndices,this.tensorIndices=t.tensorIndices,this.inputTensors=t.inputTensors,this.outputTensors=t.outputTensors,this.inputMasks=t.inputMasks,this.outputMasks=t.outputMasks,this.inputShapes=t.inputShapes,this.outputShapes=t.outputShapes;for(let n of t.inboundLayers)n!=null&&n.outboundNodes.push(this);t.outboundLayer.inboundNodes.push(this)}getConfig(){let t=[];for(let e of this.inboundLayers)e!=null?t.push(e.name):t.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:t,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}},SM=0,_e=class extends At.Serializable{constructor(t={}){super();this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=SM++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let e=t.name;if(!e){let n=this.getClassName();e=es(n)+"_"+Na(n)}if(this.name=e,this.trainable_=t.trainable==null?!0:t.trainable,t.inputShape!=null||t.batchInputShape!=null){let n;if(t.batchInputShape!=null)n=t.batchInputShape;else if(t.inputShape!=null){let o=null;t.batchSize!=null&&(o=t.batchSize),n=[o].concat(t.inputShape)}this.batchInputShape=n;let s=t.dtype;s==null&&(s=t.inputDType),s==null&&(s="float32"),this.dtype=s}t.weights!=null?this.initialWeights=t.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(t,e){return t.name+"_ib-"+e.toString()}getNodeAtIndex(t,e){if(this.inboundNodes.length===0)throw new on(`The layer has never been called and thus has no defined ${e}.`);if(this.inboundNodes.length<=t)throw new ct(`Asked to get ${e} at node ${t}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[t]}getInputAt(t){return Or(this.getNodeAtIndex(t,"input").inputTensors)}getOutputAt(t){return Or(this.getNodeAtIndex(t,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new Fn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new Fn(`Layer ${this.name} is not connected, no input to return.`);return Or(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new Fn(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new Fn(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Or(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(t=>t())}get updates(){return this._updates}get built(){return this._built}set built(t){this._built=t}get trainable(){return this.trainable_}set trainable(t){this._trainableWeights.forEach(e=>e.trainable=t),this.trainable_=t}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(t=>t.trainable):[]}set trainableWeights(t){this._trainableWeights=t}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(t=>!t.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(t){this._nonTrainableWeights=t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(t){if(t=Xe(t),this.inputSpec==null||this.inputSpec.length===0)return;let e=Xe(this.inputSpec);if(t.length!==e.length)throw new ct(`Layer ${this.name} expects ${e.length} inputs, but it received ${t.length} input tensors. Input received: ${t}`);for(let n=0;n<t.length;n++){let s=t[n],o=e[n];if(o==null)continue;let a=s.rank;if(o.ndim!=null&&a!==o.ndim)throw new ct(`Input ${n} is incompatible with layer ${this.name}: expected ndim=${o.ndim}, found ndim=${a}`);if(o.maxNDim!=null&&a>o.maxNDim)throw new ct(`Input ${n} is incompatible with layer ${this.name}: expected max_ndim=${o.maxNDim}, found ndim=${a}`);if(o.minNDim!=null&&a<o.minNDim)throw new ct(`Input ${n} is incompatible with layer ${this.name}: expected min_ndim=${o.minNDim}, found ndim=${a}.`);if(o.dtype!=null&&s.dtype!==o.dtype)throw new ct(`Input ${n} is incompatible with layer ${this.name} : expected dtype=${o.dtype}, found dtype=${s.dtype}.`);if(o.axes){let l=s.shape;for(let u in o.axes){let p=Number(u),f=o.axes[u],m=p>=0?l[p]:l[l.length+p];if(f!=null&&[f,null].indexOf(m)===-1)throw new ct(`Input ${n} is incompatible with layer ${this.name}: expected axis ${p} of input shape to have value ${f} but got shape ${l}.`)}}if(o.shape!=null)for(let l=0;l<o.shape.length;++l){let u=o.shape[l],p=s.shape[l];if(u!=null&&p!=null&&u!==p)throw new ct(`Input ${n} is incompatible with layer ${this.name}: expected shape=${o.shape}, found shape=${s.shape}.`)}}}call(t,e){return t}invokeCallHook(t,e){this._callHook!=null&&this._callHook(t,e)}setCallHook(t){this._callHook=t}clearCallHook(){this._callHook=null}apply(t,e){e=e||{},this.assertNotDisposed();let n=Xe(t),s=!0;for(let a of n)if(!(a instanceof xn)){s=!1;break}let o=!0;for(let a of n)if(a instanceof xn){o=!1;break}if(s===o)throw new ct("Arguments to apply() must be all SymbolicTensors or all Tensors");return Ns(this.name,()=>{if(!this.built){this.assertInputCompatibility(t);let a=[];for(let l of Xe(t))a.push(l.shape);this.build(Or(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&o&&(this._refCount=1)}if(this.assertInputCompatibility(t),o){let a=this.call(t,e),l=Xe(a),u=[];for(let p of l)n.indexOf(p)!==-1&&(p=p.clone()),u.push(p);if(a=Or(u),this.activityRegularizer!=null)throw new ue("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{let a=IM(t),l=this.computeOutputShape(a),u,p=NM(t);if(this.warnOnIncompatibleInputShape(Array.isArray(t)?a[0]:a),l!=null&&l.length>0&&Array.isArray(l[0])?u=l.map((f,m)=>new xn(p,f,this,Xe(t),e,this.name,m)):u=new xn(p,l,this,Xe(t),e,this.name),this.addInboundNode(t,u,null,null,a,l,e),this._refCount++,this.activityRegularizer!=null)throw new ue("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}})}warnOnIncompatibleInputShape(t){if(this.batchInputShape!=null)if(t.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(t)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let e=!1;this.batchInputShape.forEach((n,s)=>{n!=null&&t[s]!=null&&t[s]!==n&&(e=!0)}),e&&console.warn(`The shape of the input tensor (${JSON.stringify(t)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new Fn(`The layer ${this.name} has never been called and thus has no defined output shape.`);let t=[];for(let e of this.inboundNodes){let n=JSON.stringify(e.outputShapes);t.indexOf(n)===-1&&t.push(n)}if(t.length===1){let e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&e.length===1?e[0]:e}else throw new Fn(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new on(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return hc(this.weights)}build(t){this.built=!0}getWeights(t=!1){return Mp(t?this.trainableWeights:this.weights)}setWeights(t){_t(()=>{let e=this.weights;if(e.length!==t.length)throw new ct(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${t.length}, but the layer was expecting ${e.length} weights. Provided weights: ${t}...`);if(e.length===0)return;let n=[],s=Mp(e);for(let o=0;o<s.length;++o){let a=s[o],l=e[o],u=t[o];if(!E.arraysEqual(a.shape,u.shape))throw new ct(`Layer weight shape ${a.shape} not compatible with provided weight shape ${u.shape}`);n.push([l,u])}mc(n)})}addWeight(t,e,n,s,o,a,l){if(this._addedWeightNames.indexOf(t)!==-1)throw new ct(`Duplicate weight name ${t} for layer ${this.name}`);this._addedWeightNames.push(t),n==null&&(n="float32"),this.fastWeightInitDuringBuild&&(s=Ke("zeros"));let u=s.apply(e,n),p=new km(u,n,t,a,l);return u.dispose(),o!=null&&this.addLoss(()=>o.apply(p.read())),a==null&&(a=!0),a?this._trainableWeights.push(p):this._nonTrainableWeights.push(p),p}setFastWeightInitDuringBuild(t){this.fastWeightInitDuringBuild=t}addLoss(t){t==null||Array.isArray(t)&&t.length===0||(t=Xe(t),this._losses!==void 0&&this._losses!==null&&this.losses.push(...t))}computeOutputShape(t){return t}computeMask(t,e){if(!this.supportsMasking){if(e!=null)if(Array.isArray(e))e.forEach(n=>{if(n!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return e}addInboundNode(t,e,n,s,o,a,l=null){let u=Xe(t);e=Xe(e),n=Xe(n),s=Xe(s),o=fc(o),a=fc(a);let p=[],f=[],m=[];for(let d of u)p.push(d.sourceLayer),f.push(d.nodeIndex),m.push(d.tensorIndex);new Ta({outboundLayer:this,inboundLayers:p,nodeIndices:f,tensorIndices:m,inputTensors:u,outputTensors:e,inputMasks:n,outputMasks:s,inputShapes:o,outputShapes:a},l);for(let d=0;d<e.length;d++)e[d].sourceLayer=this,e[d].nodeIndex=this.inboundNodes.length-1,e[d].tensorIndex=d}getConfig(){let t={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(t.batchInputShape=this.batchInputShape),this.dtype!=null&&(t.dtype=this.dtype),t}disposeWeights(){return this.weights.forEach(t=>t.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let t=0;return--this._refCount==0&&(t=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:t}}};function IM(r){r=Xe(r);let t=[];for(let e of r)t.push(e.shape);return Or(t)}function NM(r){return"float32"}function ry(r,t,e){if((t==null||e!=null&&e>0)&&(t=r.sourceLayer,e=r.nodeIndex),t.inboundNodes.length===0)return[r];{let n=t.inboundNodes[e];if(n.inboundLayers.length===0)return n.inputTensors;{let s=[];for(let o=0;o<n.inboundLayers.length;o++){let a=n.inputTensors[o],l=n.inboundLayers[o],u=n.nodeIndices[o],p=ry(a,l,u);for(let f of p)s.indexOf(f)===-1&&s.push(f)}return s}}}var fi=class extends _e{constructor(t){super({dtype:t.dtype,name:t.name!=null?t.name:Na("input").toString()});if(t.batchSize==null&&(t.batchSize=null),t.sparse==null&&(t.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=t.sparse,t.inputShape!=null&&t.batchInputShape!=null)throw new ct("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let e=t.batchInputShape;if(e==null){if(t.inputShape==null)throw new ct("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");e=[t.batchSize].concat(t.inputShape)}else if(t.batchSize!=null)throw new ct("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");let n=t.dtype||"float32";this.batchInputShape=e,this.dtype=n,this.inputSpec=[{shape:e}];let s=new xn(this.dtype,this.batchInputShape,this,[],{},this.name);s.nodeIndex=0,s.tensorIndex=0,new Ta({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[s],outputTensors:[s],inputMasks:[null],outputMasks:[null],inputShapes:[e],outputShapes:[e]})}apply(t,e){throw new ct(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}};fi.className="InputLayer";At.registerClass(fi);function ny(r){if(r.batchShape==null&&r.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(r.batchShape!=null&&r.shape!=null)throw new ct("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=r.batchShape;r.shape!=null&&t==null&&(t=[null].concat(r.shape));let e=r.dtype;return e==null&&(e="float32"),new fi({batchInputShape:t,name:r.name,dtype:e,sparse:r.sparse}).inboundNodes[0].outputTensors[0]}async function hi(r){if(r==null)return;let t=[],e=[],n=[];for(let s in r){let o=r[s];if(typeof o!="number"){let a=o;t.push(a.data()),e.push(s),n.push(a)}}if(t.length>0){let s=await Promise.all(t);for(let o=0;o<s.length;++o)r[e[o]]=s[o][0];pe(n)}}function Sm(r){if(r!=null)for(let t in r){let e=r[t];typeof e!="number"&&e.dispose()}}var TS;(function(r){r[r.SILENT=0]="SILENT",r[r.VERBOSE=1]="VERBOSE"})(TS||(TS={}));var TM=125,Sl=class{constructor(){this.validationData=null}setParams(t){this.params=t}async onEpochBegin(t,e){}async onEpochEnd(t,e){}async onBatchBegin(t,e){}async onBatchEnd(t,e){}async onTrainBegin(t){}async onTrainEnd(t){}setModel(t){}},sy=class{constructor(t,e=10){t==null&&(t=[]),this.callbacks=t,this.queueLength=e}append(t){this.callbacks.push(t)}setParams(t){for(let e of this.callbacks)e.setParams(t)}setModel(t){for(let e of this.callbacks)e.setModel(t)}async onEpochBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochBegin(t,e)}async onEpochEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onEpochEnd(t,e)}async onBatchBegin(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchBegin(t,e)}async onBatchEnd(t,e){e==null&&(e={});for(let n of this.callbacks)await n.onBatchEnd(t,e)}async onTrainBegin(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainBegin(t)}async onTrainEnd(t){t==null&&(t={});for(let e of this.callbacks)await e.onTrainEnd(t)}},ES=class extends Sl{constructor(){super()}async onEpochBegin(t){this.seen=0,this.totals={}}async onBatchEnd(t,e){e==null&&(e={});let n=e.size==null?0:e.size;this.seen+=n;for(let s in e){let o=e[s];if(typeof o=="number")this.totals.hasOwnProperty(s)||(this.totals[s]=0),this.totals[s]=this.totals[s]+o*n;else{let a;s in this.totals?a=this.totals[s]:this.totals[s]=0;let l=_t(()=>Ot(this.totals[s],ft(o,n)));this.totals[s]=l,a!=null&&a.dispose()}}}async onEpochEnd(t,e){if(e!=null)for(let n of this.params.metrics)this.totals[n]!=null&&(typeof this.totals[n]=="number"?e[n]=this.totals[n]/this.seen:_t(()=>{let s=ft(Xt(1,this.seen),this.totals[n]);e[n]=s,this.totals[n].dispose(),Fr(e[n])}))}},oy=class extends Sl{async onTrainBegin(t){this.epoch=[],this.history={}}async onEpochEnd(t,e){e==null&&(e={}),this.epoch.push(t);for(let n in e)this.history[n]==null&&(this.history[n]=[]),this.history[n].push(e[n])}async syncData(){let t=[],e=[],n=[];for(let o in this.history){let a=this.history[o];for(let l=0;l<a.length;++l)if(typeof a[l]!="number"){let u=a[l];t.push(u.data()),e.push(o),n.push(l)}}let s=await Promise.all(t);for(let o=0;o<s.length;++o)this.history[e[o]][n[o]].dispose(),this.history[e[o]][n[o]]=s[o][0]}},iy=class extends Sl{constructor(t,e){super();if(this.currentEpoch=0,this.yieldEvery=e||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=TM),this.yieldEvery==="never"&&t.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");E.isNumber(this.yieldEvery)&&(this.maybeWait=sS(this.maybeWait.bind(this),this.yieldEvery)),this.trainBegin=t.onTrainBegin,this.trainEnd=t.onTrainEnd,this.epochBegin=t.onEpochBegin,this.epochEnd=t.onEpochEnd,this.batchBegin=t.onBatchBegin,this.batchEnd=t.onBatchEnd,this.yield=t.onYield}async maybeWait(t,e,n){let s=[];this.yield!=null&&(await hi(n),s.push(this.yield(t,e,n))),s.push(Qh()),await Promise.all(s)}async onEpochBegin(t,e){this.currentEpoch=t,this.epochBegin!=null&&(await hi(e),await this.epochBegin(t,e))}async onEpochEnd(t,e){let n=[];this.epochEnd!=null&&(await hi(e),n.push(this.epochEnd(t,e))),this.yieldEvery==="epoch"&&n.push(Qh()),await Promise.all(n)}async onBatchBegin(t,e){this.batchBegin!=null&&(await hi(e),await this.batchBegin(t,e))}async onBatchEnd(t,e){let n=[];this.batchEnd!=null&&(await hi(e),n.push(this.batchEnd(t,e))),this.yieldEvery==="batch"?n.push(Qh()):E.isNumber(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,t,e)),await Promise.all(n)}async onTrainBegin(t){this.trainBegin!=null&&(await hi(t),await this.trainBegin(t))}async onTrainEnd(t){this.trainEnd!=null&&(await hi(t),await this.trainEnd(t))}};function Im(r,t){return r==null&&(r={}),r instanceof Sl?[r]:Array.isArray(r)&&r[0]instanceof Sl?r:Xe(r).map(n=>new iy(n,t))}var On=class{constructor(){}static registerCallbackConstructor(t,e){E.assert(t>=0&&Number.isInteger(t),()=>`Verbosity level is expected to be an integer >= 0, but got ${t}`),On.checkForDuplicate(e),On.constructors[t]==null&&(On.constructors[t]=[]),On.constructors[t].push(e)}static checkForDuplicate(t){for(let e in On.constructors)On.constructors[+e].forEach(s=>{if(s===t)throw new ct("Duplicate callback constructor.")})}static clear(){On.constructors={}}static createCallbacks(t){let e=[];for(let n in On.constructors){let s=+n;t>=s&&e.push(...On.constructors[s])}return e.map(n=>new n)}};On.constructors={};function Nm(r,t,e,n,s,o,a,l,u){let p=new oy,f=[new ES,...On.createCallbacks(t)];r!=null&&f.push(...r),f.push(p);let m=new sy(f);return m.setParams({epochs:e,initialEpoch:n,samples:s,steps:o,batchSize:a,verbose:t,doValidation:l,metrics:u}),{callbackList:m,history:p}}function Cn(r,t={},e=!1){return Qs(r,At.SerializationMap.getMap().classNameMap,t,"layer",e)}function Bp(r,t){return _t(()=>{r.dtype!=="float32"&&(r=r.asType("float32"));let e=ee(kl(r),t,!0),n=Fh(e.shape,Sr()),s=ur(Gn(e,n));return Xt(r,s)})}function Il(r,t){return _t(()=>hr(kl(ie(t,r)),-1))}function Vp(r,t){return _t(()=>hr(Ar(ie(t,r)),-1))}function Gp(r,t){return _t(()=>{let e=ie(r,t),n=Hr(Ar(r),Sr(),Number.MAX_VALUE),s=Ar(Xt(e,n));return ft(100,hr(s,-1))})}function EM(r,t){return _t(()=>{let e=Hr(t,Sr(),Number.MAX_VALUE),n=bn(Ot(1,e)),s=Hr(r,Sr(),Number.MAX_VALUE),o=bn(Ot(1,s));return hr(kl(ie(n,o)),-1)})}function AM(r,t){return _t(()=>{let e=Gn(0,ie(1,ft(r,t)));return hr(kl(e),-1)})}function $M(r,t){return _t(()=>{let e=Gn(0,ie(1,ft(r,t)));return hr(e,-1)})}function DM(r,t){return _t(()=>{let e=ee(ft(r,t),-1),n=Xr(ft(ie(1,r),t),-1);return Gn(0,Ot(1,ie(n,e)))})}function RM(r,t){return _t(()=>{let e=Math.log(2),n=ie(t,r),s=ie(Ot(n,ka(ft(-2,n))),e);return hr(s,-1)})}function Nl(r,t,e=!1){return _t(()=>{if(e)t=ec(t);else{let n=ee(t,t.shape.length-1,!0);t=Xt(t,n)}return t=Hr(t,Sr(),1-Sr()),je(ee(ft(r.toFloat(),bn(t)),t.shape.length-1))})}function dc(r,t,e=!1){return _t(()=>{let n=Ca(yS(r)).toInt();t=Hr(t,Sr(),1-Sr());let s=t.shape,o=up(n,s[s.length-1]).reshape(s);return Nl(o,t,e)})}function FM(r,t){if(!E.arraysEqual(r.shape,t.shape))throw new ct(`logits and labels must have the same shape, but got shapes ${JSON.stringify(r.shape)} and ${JSON.stringify(t.shape)}`);return _t(()=>{let e=t.relu(),n=t.abs().neg();return e.sub(t.mul(r)).add(n.exp().log1p())})}function gc(r,t){return _t(()=>{let e;return e=Hr(t,Sr(),1-Sr()),e=bn(Xt(e,ie(1,e))),hr(FM(r,e),-1)})}function OM(r,t){return _t(()=>{let e=Hr(r,Sr(),1),n=Hr(t,Sr(),1);return ee(ft(r,bn(Xt(e,n))),-1)})}function PM(r,t){return _t(()=>{let e=bn(Ot(Sr(),t));return hr(ie(t,ft(r,e)),-1)})}function Tm(r,t){return _t(()=>{let e=Bp(r,-1),n=Bp(t,-1),s=ft(e,n);return je(ee(s,-1))})}var Wp={meanSquaredError:Il,meanAbsoluteError:Vp,meanAbsolutePercentageError:Gp,meanSquaredLogarithmicError:EM,squaredHinge:AM,hinge:$M,categoricalHinge:DM,logcosh:RM,categoricalCrossentropy:Nl,sparseCategoricalCrossentropy:dc,binaryCrossentropy:gc,kullbackLeiblerDivergence:OM,poisson:PM,cosineProximity:Tm};function Em(r){if(typeof r=="string"){if(r in Wp)return Wp[r];let t=`Unknown loss ${r}`;throw r.toLowerCase().includes("softmaxcrossentropy")&&(t=`Unknown loss ${r}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new ct(t)}else return r}function Am(r,t){return _t(()=>{let e=ft(.5,Gr(t)),n=ui(Kr(t,e),r.dtype);return hr(ks(r,n),-1)})}function $m(r,t){return _t(()=>ui(ks(fp(r,-1),fp(t,-1)),"float32"))}function LM(r,t){return _t(()=>fn(r.equal(1),t.equal(1)).sum().cast("float32"))}function zM(r,t){return _t(()=>fn(r.equal(0),t.equal(1)).sum().cast("float32"))}function AS(r,t){return _t(()=>{let e=LM(r,t),n=zM(r,t),s=e.add(n);return Cr(Kr(s,0),e.div(s),0).cast("float32")})}function ay(r,t){return gc(r,t)}function ly(r,t){return r.rank===t.rank&&(r=r.squeeze([r.rank-1])),t=t.argMax(-1),t.dtype!==r.dtype&&(t=t.asType(r.dtype)),ks(r,t).asType("float32")}var MM=Il,BM=Il,VM=Vp,GM=Vp,WM=Gp,UM=Gp,Dm=Nl,jM=Tm,uy=dc,Rm={binaryAccuracy:Am,categoricalAccuracy:$m,precision:AS,categoricalCrossentropy:Dm,sparseCategoricalCrossentropy:uy,mse:MM,MSE:BM,mae:VM,MAE:GM,mape:WM,MAPE:UM,cosine:jM};function $S(r){if(typeof r=="string"&&r in Rm)return Rm[r];if(typeof r!="string"&&r!=null)return r;throw new ct(`Unknown metric ${r}`)}function Up(r){if(Un(r!==null,`Unknown LossOrMetricFn ${r}`),typeof r=="string")return r;{let t;for(let e of Object.keys(Wp))if(Wp[e]===r){t=e;break}if(t!==void 0)return t;for(let e of Object.keys(Rm))if(Rm[e]===r){t=e;break}return t!==void 0?t:r.name}}function DS(r){let t={Adagrad:()=>wl.adagrad(.01),Adadelta:()=>wl.adadelta(1,.95,Sr()),Adam:()=>wl.adam(.001,.9,.999,Sr()),Adamax:()=>wl.adamax(.002,.9,.999,Sr(),0),RMSProp:()=>wl.rmsprop(.001,.9,0,Sr()),SGD:()=>wl.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,r in t)return t[r]();throw new ct(`Unknown Optimizer ${r}`)}var RS=1*1024*1024;function py(r,t,e=!1){if(r==null||typeof r!="object"||Object.getPrototypeOf(r)!==Object.prototype||!cy(r))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(e){let n=JSON.stringify(r);n.length>RS&&console.warn(`User-defined metadata of model "${t}" is too large in size (length=${n.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${RS}.`)}}function cy(r){if(r===null)return!0;if(typeof r=="object")if(Object.getPrototypeOf(r)===Object.prototype){let t=Object.keys(r);for(let e of t)if(typeof e!="string"||!cy(r[e]))return!1;return!0}else if(Array.isArray(r)){for(let t of r)if(!cy(t))return!1;return!0}else return!1;else{let t=typeof r;return t==="string"||t==="number"||t==="boolean"}}function FS(r,t,e,n=console.log){let s=HM(r),o=["Layer (type)","Output shape","Param #"];s?(t=t||65,e=e||[.45,.85,1]):(t=t||98,e=e||[.33,.55,.67,1]),e[e.length-1]<=1&&(e=e.map(f=>Math.floor(t*f)));let a;if(!s){o.push("Receives inputs"),a=[];for(let f in r.nodesByDepth)a.push(...r.nodesByDepth[f])}n("_".repeat(t)),Fm(o,e,n),n("=".repeat(t));let l=r.layers;for(let f=0;f<l.length;++f)s?KM(l[f],e,n):XM(l[f],e,a,n),n((f===l.length-1?"=":"_").repeat(t));r.checkTrainableWeightsConsistency();let u=qM(r),p=hc(r.nonTrainableWeights);n(`Total params: ${u+p}`),n(`Trainable params: ${u}`),n(`Non-trainable params: ${p}`),n("_".repeat(t))}function qM(r){let t;return r.collectedTrainableWeights!=null?t=hc(r.collectedTrainableWeights):t=hc(r.trainableWeights),t}function HM(r){let t=!0,e=[],n=[];for(let s in r.nodesByDepth)e.push(r.nodesByDepth[s]);for(let s of e){if(s.length>1||s.length===1&&s[0].inboundLayers.length>1){t=!1;break}n.push(...s)}if(t)for(let s of r.layers){let o=!1;for(let a of s.inboundNodes)if(n.indexOf(a)!==-1)if(o){t=!1;break}else o=!0;if(!t)break}return t}function Fm(r,t,e=console.log){let n="";for(let s=0;s<r.length;++s)s>0&&(n=n.slice(0,n.length-1)+" "),n+=r[s],n=n.slice(0,t[s]),n+=" ".repeat(t[s]-n.length);e(n)}function KM(r,t,e){let n;try{n=JSON.stringify(r.outputShape)}catch(l){n="multiple"}let s=r.name,o=r.getClassName(),a=[`${s} (${o})`,n,r.countParams().toString()];Fm(a,t,e)}function XM(r,t,e,n){let s;try{s=JSON.stringify(r.outputShape)}catch(f){s="multiple"}let o=[];for(let f of r.inboundNodes)if(!(e!=null&&e.length>0&&e.indexOf(f)===-1))for(let m=0;m<f.inboundLayers.length;++m){let d=f.inboundLayers[m].name,y=f.nodeIndices[m],_=f.tensorIndices[m];o.push(`${d}[${y}][${_}]`)}let a=r.name,l=r.getClassName(),u=o.length===0?"":o[0],p=[`${a} (${l})`,s,r.countParams().toString(),u];Fm(p,t,n);for(let f=1;f<o.length;++f)Fm(["","","",o[f]],t,n)}function OS(r,t,e){return(r==="inboundNodes"||r==="outputLayers"||r==="inputLayers")&&t===0&&typeof e=="string"}function xc(r,t){if(r===null)return null;if(typeof r=="string")return li(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let s=0;s<n;++s){let o=r[s];OS(t,s,o)?e.push(o):e.push(xc(o,t))}return e}else{let e={};for(let n of Object.keys(r)){let s=r[n];if(n==="name"&&typeof s=="string")e[n]=s;else{let o=li(n);e[o]=xc(s,o)}}return e}}function Om(r,t){if(r==null)return null;if(typeof r=="string")return es(r);if(typeof r=="number"||typeof r=="boolean")return r;if(r instanceof Array){let e=[],n=r.length;for(let s=0;s<n;++s){let o=r[s];OS(t,s,o)?e.push(o):e.push(Om(o,t))}return e}else{let e={};for(let n of Object.keys(r)){let s=r[n],o=es(n);(n==="name"||n==="className")&&typeof s=="string"?e[o]=s:e[o]=Om(s,n)}return e}}var yc="3.0.0";function YM(r,t){if(r.dtype==null||r.dtype===t.dtype)return t;try{return Vt(t,r.dtype)}catch(e){throw new ct(`The dtype of the feed (${t.dtype}) can not be cast to the dtype of the key '${r.name}' (${r.dtype}).`)}}var Es=class{constructor(t){if(this.id2Value={},this.id2Mask={},this.name2Id={},t instanceof Es)for(let e in t.id2Value)this.id2Value[e]=t.id2Value[e],e in t.id2Mask&&(this.id2Mask[e]=t.id2Mask[e]);else{if(t==null)return;for(let e of t)this.add(e.key,e.value)}}add(t,e,n){if(this.id2Value[t.id]==null)this.id2Value[t.id]=YM(t,e),this.name2Id[t.name]=t.id,n!=null&&(this.id2Mask[t.id]=n);else throw new ct(`Duplicate key: name=${t.name}, id=${t.id}`);return this}addFeed(t){this.add(t.key,t.value)}hasKey(t){return this.id2Value[t.id]!=null}names(){return Object.keys(this.name2Id)}getValue(t){if(t instanceof xn){if(this.id2Value[t.id]==null)throw new ct(`Nonexistent key: ${t.name}`);return this.id2Value[t.id]}else{let e=this.name2Id[t];if(e==null)throw new ct(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Value[e]}}getMask(t){if(t instanceof xn){if(this.id2Value[t.id]==null)throw new ct(`Nonexistent key: ${t.name}`);return this.id2Mask[t.id]}else{let e=this.name2Id[t];if(e==null)throw new ct(`Feed dict has no SymbolicTensor name: ${t}`);return this.id2Mask[e]}}disposeMasks(){this.id2Mask!=null&&pe(this.id2Mask)}},fy={},PS={};function Tl(r,t,e,n){let s=e==null?!1:e.training,o=Array.isArray(r),a=o?r:[r],l=a.map(_=>_.name),u=[],p=t.names();for(let _ of l)p.indexOf(_)!==-1?u.push(t.getValue(_)):u.push(null);n!=null&&(n.maxNumTensors=-Infinity,n.minNumTensors=Infinity);let f=l.join(",")+"|"+t.names().join(","),m,d;if(fy[f]==null){let _=ZM(a,t);m=_.sorted,d=_.recipientCounts,fy[f]=m,PS[f]=d}m=fy[f],d={},s||Object.assign(d,PS[f]);let y=new Es(t);for(let _=0;_<m.length;++_){if(n!=null){let it=cp().numTensors;it>n.maxNumTensors&&(n.maxNumTensors=it),it<n.minNumTensors&&(n.minNumTensors=it)}let v=m[_],C=v.sourceLayer;if(C instanceof fi)continue;let N=[],A=[],B=[],P=!1;for(let it of v.inputs){let xt=y.getValue(it),wt=y.getMask(it);N.push(xt),A.push(wt),wt!=null&&(P=!0),s||(d[it.name]--,d[it.name]===0&&!t.hasKey(it)&&l.indexOf(it.name)===-1&&!xt.isDisposed&&it.sourceLayer.stateful!==!0&&B.push(xt))}P&&(e=e||{},e.mask=A[0]);let L=Xe(C.apply(N,e)),Z=null;C.supportsMasking&&(Z=C.computeMask(N,A));let K=JM(v),et=Array.isArray(K)?K:[K];for(let it=0;it<et.length;++it){y.hasKey(et[it])||y.add(et[it],L[it],Array.isArray(Z)?Z[0]:Z);let xt=l.indexOf(et[it].name);xt!==-1&&(u[xt]=L[it])}s||pe(B)}return y.disposeMasks(),o?u:u[0]}function ZM(r,t){E.assert(r!=null&&r.length>0,()=>"Expected at least one fetch, got none");let e=[],n={};if(r.length===1){let s=LS(r[0],t);e=s.sorted,n=s.recipientMap}else{let s=new Set;for(let o of r){let{sorted:a,recipientMap:l}=LS(o,t);for(let u of a)s.has(u.name)||(e.push(u),s.add(u.name));for(let u in l)n[u]==null&&(n[u]=new Set),l[u].forEach(p=>n[u].add(p))}}return{sorted:e,recipientCounts:QM(n)}}function QM(r){let t={};for(let e in r)t[e]=r[e].size;return t}function LS(r,t){let e=new Set,n=[],s={};for(let l of t.names())e.add(l);let o=[],a=[];for(o.push(r);o.length>0;){let l=o[o.length-1];if(e.has(l.name)){o.pop();continue}let u=a[a.length-1]===o.length-1;if(l.inputs.length===0||u)o.pop(),n.push(l),e.add(l.name),u&&a.pop();else{a.push(o.length-1);for(let p of l.inputs)s[p.name]==null&&(s[p.name]=new Set),s[p.name].add(l.name),!e.has(p.name)&&o.push(p)}}return{sorted:n,recipientMap:s}}function JM(r){let t;if(r.sourceLayer.inboundNodes.length===1)t=r.sourceLayer.output;else{let e=null;for(let n=0;n<r.sourceLayer.inboundNodes.length;++n)for(let s of r.sourceLayer.inboundNodes[n].outputTensors)if(s.id===r.id){e=n;break}t=r.sourceLayer.getOutputAt(e)}return t}var jn=class extends _e{constructor(t){super({});if(this.containerNodes=new Set,this.name=t.name,this.name==null){let A=this.getClassName().toLowerCase();this.name=Na(A)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(t.inputs)?this.inputs=t.inputs.slice():this.inputs=[t.inputs],Array.isArray(t.outputs)?this.outputs=t.outputs.slice():this.outputs=[t.outputs],ns(this.inputs).length!==this.inputs.length)throw new ct(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(A=>A.name)}`);ns(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(A=>A.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(let A of this.outputs){let B=A.sourceLayer,P=A.nodeIndex,L=A.tensorIndex;this.outputLayers.push(B),this.outputLayersNodeIndices.push(P),this.outputLayersTensorIndices.push(L)}for(let A of this.inputs){let B=A.sourceLayer,P=A.nodeIndex,L=A.tensorIndex;Un(P===0,"input layer has >1 nodes"),Un(L===0,"input layer has >1 tensors"),this.inputLayers.push(B),this.inputLayersNodeIndices.push(P),this.inputLayersTensorIndices.push(L)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let A=0;A<this.inputLayers.length;A++){let B=this.inputLayers[A];if(!(B instanceof fi))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${t.inputs}. Input ${A} (0-based) originates from layer type ${B.getClassName()}.`);this.inputNames.push(B.name),this.feedInputShapes.push(B.batchInputShape),this.feedInputNames.push(B.name)}for(let A of this.outputLayers)this.outputNames.push(A.name);this.internalInputShapes=this.inputs.map(A=>A.shape),this.internalOutputShapes=this.outputs.map(A=>A.shape);let e={},n={},s={},o={},a={},l=[],u=(A,B,P,L,Z,K)=>{(L==null||Z==null||K==null)&&(L=A.sourceLayer,Z=A.nodeIndex,K=A.tensorIndex);let et=L.inboundNodes[Z];if(P.indexOf(et)!==-1)throw new on(`The tensor ${A.name} at layer "${L.name}" is part of a cycle.`);if(B.indexOf(et)!==-1)return;this.containerNodes.add(jn.nodeKey(L,Z)),L.id in a||(a[L.id]=Object.keys(a).length),P.indexOf(et)===-1&&P.push(et);let it=et.inboundLayers.length;for(let xt=0;xt<it;xt++){let wt=et.inputTensors[xt],St=et.inboundLayers[xt],yt=et.nodeIndices[xt],Nt=et.tensorIndices[xt];u(wt,B,P,St,yt,Nt)}for(B.push(et);P.indexOf(et)>=0;)P.splice(P.indexOf(et),1);l.push(et)},p=[],f=[];for(let A of this.outputs)u(A,p,f);let m=l.slice().reverse();for(let A of m){n[A.id]=A,A.id in e||(e[A.id]=0);let B=e[A.id],P=s[A.outboundLayer.id]==null?0:s[A.outboundLayer.id];B=Math.max(B,P),s[A.outboundLayer.id]=B,o[A.outboundLayer.id]=A.outboundLayer,e[A.id]=B;for(let L=0;L<A.inboundLayers.length;L++){let Z=A.inboundLayers[L],K=A.nodeIndices[L],et=Z.inboundNodes[K],it=e[et.id]==null?0:e[et.id];e[et.id]=Math.max(B+1,it),n[et.id]=et}}let d={};for(let A in e){let B=e[A];B in d||(d[B]=[]),d[B].push(n[A])}let y={};for(let A in s){let B=s[A];B in y||(y[B]=[]),y[B].push(o[A])}let _=Object.keys(y).map(A=>parseInt(A,10)).sort(Ap);this.layers=[];for(let A of _){let B=y[A];B.sort((P,L)=>{let Z=a[P.id],K=a[L.id];return Z<K?-1:Z>K?1:0});for(let P of B)P instanceof jn&&this.internalContainerRefs.push(P),this.layers.push(P)}this.layersByDepth=y,_=Object.keys(d).map(A=>parseInt(A,10)).sort(Ap);let v=this.inputs.slice(),C=[];for(let A of _)for(let B of d[A]){let P=B.outboundLayer;if(P!=null){for(let L of B.inputTensors)if(v.indexOf(L)===-1)throw new on(`Graph disconnected: cannot obtain value for tensor ${L} at layer "${P.name}". The following previous layers were accessed without issue: ${C}`);for(let L of B.outputTensors)v.push(L);C.push(P.name)}}this.nodesByDepth=d;let N=this.layers.map(A=>A.name);for(let A of N){let B=N.filter(P=>P===A).length;if(B!==1)throw new on(`The name "${A}" is used ${B} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(N))}this.outboundNodes=[],this.inboundNodes=[],new Ta({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(A=>null),outputMasks:this.outputs.map(A=>null),inputShapes:this.inputs.map(A=>A.shape),outputShapes:this.outputs.map(A=>A.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();let t={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount==0){for(let e of this.layers)t.numDisposedVariables+=e.dispose().numDisposedVariables;for(let e of this.internalContainerRefs)t.numDisposedVariables+=e.dispose().numDisposedVariables}return t.refCountAfterDispose=this._refCount,t}get trainable(){return this.trainable_}set trainable(t){this.layers.forEach(e=>{e._trainableWeights.forEach(n=>n.trainable=t)}),this.trainable_=t}get trainableWeights(){if(this._trainableWeights.length>0)throw new ct("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let t=[];for(let e of this.layers)t=t.concat(e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.layers)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.layers)e.push(...n.trainableWeights);return e.concat(t)}return t}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(t,e=!0){let n={},s=0;for(let a of this.layers)for(let l of a.weights){if(n[l.originalName]!=null)throw new ct(`Duplicate weight name: ${l.originalName}`);n[l.originalName]=l,s++}let o=[];for(let a in t){let l=a;if(n[a]==null){let u=a.split("/");l=u.slice(0,-2).concat([u[u.length-1]]).join("/")}if(n[l]!=null)o.push([n[l],t[a]]);else if(e)throw new ct(`Provided weight data has no target variable: ${a}`);delete n[l]}if(e){let a=[];for(let l in n)a.push(l);if(a.length>0)throw new ct(`${a.length} of ${s} weights are not set: ${a}`)}mc(o)}updatedConfig(){let t=this.getConfig(),e={};return e.className=this.getClassName(),e.config=t,e.kerasVersion=`tfjs-layers ${yc}`,e.backend="TensorFlow.js",e}toJSON(t,e=!0){let n=Om(this.updatedConfig());return e?JSON.stringify(n):n}call(t,e){return _t(()=>{t=Xe(t);let n=new Es;for(let s=0;s<this.inputs.length;++s)n.add(this.inputs[s],t[s]);return Tl(this.outputs,n,e)})}computeMask(t,e){return _t(()=>{t=Xe(t);let n;return e==null?n=ts(null,t.length):n=Xe(e),this.runInternalGraph(t,n)[1]})}computeOutputShape(t){let e=fc(t);if(e.length!==this.inputLayers.length)throw new ct(`Invalid inputShape argument ${t}: model has ${this.inputLayers.length} tensor inputs.`);let n={};for(let l=0;l<e.length;l++){let u=this.inputLayers[l],p=e[l],f=u.name+"_0_0";n[f]=p}let s=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(Ap);if(s.length>1)for(let l of s){let u=this.nodesByDepth[l];for(let p of u){let f=p.outboundLayer;if(this.inputLayers.map(v=>v.id).indexOf(f.id)!==-1)continue;let m=[];for(let v=0;v<p.inboundLayers.length;v++){let C=p.inboundLayers[v],N=p.nodeIndices[v],A=p.tensorIndices[v],B=`${C.name}_${N}_${A}`,P=n[B];m.push(P)}let d=f.computeOutputShape(Or(m)),y=fc(d),_=f.inboundNodes.indexOf(p);for(let v=0;v<y.length;v++){let C=`${f.name}_${_}_${v}`;n[C]=y[v]}}}let o=[],a=[];for(let l=0;l<this.outputLayers.length;l++){let u=this.outputLayers[l],p=this.outputLayersNodeIndices[l],f=this.outputLayersTensorIndices[l],m=`${u.name}_${p}_${f}`;a.push(m)}for(let l=0;l<a.length;l++){let u=a[l];Un(u in n),o.push(n[u])}return Or(o)}runInternalGraph(t,e){e==null&&(e=ts(null,t.length));let n={};for(let u=0;u<this.inputs.length;++u){let p=this.inputs[u],f=t[u],m=e[u];n[p.id]=[f,m]}let s=Object.keys(this.nodesByDepth).map(u=>parseInt(u,10)).sort(Ap);for(let u of s){let p=this.nodesByDepth[u];for(let f of p){let m=f.outboundLayer,d=f.inputTensors,y=f.outputTensors,_=new Array;for(let v of d)v.id in n&&_.push(n[v.id]);if(_.length===d.length){let v={},C,N,A,B;if(f.callArgs!=null&&(v=f.callArgs),_.length===1){let[P,L]=_[0];v.mask==null&&(v.mask=L),A=Xe(m.call(P,v)),B=Xe(m.computeMask(P,L)),C=[P],N=[L]}else C=_.map(P=>P[0]),N=_.map(P=>P[1]),v.mask==null&&(v.mask=N),A=Xe(m.call(C,v)),B=Xe(m.computeMask(C,N));if(m.activityRegularizer)throw new ue("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let P=0;P<y.length;++P){let L=y[P],Z=A[P],K=B[P];n[L.id]=[Z,K]}}}}let o=[],a=[],l=[];for(let u of this.outputs){Un(u.id in n,`Could not compute output ${u.name} : ${u.id}`);let[p,f]=n[u.id];l.push(p.shape),o.push(p),a.push(f)}return[o,a,l]}buildNodeConversionMap(t){let e={},n;for(let s of this.layers){n=s instanceof jn?1:0;for(let o=0;o<s.inboundNodes.length;o++){let a=jn.nodeKey(s,o);this.containerNodes.has(a)&&(e[a]=n,n+=1)}}return e}getLayer(t,e){if(e!=null){if(this.layers.length<=e)throw new ct(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}else if(t==null)throw new ct("Provide either a layer name or layer index");for(let n of this.layers)if(n.name===t)return n;throw new ct(`No such layer: ${t}`)}calculateLosses(){return _t(()=>{let t=[];for(let e of this.layers)for(let n=0;n<e.inboundNodes.length;++n){let s=jn.nodeKey(e,n);this.containerNodes.has(s)&&t.push(...e.calculateLosses())}return t})}getConfig(){let t={name:this.name},e=this.buildNodeConversionMap(this.layers),n=[];for(let a of this.layers){let l=a.getClassName(),u=a.getConfig(),p=[];for(let m=0;m<a.inboundNodes.length;m++){let d=a.inboundNodes[m],y=jn.nodeKey(a,m),_={};if(this.containerNodes.has(y)){if(d.callArgs)try{JSON.stringify(d.callArgs),_=d.callArgs}catch(v){console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),_={}}if(d.inboundLayers.length>0){let v=[];for(let C=0;C<d.inboundLayers.length;C++){let N=d.inboundLayers[C],A=d.nodeIndices[C],B=d.tensorIndices[C],P=jn.nodeKey(N,A),L=e[P];L==null&&(L=0),v.push([N.name,L,B,_])}p.push(v)}}}let f={};f.name=a.name,f.className=l,f.config=u,f.inboundNodes=p,n.push(f)}t.layers=n;let s=[];for(let a=0;a<this.inputLayers.length;a++){let l=this.inputLayers[a],u=this.inputLayersNodeIndices[a],p=jn.nodeKey(l,u);if(!this.containerNodes.has(p))continue;let f=e[p];f==null&&(f=0);let m=this.inputLayersTensorIndices[a];s.push([l.name,f,m])}t.inputLayers=s;let o=[];for(let a=0;a<this.outputLayers.length;a++){let l=this.outputLayers[a],u=this.outputLayersNodeIndices[a],p=jn.nodeKey(l,u);if(!this.containerNodes.has(p))continue;let f=e[p];f==null&&(f=0);let m=this.outputLayersTensorIndices[a];o.push([l.name,f,m])}return t.outputLayers=o,t}static fromConfig(t,e,n={},s=!1){let o={},a={};function l(C,N){C.name in a?a[C.name].push(N):a[C.name]=[N]}function u(C,N){let A=[],B;for(let P of N){let L=P[0],Z=P[1],K=P[2];if(B=P[3]==null?{}:P[3],!(L in o)){l(C,N);return}let et=o[L];if(et.inboundNodes.length<=Z){l(C,N);return}let it=et.inboundNodes[Z];A.push(it.outputTensors[K])}A.length>0&&C.apply(Or(A),B)}function p(C){let N=C.name,A=Cn(C,e.customObjects!=null?e.customObjects:{});A.setFastWeightInitDuringBuild(s),o[N]=A,C.inboundNodes.forEach(P=>{if(!(P instanceof Array))throw new ct(`Corrupted configuration, expected array for nodeData: ${P}`);l(A,P)})}let f=e.name,m=e.layers;for(let C of m)p(C);for(;!rS(a);)for(let C of m){let N=o[C.name];if(N.name in a){let A=a[N.name];delete a[N.name];for(let B of A)u(N,B)}}let d=[],y=[],_=e.inputLayers;for(let C of _){let N=C[0],A=C[1],B=C[2];Un(N in o);let L=o[N].inboundNodes[A].outputTensors;d.push(L[B])}let v=e.outputLayers;for(let C of v){let N=C[0],A=C[1],B=C[2];Un(N in o);let L=o[N].inboundNodes[A].outputTensors;y.push(L[B])}return new t({inputs:d,outputs:y,name:f})}get stateful(){if(this._stateful)throw new ct("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(let t of this.layers)if(t.stateful)return!0;return!1}resetStates(){_t(()=>{this.layers.forEach(t=>{t.stateful&&t.resetStates()})})}};function tB(r,t,e){let n=t.length;if(r==null||Array.isArray(r)&&r.length===0)return t.map(s=>null);if(n===1)return Array.isArray(r)&&r.length===1?r:typeof r=="object"&&t[0]in r?[r[t[0]]]:[r];if(Array.isArray(r)){if(r.length!==n)throw new Error(`Provided ${e} is an array of ${r.length} element(s), but the model has ${n} outputs. Make sure a set of weights is provided for each model output.`);return r}else if(typeof r=="object"&&Object.keys(r).length>0&&typeof r[Object.keys(r)[0]]=="object"){let s=[];return t.forEach(o=>{o in r?s.push(r[o]):s.push(null)}),s}else throw new Error(`The model has multiple (${n}) outputs, so ${e} must be either an array with ${n} elements or an object with ${t} keys. Provided ${e} not understood: ${JSON.stringify(r)}`)}function Pm(r,t){return tB(r,t,"classWeight")}async function Lm(r,t,e,n){if(t!=null||n!=null)throw new Error("Support sampleWeight is not implemented yet");if(e!=null){let s=_t(()=>{if(r.shape.length===1)return r.clone();if(r.shape.length===2)if(r.shape[1]>1){let l=1;return r.argMax(l)}else{if(r.shape[1]===1)return r.reshape([r.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${r.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${r.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),o=Array.from(await s.data());pe(s);let a=[];return o.forEach(l=>{if(e[l]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${l} exists in the data but not in classWeight`);a.push(e[l])}),Is(a,"float32")}else return null}function zS(r,t){return ft(r,t)}var eB=32;function BS(r,t){let e,n,s=t;e=s.xs,n=s.ys,E.assert(e!=null&&n!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${t}`);let o=MS("input",r.inputNames,e),a=MS("output",r.outputNames,n),l=o[0].shape[0];E.assert(o.length===r.inputs.length,()=>`LayersModel has ${r.inputs.length} inputs, but the dataset provides ${o.length} inputs.  (Expected input keys: ${JSON.stringify(r.inputNames)})`),E.assert(a.length===r.outputs.length,()=>`LayersModel has ${r.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(r.outputNames)})`);for(let u=0;u<o.length;u++)E.assert(o[u].shape[0]===l,()=>`Batch size mismatch: input ${r.inputNames[u]} has ${o[u].shape[0]}; expected  ${l} based on input ${r.inputNames[0]}.`);for(let u=0;u<a.length;u++)E.assert(a[u].shape[0]===l,()=>`Batch size mismatch: output ${r.outputNames[u]} has ${a[u].shape[0]}; expected  ${l} based on input ${r.inputNames[0]}.`);return{xs:o,ys:a}}function MS(r,t,e){if(e instanceof Ae)return[e];if(Array.isArray(e))return E.assert(e.length===t.length,()=>`Received an array of ${e.length} Tensors, but expected ${t.length} to match the ${r} keys ${t}.`),e;{let n=[];for(let s of t){if(e[s]==null)throw new ct(`The feature data generated by the dataset lacks the required ${r} key '${s}'.`);n.push(e[s])}return n}}function rB(r){if(r.length===3)throw new ue("Validation with sample weights is not implemented yet.");return{xs:r[0],ys:r[1]}}async function GS(r,t,e){let n=e.batchesPerEpoch!=null;if(E.assert(r.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),E.assert(e!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),E.assert(e.epochs!=null&&e.epochs>0&&Number.isInteger(e.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${e.epochs}`),E.assert(!n||e.batchesPerEpoch>0&&Number.isInteger(e.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${e.batchesPerEpoch}`),E.assert(e.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;try{let s=e.validationData!=null,o,a;if(s)if(VS(e.validationData))E.assert(e.validationBatches==null||e.validationBatches>0&&Number.isInteger(e.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${e.validationBatches}`);else{let C=rB(e.validationData);o=C.xs,a=C.ys}let l=r.makeTrainFunction(),u=r.getDedupedMetricsNames(),p;s?p=u.slice().concat(u.map(C=>"val_"+C)):p=u.slice();let f=Im(e.callbacks,e.yieldEvery),m=e.verbose==null?1:e.verbose,{callbackList:d,history:y}=Nm(f,m,e.epochs,null,null,nB(t,e),null,s,p);d.setModel(r),r.history=y,await d.onTrainBegin(),r.stopTraining_=!1;let _=e.initialEpoch==null?0:e.initialEpoch,v=await t.iterator();for(;_<e.epochs;){let C={};await d.onEpochBegin(_);let N=0,A=0;for(n||(v=await t.iterator());n?N<e.batchesPerEpoch:!0;){let B=await v.next();if(n&&B.done){console.warn(`You provided \`batchesPerEpoch\` as ${e.batchesPerEpoch}, but your dataset iterator ran out of data after ${N} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${e.batchesPerEpoch*e.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(B.value!=null){let{xs:P,ys:L}=BS(r,B.value),Z={};Z.batch=A,Z.size=P[0].shape[0],await d.onBatchBegin(A,Z);let K=[];if(e.classWeight!=null){let xt=Pm(e.classWeight,r.outputNames);for(let wt=0;wt<xt.length;++wt)K.push(await Lm(L[wt],null,xt[wt]))}let et=P.concat(L).concat(K),it=l(et);pe(et);for(let xt=0;xt<u.length;++xt){let wt=u[xt],St=it[xt];Z[wt]=St,Fr(St)}await d.onBatchEnd(A,Z),Sm(Z),A++,N++}if(n?N>=e.batchesPerEpoch:B.done){if(s){let P;VS(e.validationData)?P=Xe(await r.evaluateDataset(e.validationData,{batches:e.validationBatches})):P=Xe(r.evaluate(o,a,{batchSize:e.validationBatchSize==null?eB:e.validationBatchSize,verbose:0}));for(let L=0;L<r.metricsNames.length;++L)C[`val_${r.metricsNames[L]}`]=P[L]}break}if(r.stopTraining_)break}if(await d.onEpochEnd(_,C),_++,r.stopTraining_)break}return await d.onTrainEnd(),await r.history.syncData(),r.history}finally{r.isTraining=!1}}function nB(r,t){let e=null;return t.batchesPerEpoch!=null?e=t.batchesPerEpoch:Number.isFinite(r.size)&&(e=r.size),e}function VS(r){return typeof r.iterator=="function"}function sB(r){return typeof r.next=="function"}async function WS(r,t,e){e=e||{};let n=e.batches!=null,s=r.testFunction,o=[];if(e.verbose>0)throw new ue("Verbose mode is not implemented yet.");E.assert(!n||e.batches>0&&Number.isInteger(e.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(e.batches)}`);let a=sB(t)?t:await t.iterator(),l=0,u=0;for(;n?u<e.batches:!0;){let p=await a.next();if(o=_t(()=>{if(p.value){let{xs:f,ys:m}=BS(r,p.value),d=f.concat(m),y=_t(()=>s(d));if(pe(d),u===0)for(let v=0;v<y.length;++v)o.push(fe(0));let _=d[0].shape[0];for(let v=0;v<y.length;++v){let C=y[v],N=o[v];o[v]=_t(()=>Ot(o[v],ft(_,C))),u>0&&pe(N)}pe(y),l+=_,++u}return o}),p.done){n&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${e.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let p=0;p<o.length;++p){let f=o[p];o[p]=Xt(o[p],l),pe(f)}return Or(o)}function zm(r){E.assert(r>0&&Number.isInteger(r),()=>`batchSize is required to be a positive integer, but got ${r}`)}function _c(r,t,e){return r==null?[null]:Array.isArray(r)?r.map(n=>pi(n,t,e-t)):pi(r,t,e-t)}function Mm(r,t){return _t(()=>r==null?null:Array.isArray(r)?r.map(e=>Mm(e,t)):fm(r,t.dtype==="int32"?t:t.toInt()))}function Bm(r,t){let e=[],n=0,s=null;for(;n<r;)s=n+t,s>=r&&(s=r),e.push([n,s]),n=s;return e}async function oB(r,t,e,n,s,o,a,l,u,p,f,m,d,y,_){s==null&&(s=32),o==null&&(o=1),f==null&&(f=!0),d==null&&(d=0);let v=!1;if(u!=null&&p!=null&&(v=!0),_!=null&&(v=!0,y==null))throw new ct("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");let C=r.checkNumSamples(e,s,y,"steps_per_epoch"),N;C!=null&&(N=an(0,C)),a==null&&(a=1);let{callbackList:A,history:B}=Nm(l,a,o,d,C,y,s,v,m);A.setModel(r),r.history=B,await A.onTrainBegin(),r.stopTraining_=!1;for(let P=d;P<o;++P){await A.onEpochBegin(P);let L={};if(y!=null)throw new ue("stepsPerEpoch mode is not implemented yet.");{if(f==="batch")throw new ue("batch shuffling is not implemneted yet");f&&E.shuffle(N);let Z=Is(N),K=Bm(C,s);for(let et=0;et<K.length;++et){let it={};if(await A.onBatchBegin(et,it),_t(()=>{let xt=K[et][0],wt=K[et][1],St=pi(Z,xt,wt-xt);it.batch=et,it.size=wt-xt;let yt=Mm(e,St),Nt=t(yt);for(let ht=0;ht<n.length;++ht){let It=n[ht],Ft=Nt[ht];it[It]=Ft,Fr(Ft)}if(et===K.length-1&&v){let ht=r.testLoop(u,p,s);for(let It=0;It<n.length;++It){let Ft=n[It],Ct=ht[It];Fr(Ct),L["val_"+Ft]=Ct}}}),await A.onBatchEnd(et,it),Sm(it),r.stopTraining_)break}Z.dispose()}if(await A.onEpochEnd(P,L),r.stopTraining_)break}return await A.onTrainEnd(),await r.history.syncData(),r.history}async function US(r,t,e,n={}){if(r.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");r.isTraining=!0;let s,o,a,l,u,p,f;try{let m=n.batchSize==null?32:n.batchSize;zm(m);let d=!1,y=await r.standardizeUserData(t,e,n.sampleWeight,n.classWeight,d,m);s=y[0],o=y[1],f=y[2];let _=!1,v;if(n.validationData!=null&&n.validationData.length>0){if(_=!0,n.validationData.length===2)a=n.validationData[0],l=n.validationData[1];else throw n.validationData.length===3?new ue("validationData including sample weights is not supported yet."):new ct(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${n.validationData} is invalid.`);let K=!0,et=await r.standardizeUserData(a,l,null,null,K,m);u=et[0],p=et[1],v=u.concat(p)}else if(n.validationSplit!=null&&n.validationSplit>0&&n.validationSplit<1){_=!0;let K=Math.floor(s[0].shape[0]*(1-n.validationSplit)),et=s[0].shape[0];u=_c(s,K,et),s=_c(s,0,K),p=_c(o,K,et),o=_c(o,0,K),v=u.concat(p)}else n.validationSteps!=null&&(_=!0);let C=s.concat(o).concat(f);r.checkTrainableWeightsConsistency();let N=r.makeTrainFunction(),A=r.getDedupedMetricsNames(),B,P;_?(r.makeTestFunction(),B=r.testFunction,P=A.slice().concat(A.map(K=>"val_"+K))):(B=null,v=[],P=A.slice());let L=Im(n.callbacks,n.yieldEvery);return await oB(r,N,C,A,m,n.epochs,n.verbose,L,B,v,n.shuffle,P,n.initialEpoch,null,null)}finally{r.isTraining=!1,Ea(s,t),Ea(o,e),Ea(u,a),Ea(p,l),f!=null&&pe(f)}}function hy(r){let t=[];r instanceof Ae&&(r=[r]);for(let e=0;e<r.length;++e){let n=r[e];if(n.rank===1)t.push(ci(n,1));else{if(n.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(n)}}return t}function Ea(r,t){if(r==null)return;let e=[];if(t instanceof Ae)e.push(t.id);else if(Array.isArray(t))t.forEach(s=>e.push(s.id));else if(t!=null)for(let s in t){let o=t[s];e.push(o.id)}let n=[];if(r instanceof Ae)e.indexOf(r.id)===-1&&n.push(r);else if(Array.isArray(r))r.forEach(s=>{e.indexOf(s.id)===-1&&n.push(s)});else if(r!=null)for(let s in r){let o=r[s];e.indexOf(o.id)===-1&&n.push(o)}n.forEach(s=>{s.isDisposed||s.dispose()})}function iB(r){return r instanceof Ae}function my(r){return Array.isArray(r)}function jS(r){return!iB(r)&&!my(r)}function qS(r,t,e,n=!0,s=""){if(t==null||t.length===0){if(r!=null){let a=!1;if(my(r)&&r.length>0)a=!0;else if(jS(r)){for(let l in r)if(r.hasOwnProperty(l)){a=!0;break}}else a=!0;if(a)throw new ct(`Error when checking model ${s} expected no data, but got ${r}`)}return[]}if(r==null)return t.map(a=>null);let o;if(jS(r)){r=r,o=[];for(let a of t){if(r[a]==null)throw new ct(`No data provided for "${a}". Need data for each key in: ${t}`);o.push(r[a])}}else if(my(r)){if(r=r,r.length!==t.length)throw new ct(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${t.length} Tensor(s), but instead got the following list of Tensor(s): ${r}`);o=r}else{if(r=r,t.length>1)throw new ct(`The model ${s} expects ${t.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${r.shape}`);o=[r]}if(o=hy(o),e!=null)for(let a=0;a<t.length;++a){if(e[a]==null)continue;let l=o[a];if(l.shape.length!==e[a].length)throw new ct(`Error when checking ${s}: expected ${t[a]} to have ${e[a].length} dimension(s). but got array with shape ${l.shape}`);for(let u=0;u<e[a].length;++u){if(u===0&&!n)continue;let p=l.shape[u],f=e[a][u];if(f!=null&&f>=0&&p!==f)throw new ct(`Error when checking ${s}: expected ${t[a]} to have shape [${e[a]}], but got array with shape [${l.shape}].`)}}return o}function aB(r,t,e){let n=ns(r.map(o=>o.shape[0]));n.sort();let s=ns(t.map(o=>o.shape[0]));if(s.sort(),n.length>1)throw new ct(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(r.map(o=>o.shape))}`);if(s.length>1)throw new ct(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(t.map(o=>o.shape))}`);if(n.length>0&&s.length>0&&!E.arraysEqual(n,s))throw new ct(`Input Tensors should have the same number of samples as target Tensors. Found ${n[0]} input sample(s) and ${s[0]} target sample(s).`)}function lB(r,t,e){let n=[Il,gc,Nl];for(let s=0;s<r.length;++s){let o=r[s],a=t[s],l=e[s];if(a!=null){if(a===Nl&&o.shape[o.shape.length-1]===1)throw new ct(`You are passing a target array of shape ${o.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(n.indexOf(a)!==-1){let u=o.shape.slice(1),p=l.slice(1);for(let f=0;f<u.length;++f){let m=u[f],d=p[f];if(d!=null&&m!==d)throw new ct(`A target Tensor with shape ${o.shape} was passed for an output of shape ${l}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function HS(r,t,e,n=!0,s=""){let o;if(Array.isArray(r)){if(r.length!==t.length)throw new ct(`Error when checking model ${s}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${t.length} Tensor(s), but instead got ${r.length} Tensors(s).`);o=r}else{if(t.length>1)throw new ct(`The model expects ${t.length} ${s} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(r.shape)}.`);o=[r]}if(e!=null)for(let a=0;a<t.length;++a){if(e[a]==null)continue;let l=o[a];if(l.shape.length!==e[a].length)throw new ct(`Error when checking ${s}: expected ${t[a]} to have ${e[a].length} dimension(s), but got array with shape ${JSON.stringify(l.shape)}`);for(let u=0;u<e[a].length;++u){if(u===0&&!n)continue;let p=l.shape[u],f=e[a][u];if(f!=null&&f!==p)throw new ct(`Error when checking ${s}: expected ${t[a]} to have shape ${JSON.stringify(e[a])} but got array with shape ${JSON.stringify(l.shape)}.`)}}}function uB(r,t){if(r==null||Array.isArray(r)&&r.length===0)return t.map(n=>[]);let e;if(typeof r=="string"||typeof r=="function")e=[r];else if(Array.isArray(r)||typeof r=="object")e=r;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${r}`);if(Array.isArray(e))return t.map(n=>e);{let n=[];for(let s of t){let o=e.hasOwnProperty(s)?e[s]:[];Array.isArray(o)||(o=[o]),n.push(o)}return n}}var cB="layers-model",As=class extends jn{constructor(t){super(t);this.isTraining=!1}summary(t,e,n=console.log){if(!this.built)throw new ct("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");FS(this,t,e,n)}compile(t){if(t.loss==null&&(t.loss=[]),this.loss=t.loss,typeof t.optimizer=="string")this.optimizer_=DS(t.optimizer),this.isOptimizerOwned=!0;else{if(!(t.optimizer instanceof hn))throw new ct("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=t.optimizer,this.isOptimizerOwned=!1}let e=[];if(!Array.isArray(t.loss)&&typeof t.loss!="string"&&typeof t.loss!="function"){t.loss=t.loss;for(let a in t.loss)if(this.outputNames.indexOf(a)===-1)throw new ct(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(let a of this.outputNames)t.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),e.push(Em(t.loss[a]))}else if(Array.isArray(t.loss)){if(t.loss.length!==this.outputs.length)throw new ct(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${t.loss}.`);e=t.loss.map(l=>Em(l))}else{let a=Em(t.loss);this.outputs.forEach(l=>{e.push(a)})}this.lossFunctions=e,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){let l=this.internalOutputShapes[a],u=this.outputNames[a];this.feedOutputNames.push(u),this.feedOutputShapes.push(l),this.feedLossFns.push(this.lossFunctions[a])}let n=[];this.metrics=t.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Ns("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let l=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([l,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});let s=uB(t.metrics,this.outputNames),o=(a,l,u)=>{this.outputNames.length>1&&(l=this.outputNames[a]+"_"+l),this.metricsNames.push(l),this.metricsTensors.push([u,a])};Ns("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(n.indexOf(a)!==-1)continue;let l=s[a];(p=>{let f="",m,d,y;for(let _ of p){if(typeof _=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(_)!==-1){let C=this.internalOutputShapes[a];C[C.length-1]===1||this.lossFunctions[a]===gc?["accuracy","acc"].indexOf(_)!==-1?d=Am:["crossentropy","ce"].indexOf(_)!==-1&&(d=ay):this.lossFunctions[a]===dc?["accuracy","acc"].indexOf(_)!==-1?d=ly:["crossentropy","ce"].indexOf(_)!==-1&&(d=uy):["accuracy","acc"].indexOf(_)!==-1?d=$m:["crossentropy","ce"].indexOf(_)!==-1&&(d=Dm);let N;["accuracy","acc"].indexOf(_)!==-1?N="acc":["crossentropy","ce"].indexOf(_)!==-1&&(N="ce"),y=d,m=f+N}else y=$S(_),m=f+Up(_);let v;Ns(m,()=>{v=y}),o(a,m,v)}})(l)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(t,e,n={}){let s=n.batchSize==null?32:n.batchSize;zm(s);let o=!0,a=this.standardizeUserDataXY(t,e,o,s);try{let l=a[0].concat(a[1]);this.makeTestFunction();let u=this.testFunction,p=this.testLoop(u,l,s,n.verbose,n.steps);return Or(p)}finally{Ea(a[0],t),Ea(a[1],e)}}async evaluateDataset(t,e){return this.makeTestFunction(),WS(this,t,e)}checkNumSamples(t,e,n,s="steps"){let o;if(n!=null){if(o=null,e!=null)throw new ct(`If ${s} is set, batchSize must be null or undefined.Got batchSize = ${e}`)}else if(t!=null)Array.isArray(t)?o=t[0].shape[0]:o=t.shape[0];else throw new ct(`Either the input data should have a defined shape, or ${s} shoud be specified.`);return o}execute(t,e){if(Array.isArray(e)&&e.length===0)throw new ct("`outputs` is an empty Array, which is not allowed.");let n=Array.isArray(e),s=n?e:[e],o=this.retrieveSymbolicTensors(s),a=new Es;if(t instanceof Ae&&(t=[t]),Array.isArray(t)){if(t.length!==this.inputs.length)throw new ct(`The number of inputs provided (${t.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let u=0;u<this.inputs.length;++u)a.add(this.inputs[u],t[u])}else for(let u of this.inputs){let p=t[u.name];if(p==null)throw new ct(`No value is provided for the model's input ${u.name}`);a.add(u,p)}let l=Tl(o,a);return n?l:l[0]}retrieveSymbolicTensors(t){let e=ts(null,t.length),n=t.length;for(let s of this.layers){let o=Array.isArray(s.output)?s.output:[s.output],a=o.map(l=>l.name);for(let l=0;l<t.length;++l){let u=a.indexOf(t[l]);if(u!==-1&&(e[l]=o[u],n--),n===0)break}if(n===0)break}if(n>0){let s=[];throw e.forEach((o,a)=>{o==null&&s.push(t[a])}),new ct(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(s)}`)}return e}predictLoop(t,e=32,n=!1){return _t(()=>{let s=this.checkNumSamples(t);if(n)throw new ue("Verbose predictLoop() is not implemented yet.");let o=Bm(s,e),a=this.outputs.map(l=>[]);for(let l=0;l<o.length;++l)_t(()=>{let p=o[l][0],f=o[l][1],m=_c(t,p,f),d=[];if(Array.isArray(m))for(let _=0;_<m.length;++_)d.push({key:this.inputs[_],value:m[_]});else d.push({key:this.inputs[0],value:m});let y=new Es(d);return Tl(this.outputs,y)}).forEach((p,f)=>a[f].push(p));return Or(a.map(l=>ar(l,0)))})}predict(t,e={}){let n=hy(t);HS(n,this.inputNames,this.feedInputShapes,!1);try{let s=e.batchSize==null?32:e.batchSize;return zm(s),this.predictLoop(n,s)}finally{Ea(n,t)}}predictOnBatch(t){HS(t,this.inputNames,this.feedInputShapes,!0);let e=(Array.isArray(t)?t[0]:t).shape[0];return this.predictLoop(t,e)}standardizeUserDataXY(t,e,n=!0,s){if(this.optimizer_==null)throw new on("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");let o=[];for(let a=0;a<this.feedOutputShapes.length;++a){let l=this.feedOutputShapes[a];this.feedLossFns[a]===dc?o.push(l.slice(0,l.length-1).concat([1])):o.push(l)}if(t=qS(t,this.feedInputNames,this.feedInputShapes,!1,"input"),e=qS(e,this.feedOutputNames,o,!1,"target"),aB(t,e,null),lB(e,this.feedLossFns,this.feedOutputShapes),this.stateful&&s!=null&&s>0&&t[0].shape[0]%s!=0)throw new ct(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${s}. Found: ${t[0].shape[0]} sample(s).`);return[t,e]}async standardizeUserData(t,e,n,s,o=!0,a){let[l,u]=this.standardizeUserDataXY(t,e,o,a);if(n!=null)throw new Error("sample weight is not supported yet.");let p=null;if(s!=null){let f=Pm(s,this.outputNames);p=[];for(let m=0;m<f.length;++m)p.push(await Lm(u[m],null,f[m]))}return[l,u,p]}testLoop(t,e,n,s=0,o){return _t(()=>{let a=this.checkNumSamples(e,n,o,"steps"),l=[];if(s>0)throw new ue("Verbose mode is not implemented yet.");if(o!=null)throw new ue("steps mode in testLoop() is not implemented yet");{let u=Bm(a,n),p=Is(an(0,a));for(let f=0;f<u.length;++f){let m=u[f][0],d=u[f][1],y=pi(p,m,d-m),_=Mm(e,y),v=t(_);if(f===0)for(let C=0;C<v.length;++C)l.push(fe(0));for(let C=0;C<v.length;++C){let N=v[C];l[C]=Ot(l[C],ft(d-m,N))}}for(let f=0;f<l.length;++f)l[f]=Xt(l[f],a)}return l})}getDedupedMetricsNames(){let t=this.metricsNames,e=[];for(let n=0;n<t.length;++n){let s=t[n],o=s;Xx(t,s)>1&&(o+=`_${Xx(t.slice(0,n),s)}`),e.push(o)}return e}makeTrainFunction(){return t=>{let e=[],n=t.slice(0,this.inputs.length),s=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),o=t.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],l=()=>{let m=[];for(let v=0;v<this.inputs.length;++v)m.push({key:this.inputs[v],value:n[v]});let d=new Es(m),y=Tl(this.outputs,d,{training:!0}),_;for(let v=0;v<this.lossFunctions.length;++v){let N=this.lossFunctions[v](s[v],y[v]);o[v]!=null&&(N=zS(N,o[v]));let A=hr(N);e.push(A),v===0?_=N:_=Ot(_,N)}for(let v=0;v<this.metricsTensors.length;++v){let C;if(this.outputs.length>1&&v<this.outputs.length)C=e[v];else{let N=this.metricsTensors[v][0],A=this.metricsTensors[v][1];C=hr(N(s[A],y[A]))}Fr(C),a.push(C)}return _=hr(_),this.calculateLosses().forEach(v=>{_=Ot(_,v)}),_},u=this.collectedTrainableWeights.map(m=>m.read()),p=!0;return[this.optimizer_.minimize(l,p,u)].concat(a)}}makeTestFunction(){this.testFunction=t=>_t(()=>{let e=[],n,s=t.slice(0,this.inputs.length),o=t.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let p=0;p<this.inputs.length;++p)a.push({key:this.inputs[p],value:s[p]});let l=new Es(a),u=Tl(this.outputs,l);for(let p=0;p<this.lossFunctions.length;++p){let f=this.lossFunctions[p],m=hr(f(o[p],u[p]));p===0?n=m:n=Ot(n,m),e.push(n)}for(let p=0;p<this.metricsTensors.length;++p){let f=this.metricsTensors[p][0],m=this.metricsTensors[p][1],d=hr(f(o[m],u[m]));e.push(d)}return e})}async fit(t,e,n={}){return US(this,t,e,n)}async fitDataset(t,e){return GS(this,t,e)}async trainOnBatch(t,e){let n=await this.standardizeUserData(t,e),s=n[0],o=n[1],l=this.makeTrainFunction()(s.concat(o)),u=[];for(let p of l){let f=await p.data();u.push(f[0])}return pe(l),Or(u)}getNamedWeights(t){let e=[],n=t!=null&&t.trainableOnly,s=n?this.trainableWeights:this.weights,o=this.getWeights(n);for(let a=0;a<s.length;++a)n&&!s[a].trainable||e.push({name:s[a].originalName,tensor:o[a]});return e}set stopTraining(t){this.stopTraining_=t}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(t){this.optimizer_!==t&&(this.optimizer_=t,this.isOptimizerOwned=!1)}dispose(){let t=super.dispose();if(t.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){let e=cp().numTensors;this.optimizer_.dispose(),t.numDisposedVariables+=e-cp().numTensors}return t}getLossIdentifiers(){let t;if(typeof this.loss=="string")t=es(this.loss);else if(Array.isArray(this.loss)){for(let e of this.loss)if(typeof e!="string")throw new Error("Serialization of non-string loss is not supported.");t=this.loss.map(e=>es(e))}else{let e=Object.keys(this.loss);t={};let n=this.loss;for(let s of e)if(typeof n[s]=="string")t[s]=es(n[s]);else throw new Error("Serialization of non-string loss is not supported.")}return t}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[es(Up(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(t=>es(Up(t)));{let t={};for(let e in this.metrics)t[e]=es(Up(this.metrics[e]));return t}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(t){if(t.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(t.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(t.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");let e=xc(t.optimizer_config),n=Cn(e),s;if(typeof t.loss=="string")s=li(t.loss);else if(Array.isArray(t.loss))s=t.loss.map(a=>li(a));else if(t.loss!=null){s={};for(let a in t.loss)s[a]=li(t.loss[a])}let o;if(Array.isArray(t.metrics))o=t.metrics.map(a=>li(a));else if(t.metrics!=null){o={};for(let a in t.metrics)o[a]=li(t.metrics[a])}this.compile({loss:s,metrics:o,optimizer:n})}async save(t,e){if(typeof t=="string"){let p=Cs.getSaveHandlers(t);if(p.length===0)throw new ct(`Cannot find any save handlers for URL '${t}'`);if(p.length>1)throw new ct(`Found more than one (${p.length}) save handlers for URL '${t}'`);t=p[0]}if(t.save==null)throw new ct("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");let n=await Cs.encodeWeights(this.getNamedWeights(e)),s=!1,o=null,l={modelTopology:this.toJSON(o,s),format:cB,generatedBy:`TensorFlow.js tfjs-layers v${yc}`,convertedBy:null};if((e==null?!1:e.includeOptimizer)&&this.optimizer!=null){l.trainingConfig=this.getTrainingConfig();let p="optimizer",{data:f,specs:m}=await Cs.encodeWeights(await this.optimizer.getWeights(),p);n.specs.push(...m),n.data=Cs.concatenateArrayBuffers([n.data,f])}if(this.userDefinedMetadata!=null){let p=!0;py(this.userDefinedMetadata,this.name,p),l.userDefinedMetadata=this.userDefinedMetadata}return l.weightData=n.data,l.weightSpecs=n.specs,t.save(l)}setUserDefinedMetadata(t){py(t,this.name),this.userDefinedMetadata=t}getUserDefinedMetadata(){return this.userDefinedMetadata}};As.className="Model";At.registerClass(As);var dy=class extends As{};dy.className="Functional";At.registerClass(dy);async function KS(r,t){if(t==null&&(t={}),typeof r=="string"){let e=Cs.getLoadHandlers(r,t);if(e.length===0)e.push(Cs.browserHTTPRequest(r,t));else if(e.length>1)throw new ct(`Found more than one (${e.length}) load handlers for URL '${r}'`);r=e[0]}return pB(r,void 0,t)}async function pB(r,t,e){if(e==null&&(e={}),r.load==null)throw new ct("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");let n=await r.load(),s=n.modelTopology;s.model_config!=null&&(s=s.model_config);let o=e.strict==null?!0:e.strict,a=n.weightData!=null&&n.weightSpecs!=null&&o,l=Cn(xc(s),t,a),u=n.trainingConfig;if(u!=null&&l.loadTrainingConfig(u),n.userDefinedMetadata!=null&&l.setUserDefinedMetadata(n.userDefinedMetadata),n.weightData!=null){if(n.weightSpecs==null)throw new ct("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");let{modelWeights:p,optimizerWeights:f}=fB(n.weightData,n.weightSpecs);l.loadWeights(p,o),l.optimizer!=null&&f.length>0&&await l.optimizer.setWeights(f),pe(p),pe(f.map(m=>m.tensor))}return l}function fB(r,t){let e=Cs.decodeWeights(r,t),n={},s=[];return t.forEach(o=>{o.group==="optimizer"?s.push({name:o.name,tensor:e[o.name]}):n[o.name]=e[o.name]}),{modelWeights:n,optimizerWeights:s}}var Aa=class extends As{constructor(t){super({inputs:[],outputs:[]});if(t=t||{},this.trainable=!0,this.built=!1,this.name=t.name!=null?t.name:Na("sequential_"),t.layers!=null)for(let e of t.layers)this.add(e)}checkShape(t){if(t.inboundNodes[0].outputTensors[0].shape.some(n=>n<0))throw new ct(`Negative dimension size caused by adding layer ${t.name} with input shape [${t.inboundNodes[0].inputTensors[0].shape}]`)}add(t){let e=t instanceof Aa||t instanceof As,n;if(e){if(n=t,n.outputs.length!==1)throw new ct("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(n.inputs.length!==1)throw new ct("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(t.inboundNodes.length===0){if(t.batchInputShape==null)throw new ct("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");let s=ny({batchShape:t.batchInputShape,dtype:t.dtype,name:t.name+"_input"});t.apply(s)}if(e)this.outputs=n.outputs,this.inputs=n.inputs;else{if(t.inboundNodes.length!==1)throw new ct(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${t.name} which has ${t.inboundNodes.length} pre-existing inbound connections.`);if(t.inboundNodes[0].outputTensors.length!==1)throw new ct("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[t.inboundNodes[0].outputTensors[0]],this.inputs=ry(this.outputs[0])}this.inboundNodes=[],new Ta({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:ts(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(s=>s.shape),outputShapes:this.outputs[0].shape})}else{let s=t.apply(this.outputs[0]);if(Array.isArray(s))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(t),this.outputs=[s],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(t),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{let t=this.layers.length-1;this.layers[t].outboundNodes=[],this.outputs=[this.layers[t].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(t,e){return this.model==null&&this.build(),this.model.call(t,e)}build(t){if(De(t),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new As({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(t,e,n=console.log){this.built||this.build(),super.summary(t,e,n)}setWeights(t){this.model==null&&this.build(),this.model.setWeights(t)}evaluate(t,e,n={}){if(!this.built)throw new on("The model needs to be compiled before being used.");return this.model.evaluate(t,e,n)}async evaluateDataset(t,e){if(!this.built)throw new on("The model needs to be compiled before being used.");return this.model.evaluateDataset(t,e)}predict(t,e={}){return this.model==null&&this.build(),this.model.predict(t,e)}predictOnBatch(t){return this.model==null&&this.build(),this.model.predictOnBatch(t)}compile(t){this.build(),this.model.compile(t),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(t){this.model.optimizer=t}async fit(t,e,n={}){if(!this.built)throw new on("The model needs to be compiled before being used.");return this.model.fit(t,e,n)}async fitDataset(t,e){if(!this.built)throw new on("The model needs to be compiled before being used.");return this.model.fitDataset(t,e)}async trainOnBatch(t,e){return this.model.trainOnBatch(t,e)}static fromConfig(t,e,n={},s=!1){let o,a={};if(e instanceof Array){if(e[0].className==null||e[0].className==="Merge")throw new ct("Legacy serialization format not supported yet.");o=e}else E.assert(e.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),o=e.layers,delete e.layers,a=e;let l=new t(a);if(!(l instanceof Aa))throw new ue(`Sequential.fromConfig called on non-Sequential input: ${l}`);for(let u of o){let f=Cn(u,void 0,s);s&&f.setFastWeightInitDuringBuild(!0),l.add(f)}return l}set stopTraining(t){if(this.model==null)throw new ct("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=t}get stopTraining(){if(this.model==null)throw new ct("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){let t=[];for(let e of this.layers){let n={};n.className=e.getClassName(),n.config=e.getConfig(),t.push(n)}return{name:this.name,layers:t}}};Aa.className="Sequential";At.registerClass(Aa);function gy(r,t){return t==null&&(t={}),KS(r,t)}var kn=class extends At.Serializable{getConfig(){return{}}},xy=class extends kn{apply(t,e=1){return bS(t,e)}};xy.className="elu";At.registerClass(xy);var yy=class extends kn{apply(t){return Gh(t)}};yy.className="selu";At.registerClass(yy);var _y=class extends kn{apply(t){return Ss(t)}};_y.className="relu";At.registerClass(_y);var by=class extends kn{apply(t){return _t(()=>Zu(6,Ss(t)))}};by.className="relu6";At.registerClass(by);var vy=class extends kn{apply(t){return t}};vy.className="linear";At.registerClass(vy);var wy=class extends kn{apply(t){return ii(t)}};wy.className="sigmoid";At.registerClass(wy);var Cy=class extends kn{apply(t){return wS(t)}};Cy.className="hardSigmoid";At.registerClass(Cy);var ky=class extends kn{apply(t){return ka(t)}};ky.className="softplus";At.registerClass(ky);var Sy=class extends kn{apply(t){return vS(t)}};Sy.className="softsign";At.registerClass(Sy);var Iy=class extends kn{apply(t){return Eh(t)}};Iy.className="tanh";At.registerClass(Iy);var jp=class extends kn{apply(t,e=-1){return ec(t,e)}};jp.className="softmax";At.registerClass(jp);var Ny=class extends kn{apply(t,e=-1){return Lh(t,e)}};Ny.className="logSoftmax";At.registerClass(Ny);var Ty=class extends kn{apply(t,e=1){return _t(()=>ii(t.mul(e)).mul(t))}};Ty.className="swish";At.registerClass(Ty);function $s(r){return r.getClassName()}function Ey(r,t={}){return Qs(r,At.SerializationMap.getMap().classNameMap,t,"activation")}function Ds(r){if(r==null){let t={};return t.className="linear",t.config={},Ey(t)}if(typeof r=="string"){let t={};return t.className=r,t.config={},Ey(t)}else return r instanceof kn?r:Ey(r)}function hB(r){if(r!=null&&typeof r!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${r}`)}var Ay=class extends At.Serializable{},Vm=class extends Ay{constructor(t){super();hB(t),this.l1=t==null||t.l1==null?.01:t.l1,this.l2=t==null||t.l2==null?.01:t.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(t){return _t(()=>{let e=lr([1]);return this.hasL1&&(e=Ot(e,ee(ft(this.l1,Ar(t))))),this.hasL2&&(e=Ot(e,ee(ft(this.l2,kl(t))))),e.asScalar()})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(t,e){return new t({l1:e.l1,l2:e.l2})}};Vm.className="L1L2";At.registerClass(Vm);var XS={l1l2:"L1L2"};function qe(r){return ic(r)}function YS(r,t={}){return Qs(r,At.SerializationMap.getMap().classNameMap,t,"regularizer")}function Ye(r){if(r==null)return null;if(typeof r=="string"){let e={className:r in XS?XS[r]:r,config:{}};return YS(e)}else return r instanceof Ay?r:YS(r)}var Gm=class extends _e{constructor(t){super(t??{});this.supportsMasking=!0,t!=null&&(this.maxValue=t.maxValue)}call(t,e){t=xe(t);let n=Ss(t);return this.maxValue!=null&&(n=Hr(n,0,this.maxValue)),n}computeOutputShape(t){return t}getConfig(){let t={maxValue:this.maxValue},e=super.getConfig();return Object.assign(t,e),t}};Gm.className="ReLU";At.registerClass(Gm);var Wm=class extends _e{constructor(t){super(t??{});this.DEFAULT_ALPHA=.3,t==null&&(t={}),this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=xe(t);return Ku(n,this.alpha)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};Wm.className="LeakyReLU";At.registerClass(Wm);var Um=class extends _e{constructor(t){super(t??{});if(this.DEFAULT_ALPHA_INITIALIZER="zeros",t==null&&(t={}),this.supportsMasking=!0,this.alphaInitializer=Ke(t.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ye(t.alphaRegularizer),this.alphaConstraint=dr(t.alphaConstraint),t.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(t.sharedAxes))this.sharedAxes=t.sharedAxes;else if(typeof t.sharedAxes=="number")this.sharedAxes=[t.sharedAxes];else throw new ct(`Expected sharedAxes to be a number or an array of numbers, but got ${t.sharedAxes}`)}build(t){t=De(t);let e=t.slice(1);if(this.sharedAxes!=null)for(let s of this.sharedAxes)e[s-1]=1;this.alpha=this.addWeight("alpha",e,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);let n={};if(this.sharedAxes!=null)for(let s=1;s<t.length;++s)n[s]=t[s];this.inputSpec=[new cr({ndim:t.length,axes:n})],this.built=!0}call(t,e){return t=xe(t),tc(t,this.alpha.read())}getConfig(){let t={alphaInitializer:tr(this.alphaInitializer),alphaRegularizer:qe(this.alphaRegularizer),alphaConstraint:mr(this.alphaConstraint),sharedAxes:this.sharedAxes},e=super.getConfig();return Object.assign(t,e),t}};Um.className="PReLU";At.registerClass(Um);var jm=class extends _e{constructor(t){super(t??{});if(this.DEFAULT_ALPHA=1,t==null&&(t={}),t.alpha!=null&&t.alpha!==this.DEFAULT_ALPHA)throw new ue(`Non-default alpha value (${t.alpha}) is not supported by the ELU layer yet.`);this.alpha=t.alpha==null?this.DEFAULT_ALPHA:t.alpha}call(t,e){let n=xe(t);return wa(n)}computeOutputShape(t){return t}getConfig(){let t={alpha:this.alpha},e=super.getConfig();return Object.assign(t,e),t}};jm.className="ELU";At.registerClass(jm);var qm=class extends _e{constructor(t){super(t??{});this.DEFAULT_THETA=1,t==null&&(t={}),this.theta=t.theta==null?this.DEFAULT_THETA:t.theta}call(t,e){let n=xe(t);return n.mul(ui(n.greater(this.theta),"float32"))}computeOutputShape(t){return t}getConfig(){let t={theta:this.theta},e=super.getConfig();return Object.assign(t,e),t}};qm.className="ThresholdedReLU";At.registerClass(qm);var Hm=class extends _e{constructor(t){super(t??{});this.DEFAULT_AXIS=1,t==null&&(t={}),this.softmax=new jp().apply,this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis}call(t,e){let n=xe(t);return this.softmax(n,this.axis)}computeOutputShape(t){return t}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};Hm.className="Softmax";At.registerClass(Hm);function $a(r,t,e){if(typeof r=="number")return ts(r,t);if(r.length!==t)throw new ct(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${r.length} elements.`);for(let n=0;n<t;++n){let s=r[n];if(!dS(s))throw new ct(`The ${e} argument must be an integer or tuple of ${t} integers. Received: ${JSON.stringify(r)} including a non-integer number ${s}`)}return r}function Sn(r,t,e,n,s=1){if(r==null)return r;let o=t+(t-1)*(s-1),a;return e==="same"?a=r:a=r-o+1,Math.floor((a+n-1)/n)}function qp(r,t,e,n){if(r==null)return null;if(n==="valid")r=r*t+Ts([e-t,0]);else if(n==="same")r=r*t;else throw new ct(`Unsupport padding mode: ${n}.`);return r}function Hp(r,t){return _t(()=>(fr(t),t==="channelsFirst"?Le(r,[0,2,3,1]):r))}function $y(r,t){return _t(()=>(fr(t),t==="channelsFirst"?Le(r,[0,2,3,4,1]):r))}function mB(r,t,e,n=1,s="valid",o,a=1){return _t(()=>{if(o==null&&(o=mn()),fr(o),r.shape.length!==3)throw new ct(`The input of a conv1dWithBias operation should be 3, but is ${r.shape.length} instead.`);if(t.shape.length!==3)throw new ct(`The kernel for a conv1dWithBias operation should be 3, but is ${t.shape.length} instead`);if(e!=null&&e.shape.length!==1)throw new ct(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(o==="channelsFirst"&&(r=Le(r,[0,2,1])),s==="causal")throw new ue("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let l=Ah(r,t,n,s==="same"?"same":"valid","NWC",a);return e!=null&&(l=vn(l,e)),l})}function ZS(r,t,e,n=[1,1],s="valid",o,a,l=null){return _t(()=>{if(o==null&&(o=mn()),fr(o),r.rank!==3&&r.rank!==4)throw new ct(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${r.rank}.`);if(t.rank!==3&&t.rank!==4)throw new ct(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${r.rank}.`);let u=Hp(r,o);if(s==="causal")throw new ue("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return u=oc.conv2d({x:u,filter:t,strides:n,pad:s==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:e,activation:l}),o==="channelsFirst"&&(u=Le(u,[0,3,1,2])),u})}function dB(r,t,e,n=[1,1,1],s="valid",o,a){return _t(()=>{if(o==null&&(o=mn()),fr(o),r.rank!==4&&r.rank!==5)throw new ct(`conv3dWithBias expects input to be of rank 4 or 5, but received ${r.rank}.`);if(t.rank!==4&&t.rank!==5)throw new ct(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${r.rank}.`);let l=$y(r,o);if(s==="causal")throw new ue("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return l=tC(l,t,n,s==="same"?"same":"valid","NDHWC",a),e!=null&&(l=vn(l,e)),o==="channelsFirst"&&(l=Le(l,[0,4,1,2,3])),l})}var bc=class extends _e{constructor(t,e){super(e);if(this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",bc.verifyArgs(e),this.rank=t,_r(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new ue(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=$a(e.kernelSize,t,"kernelSize"),this.strides=$a(e.strides==null?1:e.strides,t,"strides"),this.padding=e.padding==null?"valid":e.padding,dn(this.padding),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,fr(this.dataFormat),this.activation=Ds(e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.biasInitializer=Ke(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=dr(e.biasConstraint),this.biasRegularizer=Ye(e.biasRegularizer),this.activityRegularizer=Ye(e.activityRegularizer),this.dilationRate=$a(e.dilationRate==null?1:e.dilationRate,t,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new ct(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new ct(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new ct(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(t){if(Un("kernelSize"in t,"required key 'kernelSize' not in config"),typeof t.kernelSize!="number"&&!nm(t.kernelSize,"number",1,3))throw new ct(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(t.kernelSize)}.`)}getConfig(){let t={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:$s(this.activation),useBias:this.useBias,biasInitializer:tr(this.biasInitializer),biasRegularizer:qe(this.biasRegularizer),activityRegularizer:qe(this.activityRegularizer),biasConstraint:mr(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}},El=class extends bc{constructor(t,e){super(t,e);this.kernel=null,El.verifyArgs(e),this.filters=e.filters,_r(this.filters,"filters"),this.kernelInitializer=Ke(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=dr(e.kernelConstraint),this.kernelRegularizer=Ye(e.kernelRegularizer)}build(t){t=De(t);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new ct(`The channel dimension of the input should be defined. Found ${t[e]}`);let n=t[e],s=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",s,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[e]:n}}],this.built=!0}call(t,e){return _t(()=>{t=xe(t);let n,s=this.bias==null?null:this.bias.read(),o=sm(this.activation.getClassName());if(o!=null&&this.rank===2)n=ZS(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate,o);else{if(this.rank===1)n=mB(t,this.kernel.read(),s,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)n=ZS(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)n=dB(t,this.kernel.read(),s,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new ue("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(n=this.activation.apply(n))}return n})}computeOutputShape(t){t=De(t);let e=[],n=this.dataFormat==="channelsLast"?t.slice(1,t.length-1):t.slice(2);for(let o=0;o<n.length;++o){let a=Sn(n[o],this.kernelSize[o],this.padding,this.strides[o],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[o]);e.push(a)}let s=[t[0]];return this.dataFormat==="channelsLast"?(s=s.concat(e),s.push(this.filters)):(s.push(this.filters),s=s.concat(e)),s}getConfig(){let t={filters:this.filters,kernelInitializer:tr(this.kernelInitializer),kernelRegularizer:qe(this.kernelRegularizer),kernelConstraint:mr(this.kernelConstraint)},e=super.getConfig();return Object.assign(t,e),t}static verifyArgs(t){if(!("filters"in t)||typeof t.filters!="number"||t.filters<1)throw new ct(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(t.filters)}`)}},Al=class extends El{constructor(t){super(2,t);Al.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!nm(t.kernelSize,"number",1,2))throw new ct(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(t.kernelSize)}.`)}};Al.className="Conv2D";At.registerClass(Al);var vc=class extends El{constructor(t){super(3,t);vc.verifyArgs(t)}getConfig(){let t=super.getConfig();return delete t.rank,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!(Array.isArray(t.kernelSize)&&(t.kernelSize.length===1||t.kernelSize.length===3)))throw new ct(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(t.kernelSize)}.`)}};vc.className="Conv3D";At.registerClass(vc);var Km=class extends Al{constructor(t){super(t);if(this.inputSpec=[new cr({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new ct(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(t){if(t=De(t),t.length!==4)throw new ct("Input should have rank 4; Received input shape: "+JSON.stringify(t));let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null)throw new ct("The channel dimension of the inputs should be defined. Found `None`.");let n=t[e],s=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",s,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new cr({ndim:4,axes:{[e]:n}})],this.built=!0}call(t,e){return _t(()=>{let n=xe(t);if(n.shape.length!==4)throw new ct(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${n.shape.length}`);let s=n.shape,o=s[0],a,l;this.dataFormat==="channelsFirst"?(a=2,l=3):(a=1,l=2);let u=s[a],p=s[l],f=this.kernelSize[0],m=this.kernelSize[1],d=this.strides[0],y=this.strides[1],_=qp(u,d,f,this.padding),v=qp(p,y,m,this.padding),C=[o,_,v,this.filters];this.dataFormat!=="channelsLast"&&(n=Le(n,[0,2,3,1]));let N=$h(n,this.kernel.read(),C,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(N=Le(N,[0,3,1,2])),this.bias!=null&&(N=vn(N,this.bias.read(),this.dataFormat)),this.activation!=null&&(N=this.activation.apply(N)),N})}computeOutputShape(t){t=De(t);let e=t.slice(),n,s,o;this.dataFormat==="channelsFirst"?(n=1,s=2,o=3):(n=3,s=1,o=2);let a=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],p=this.strides[1];return e[n]=this.filters,e[s]=qp(e[s],u,a,this.padding),e[o]=qp(e[o],p,l,this.padding),e}getConfig(){let t=super.getConfig();return delete t.dilationRate,t}};Km.className="Conv2DTranspose";At.registerClass(Km);var Dy=class extends El{constructor(t,e){super(t,e);if(this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,e.filters==null)throw new ct("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(e.kernelInitializer!=null||e.kernelRegularizer!=null||e.kernelConstraint!=null)throw new ct("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(e.padding!=null&&e.padding!=="same"&&e.padding!=="valid")throw new ct(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(e.padding)}`);this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=Ke(e.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ye(e.depthwiseRegularizer),this.depthwiseConstraint=dr(e.depthwiseConstraint),this.pointwiseInitializer=Ke(e.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ye(e.pointwiseRegularizer),this.pointwiseConstraint=dr(e.pointwiseConstraint)}build(t){if(t=De(t),t.length<this.rank+2)throw new ct(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(t)}`);let e=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[e]==null||t[e]<0)throw new ct(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(t[e])}`);let n=t[e],s=this.kernelSize.concat([n,this.depthMultiplier]),o=[];for(let l=0;l<this.rank;++l)o.push(1);o.push(n*this.depthMultiplier,this.filters);let a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",s,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",o,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new cr({ndim:this.rank+2,axes:{[e]:n}})],this.built=!0}call(t,e){return _t(()=>{t=xe(t);let n;if(this.rank===1)throw new ue("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(t=Le(t,[0,2,3,1])),n=Wh(t,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(n=vn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),this.dataFormat==="channelsFirst"&&(n=Le(n,[0,3,1,2])),n})}getConfig(){let t=super.getConfig();return delete t.rank,delete t.kernelInitializer,delete t.kernelRegularizer,delete t.kernelConstraint,t.depthwiseInitializer=tr(this.depthwiseInitializer),t.pointwiseInitializer=tr(this.pointwiseInitializer),t.depthwiseRegularizer=qe(this.depthwiseRegularizer),t.pointwiseRegularizer=qe(this.pointwiseRegularizer),t.depthwiseConstraint=mr(this.depthwiseConstraint),t.pointwiseConstraint=mr(this.pointwiseConstraint),t}};Dy.className="SeparableConv";var Xm=class extends Dy{constructor(t){super(2,t)}};Xm.className="SeparableConv2D";At.registerClass(Xm);var wc=class extends El{constructor(t){super(1,t);wc.verifyArgs(t),this.inputSpec=[{ndim:3}]}getConfig(){let t=super.getConfig();return delete t.rank,delete t.dataFormat,t}static verifyArgs(t){if(typeof t.kernelSize!="number"&&!nm(t.kernelSize,"number",1,1))throw new ct(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(t.kernelSize)}.`)}};wc.className="Conv1D";At.registerClass(wc);var Ym=class extends _e{constructor(t){super(t);typeof t.cropping=="number"?this.cropping=[[t.cropping,t.cropping],[t.cropping,t.cropping]]:typeof t.cropping[0]=="number"?this.cropping=[[t.cropping[0],t.cropping[0]],[t.cropping[1],t.cropping[1]]]:this.cropping=t.cropping,this.dataFormat=t.dataFormat===void 0?"channelsLast":t.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(t){return this.dataFormat==="channelsFirst"?[t[0],t[1],t[2]-this.cropping[0][0]-this.cropping[0][1],t[3]-this.cropping[1][0]-this.cropping[1][1]]:[t[0],t[1]-this.cropping[0][0]-this.cropping[0][1],t[2]-this.cropping[1][0]-this.cropping[1][1],t[3]]}call(t,e){return _t(()=>{if(t=xe(t),this.dataFormat==="channelsLast"){let n=Dp(t,this.cropping[0][0],t.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Dp(n,this.cropping[1][0],t.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{let n=Dp(t,this.cropping[0][0],t.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Dp(n,this.cropping[1][0],t.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){let t={cropping:this.cropping,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};Ym.className="Cropping2D";At.registerClass(Ym);var Zm=class extends _e{constructor(t){super(t);this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=t.size==null?this.DEFAULT_SIZE:t.size,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,fr(this.dataFormat),this.interpolation=t.interpolation==null?"nearest":t.interpolation,fS(this.interpolation)}computeOutputShape(t){if(this.dataFormat==="channelsFirst"){let e=t[2]==null?null:this.size[0]*t[2],n=t[3]==null?null:this.size[1]*t[3];return[t[0],t[1],e,n]}else{let e=t[1]==null?null:this.size[0]*t[1],n=t[2]==null?null:this.size[1]*t[2];return[t[0],e,n,t[3]]}}call(t,e){return _t(()=>{let n=xe(t),s=n.shape;if(this.dataFormat==="channelsFirst"){n=Le(n,[0,2,3,1]);let o=this.size[0]*s[2],a=this.size[1]*s[3],l=this.interpolation==="nearest"?n.resizeNearestNeighbor([o,a]):n.resizeBilinear([o,a]);return Le(l,[0,3,1,2])}else{let o=this.size[0]*s[1],a=this.size[1]*s[2];return this.interpolation==="nearest"?n.resizeNearestNeighbor([o,a]):n.resizeBilinear([o,a])}})}getConfig(){let t={size:this.size,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};Zm.className="UpSampling2D";At.registerClass(Zm);function gB(r,t,e=[1,1],n="valid",s,o){return _t(()=>{s==null&&(s=mn()),fr(s);let a=Hp(r,s);if(r.rank!==4)throw new ct(`Input for depthwiseConv2d is required to be 4-D, but is instead ${r.rank}-D`);if(t.rank!==4)throw new ct(`depthwiseKernel is required to be 4-D, but is instead ${t.rank}-D`);return a=va(a,t,e,n==="same"?"same":"valid","NHWC",o),s==="channelsFirst"&&(a=Le(a,[0,3,1,2])),a})}var Jm=class extends bc{constructor(t){super(2,t);this.depthwiseKernel=null,this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=Ke(t.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=dr(t.depthwiseConstraint),this.depthwiseRegularizer=Ye(t.depthwiseRegularizer)}build(t){if(t=De(t),t.length<4)throw new ct(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(t)}.`);let e=this.dataFormat==="channelsFirst"?1:3;if(t[e]==null||t[e]<0)throw new ct(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${t[e]}).`);let n=t[e],s=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",s,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return _t(()=>{t=xe(t);let n=gB(t,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(n=vn(n,this.bias.read(),this.dataFormat)),this.activation!=null&&(n=this.activation.apply(n)),n})}computeOutputShape(t){t=De(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[1]*this.depthMultiplier:t[3]*this.depthMultiplier,o=Sn(e,this.kernelSize[0],this.padding,this.strides[0]),a=Sn(n,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[t[0],s,o,a]:[t[0],o,a,s]}getConfig(){let t=super.getConfig();return t.depthMultiplier=this.depthMultiplier,t.depthwiseInitializer=tr(this.depthwiseInitializer),t.depthwiseRegularizer=qe(this.depthwiseRegularizer),t.depthwiseConstraint=mr(this.depthwiseRegularizer),t}};Jm.className="DepthwiseConv2D";At.registerClass(Jm);function Ry(r,t,e,n){if(Array.isArray(r)){if(t!=null||e!=null)throw new ct("When inputs is an array, neither initialState or constants should be provided");n!=null&&(e=r.slice(r.length-n,r.length),r=r.slice(0,r.length-n)),r.length>1&&(t=r.slice(1,r.length)),r=r[0]}function s(o){return o==null||Array.isArray(o)?o:[o]}return t=s(t),e=s(e),{inputs:r,initialState:t,constants:e}}function Fy(r,t,e,n=!1,s,o,a=!1,l=!1){return _t(()=>{let u=t.shape.length;if(u<3)throw new ct(`Input should be at least 3D, but is ${u}D.`);let p=[1,0].concat(an(2,u));if(t=Le(t,p),o!=null)throw new ue("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),s!=null&&(s=s.asType("bool").asType("float32"),s.rank===u-1&&(s=nn(s,-1)),s=Le(s,p)),n&&(t=Qn(t,0),s!=null&&(s=Qn(s,0)));let f=[],m,d=e,y=t.shape[0],_=Rn(t),v;s!=null&&(v=Rn(s));for(let N=0;N<y;++N){let A=_[N],B=_t(()=>r(A,d));if(s==null)m=B[0],d=B[1];else{let P=_t(()=>{let L=v[N],Z=Gr(L).sub(L),K=B[0].mul(L).add(d[0].mul(Z)),et=d.map((it,xt)=>B[1][xt].mul(L).add(it.mul(Z)));return{output:K,newStates:et}});m=P.output,d=P.newStates}l&&f.push(m)}let C;return l&&(C=Zr(f,1)),[m,C,d]})}var is=class extends _e{constructor(t){super(t);let e;if(t.cell==null)throw new ct("cell property is missing for the constructor of RNN.");if(Array.isArray(t.cell)?e=new Kp({cells:t.cell}):e=t.cell,e.stateSize==null)throw new ct("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=e,this.returnSequences=t.returnSequences==null?!1:t.returnSequences,this.returnState=t.returnState==null?!1:t.returnState,this.goBackwards=t.goBackwards==null?!1:t.goBackwards,this._stateful=t.stateful==null?!1:t.stateful,this.unroll=t.unroll==null?!1:t.unroll,this.supportsMasking=!0,this.inputSpec=[new cr({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return an(0,t).map(e=>null)}else return this.states_}setStates(t){this.states_=t}computeOutputShape(t){Cm(t)&&(t=t[0]),t=t;let e=this.cell.stateSize;Array.isArray(e)||(e=[e]);let n=e[0],s;if(this.returnSequences?s=[t[0],t[1],n]:s=[t[0],n],this.returnState){let o=[];for(let a of e)o.push([t[0],a]);return[s].concat(o)}else return s}computeMask(t,e){return _t(()=>{Array.isArray(e)&&(e=e[0]);let n=this.returnSequences?e:null;if(this.returnState){let s=this.states.map(o=>null);return[n].concat(s)}else return n})}get states(){if(this.states_==null){let t=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,e=[];for(let n=0;n<t;++n)e.push(null);return e}else return this.states_}set states(t){this.states_=t}build(t){let e=null;if(this.numConstants!=null)throw new ue("Constants support is not implemented in RNN yet.");Cm(t)&&(t=t[0]),t=t;let n=this.stateful?t[0]:null,s=t.slice(2);this.inputSpec[0]=new cr({shape:[n,null,...s]});let o=[t[0]].concat(t.slice(2));if(e!=null)throw new ue("Constants support is not implemented in RNN yet.");this.cell.build(o);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!E.arraysEqual(this.stateSpec.map(l=>l.shape[l.shape.length-1]),a))throw new ct(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(l=>new cr({shape:[null,l]}));this.stateful&&this.resetStates()}resetStates(t,e=!1){_t(()=>{if(!this.stateful)throw new Fn("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape[0];if(n==null)throw new ct("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>lr([n,s])):this.states_=[lr([n,this.cell.stateSize])];else if(t==null)pe(this.states_),this.keptStates!=null&&(pe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(s=>lr([n,s])):this.states_[0]=lr([n,this.cell.stateSize]);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ct(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e===!0?this.keptStates.push(this.states_.slice()):pe(this.states_);for(let s=0;s<this.states_.length;++s){let o=t[s],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[s]:this.cell.stateSize,l=[n,a];if(!E.arraysEqual(o.shape,l))throw new ct(`State ${s} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${o.shape}`);this.states_[s]=o}}this.states_=this.states_.map(s=>Fr(s.clone()))})}apply(t,e){let n=e==null?null:e.initialState,s=e==null?null:e.constants;e==null&&(e={});let o=Ry(t,n,s,this.numConstants);t=o.inputs,n=o.initialState,s=o.constants;let a=[],l=[];if(n!=null){e.initialState=n,a=a.concat(n),this.stateSpec=[];for(let p of n)this.stateSpec.push(new cr({shape:p.shape}));l=l.concat(this.stateSpec)}if(s!=null&&(e.constants=s,a=a.concat(s),this.numConstants=s.length),a[0]instanceof xn){let p=[t].concat(a),f=this.inputSpec.concat(l),m=this.inputSpec;this.inputSpec=f;let d=super.apply(p,e);return this.inputSpec=m,d}else return super.apply(t,e)}call(t,e){return _t(()=>{let n=e==null?null:e.mask,s=e==null?null:e.training,o=e==null?null:e.initialState;t=xe(t),o==null&&(this.stateful?o=this.states_:o=this.getInitialState(t));let a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(o.length!==a)throw new ct(`RNN Layer has ${a} state(s) but was passed ${o.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");let l={training:s},p=Fy((_,v)=>{let C=this.cell.call([_].concat(v),l);return[C[0],C.slice(1)]},t,o,this.goBackwards,n,null,this.unroll,this.returnSequences),f=p[0],m=p[1],d=p[2];this.stateful&&this.resetStates(d,s);let y=this.returnSequences?m:f;return this.returnState?[y].concat(d):y})}getInitialState(t){return _t(()=>{let e=lr(t.shape);return e=ee(e,[1,2]),e=ci(e),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(n=>n>1?pm(e,[1,n]):e):this.cell.stateSize>1?[pm(e,[1,this.cell.stateSize])]:[e]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(t)}getConfig(){let t=super.getConfig(),e={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(e.numConstants=this.numConstants);let n=this.cell.getConfig();return this.getClassName()===is.className&&(e.cell={className:this.cell.getClassName(),config:n}),Object.assign({},n,t,e)}static fromConfig(t,e,n={}){let s=e.cell,o=Cn(s,n);return new t(Object.assign(e,{cell:o}))}};is.className="RNN";At.registerClass(is);var $l=class extends _e{},Xp=class extends $l{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,_r(this.units,"units"),this.activation=Ds(t.activation==null?this.DEFAULT_ACTIVATION:t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Ke(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ke(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ke(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ye(t.kernelRegularizer),this.recurrentRegularizer=Ye(t.recurrentRegularizer),this.biasRegularizer=Ye(t.biasRegularizer),this.kernelConstraint=dr(t.kernelConstraint),this.recurrentConstraint=dr(t.recurrentConstraint),this.biasConstraint=dr(t.biasConstraint),this.dropout=Cl([1,Ts([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Cl([1,Ts([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=De(t),this.kernel=this.addWeight("kernel",[t[t.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return _t(()=>{if(t=t,t.length!==2)throw new ct(`SimpleRNNCell expects 2 input Tensors, got ${t.length}.`);let n=t[1];t=t[0];let s=e.training==null?!1:e.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=mi({ones:()=>Gr(t),rate:this.dropout,training:s})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=mi({ones:()=>Gr(n),rate:this.recurrentDropout,training:s}));let o,a=this.dropoutMask,l=this.recurrentDropoutMask;a!=null?o=os(ft(t,a),this.kernel.read()):o=os(t,this.kernel.read()),this.bias!=null&&(o=vn(o,this.bias.read())),l!=null&&(n=ft(n,l));let u=Ot(o,os(n,this.recurrentKernel.read()));return this.activation!=null&&(u=this.activation.apply(u)),[u,u]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:$s(this.activation),useBias:this.useBias,kernelInitializer:tr(this.kernelInitializer),recurrentInitializer:tr(this.recurrentInitializer),biasInitializer:tr(this.biasInitializer),kernelRegularizer:qe(this.kernelRegularizer),recurrentRegularizer:qe(this.recurrentRegularizer),biasRegularizer:qe(this.biasRegularizer),activityRegularizer:qe(this.activityRegularizer),kernelConstraint:mr(this.kernelConstraint),recurrentConstraint:mr(this.recurrentConstraint),biasConstraint:mr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},t,e)}};Xp.className="SimpleRNNCell";At.registerClass(Xp);var Qm=class extends is{constructor(t){t.cell=new Xp(t),super(t)}call(t,e){return _t(()=>{this.cell.dropoutMask!=null&&(pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,s=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:n,training:s,initialState:o})})}static fromConfig(t,e){return new t(e)}};Qm.className="SimpleRNN";At.registerClass(Qm);var Yp=class extends $l{constructor(t){super(t);if(this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.resetAfter)throw new ct("GRUCell does not support reset_after parameter set to true.");this.units=t.units,_r(this.units,"units"),this.activation=Ds(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Ds(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Ke(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ke(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ke(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ye(t.kernelRegularizer),this.recurrentRegularizer=Ye(t.recurrentRegularizer),this.biasRegularizer=Ye(t.biasRegularizer),this.kernelConstraint=dr(t.kernelConstraint),this.recurrentConstraint=dr(t.recurrentConstraint),this.biasConstraint=dr(t.biasConstraint),this.dropout=Cl([1,Ts([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Cl([1,Ts([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){t=De(t);let e=t[t.length-1];this.kernel=this.addWeight("kernel",[e,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(t,e){return _t(()=>{if(t=t,t.length!==2)throw new ct(`GRUCell expects 2 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training==null?!1:e.training,s=t[1];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=mi({ones:()=>Gr(t),rate:this.dropout,training:n,count:3})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=mi({ones:()=>Gr(s),rate:this.recurrentDropout,training:n,count:3}));let o=this.dropoutMask,a=this.recurrentDropoutMask,l,u,p;0<this.dropout&&this.dropout<1&&(t=ft(t,o[0]));let f=os(t,this.kernel.read());this.useBias&&(f=vn(f,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(s=ft(s,a[0]));let m=this.recurrentKernel.read(),[d,y]=Yr(m,[2*this.units,this.units],m.rank-1),_=os(s,d),[v,C,N]=Yr(f,3,f.rank-1),[A,B]=Yr(_,2,_.rank-1);l=this.recurrentActivation.apply(Ot(v,A)),u=this.recurrentActivation.apply(Ot(C,B));let P=os(ft(u,s),y);p=this.activation.apply(Ot(N,P));let L=Ot(ft(l,s),ft(Ot(1,je(l)),p));return[L,L]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:$s(this.activation),recurrentActivation:$s(this.recurrentActivation),useBias:this.useBias,kernelInitializer:tr(this.kernelInitializer),recurrentInitializer:tr(this.recurrentInitializer),biasInitializer:tr(this.biasInitializer),kernelRegularizer:qe(this.kernelRegularizer),recurrentRegularizer:qe(this.recurrentRegularizer),biasRegularizer:qe(this.biasRegularizer),activityRegularizer:qe(this.activityRegularizer),kernelConstraint:mr(this.kernelConstraint),recurrentConstraint:mr(this.recurrentConstraint),biasConstraint:mr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},t,e)}};Yp.className="GRUCell";At.registerClass(Yp);var td=class extends is{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Yp(t),super(t)}call(t,e){return _t(()=>{this.cell.dropoutMask!=null&&(pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,s=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:n,training:s,initialState:o})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};td.className="GRU";At.registerClass(td);var Dl=class extends $l{constructor(t){super(t);this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=t.units,_r(this.units,"units"),this.activation=Ds(t.activation===void 0?this.DEFAULT_ACTIVATION:t.activation),this.recurrentActivation=Ds(t.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:t.recurrentActivation),this.useBias=t.useBias==null?!0:t.useBias,this.kernelInitializer=Ke(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=Ke(t.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=Ke(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=t.unitForgetBias,this.kernelRegularizer=Ye(t.kernelRegularizer),this.recurrentRegularizer=Ye(t.recurrentRegularizer),this.biasRegularizer=Ye(t.biasRegularizer),this.kernelConstraint=dr(t.kernelConstraint),this.recurrentConstraint=dr(t.recurrentConstraint),this.biasConstraint=dr(t.biasConstraint),this.dropout=Cl([1,Ts([0,t.dropout==null?0:t.dropout])]),this.recurrentDropout=Cl([1,Ts([0,t.recurrentDropout==null?0:t.recurrentDropout])]),this.implementation=t.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(t){var e;t=De(t);let n=t[t.length-1];this.kernel=this.addWeight("kernel",[n,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let s;if(this.useBias){if(this.unitForgetBias){let o=this.biasInitializer,a=this.units;s=new(e=class extends wn{apply(u,p){let f=o.apply([a]),m=new pc().apply([a]),d=o.apply([a*2]);return ty(ty(f,m),d)}},e.className="CustomInit",e)}else s=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,s,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(t,e){return _t(()=>{let n=e.training==null?!1:e.training;if(t=t,t.length!==3)throw new ct(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let s=t[1],o=t[2];t=t[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=mi({ones:()=>Gr(t),rate:this.dropout,training:n,count:4})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=mi({ones:()=>Gr(s),rate:this.recurrentDropout,training:n,count:4}));let a=this.dropoutMask,l=this.recurrentDropoutMask,u,p,f,m;0<this.dropout&&this.dropout<1&&(t=ft(t,a[0]));let d=os(t,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(s=ft(s,l[0])),d=Ot(d,os(s,this.recurrentKernel.read())),this.useBias&&(d=vn(d,this.bias.read()));let[y,_,v,C]=Yr(d,4,d.rank-1);u=this.recurrentActivation.apply(y),p=this.recurrentActivation.apply(_),f=Ot(ft(p,o),ft(u,this.activation.apply(v))),m=this.recurrentActivation.apply(C);let N=ft(m,this.activation.apply(f));return[N,N,f]})}getConfig(){let t=super.getConfig(),e={units:this.units,activation:$s(this.activation),recurrentActivation:$s(this.recurrentActivation),useBias:this.useBias,kernelInitializer:tr(this.kernelInitializer),recurrentInitializer:tr(this.recurrentInitializer),biasInitializer:tr(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:qe(this.kernelRegularizer),recurrentRegularizer:qe(this.recurrentRegularizer),biasRegularizer:qe(this.biasRegularizer),activityRegularizer:qe(this.activityRegularizer),kernelConstraint:mr(this.kernelConstraint),recurrentConstraint:mr(this.recurrentConstraint),biasConstraint:mr(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},t,e)}};Dl.className="LSTMCell";At.registerClass(Dl);var ed=class extends is{constructor(t){t.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),t.cell=new Dl(t),super(t)}call(t,e){return _t(()=>{this.cell.dropoutMask!=null&&(pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);let n=e==null?null:e.mask,s=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:n,training:s,initialState:o})})}static fromConfig(t,e){return e.implmentation===0&&(e.implementation=1),new t(e)}};ed.className="LSTM";At.registerClass(ed);var Kp=class extends $l{constructor(t){super(t);this.cells=t.cells}get stateSize(){let t=[];for(let e of this.cells.slice().reverse())Array.isArray(e.stateSize)?t.push(...e.stateSize):t.push(e.stateSize);return t}call(t,e){return _t(()=>{t=t;let n=t.slice(1),s=[];for(let l of this.cells.slice().reverse())Array.isArray(l.stateSize)?s.push(n.splice(0,l.stateSize.length)):s.push(n.splice(0,1));s.reverse();let o=[],a;for(let l=0;l<this.cells.length;++l){let u=this.cells[l];n=s[l],l===0?a=[t[0]].concat(n):a=[a[0]].concat(n),a=u.call(a,e),o.push(a.slice(1))}n=[];for(let l of o.slice().reverse())n.push(...l);return[a[0]].concat(n)})}build(t){Cm(t)&&(t=t[0]),t=t;let e;this.cells.forEach((n,s)=>{Ns(`RNNCell_${s}`,()=>{n.build(t),Array.isArray(n.stateSize)?e=n.stateSize[0]:e=n.stateSize,t=[t[0],e]})}),this.built=!0}getConfig(){let t=super.getConfig(),e=o=>({className:o.getClassName(),config:o.getConfig()}),s={cells:this.cells.map(e)};return Object.assign({},t,s)}static fromConfig(t,e,n={}){let s=[];for(let o of e.cells)s.push(Cn(o,n));return new t({cells:s})}get trainableWeights(){if(!this.trainable)return[];let t=[];for(let e of this.cells)t.push(...e.trainableWeights);return t}get nonTrainableWeights(){let t=[];for(let e of this.cells)t.push(...e.nonTrainableWeights);if(!this.trainable){let e=[];for(let n of this.cells)e.push(...n.trainableWeights);return e.concat(t)}return t}getWeights(){let t=[];for(let e of this.cells)t.push(...e.weights);return Mp(t)}setWeights(t){let e=[];for(let n of this.cells){let s=n.weights.length,o=t.splice(s);for(let a=0;a<n.weights.length;++a)e.push([n.weights[a],o[a]])}mc(e)}};Kp.className="StackedRNNCells";At.registerClass(Kp);function mi(r){let{ones:t,rate:e,training:n=!1,count:s=1}=r,o=()=>hm(t(),e),a=()=>Ia(o,t,n);return!s||s<=1?Fr(a().clone()):Array(s).fill(void 0).map(a).map(u=>Fr(u.clone()))}var xB=function(r,t){var e={};for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&t.indexOf(n)<0&&(e[n]=r[n]);if(r!=null&&typeof Object.getOwnPropertySymbols=="function")for(var s=0,n=Object.getOwnPropertySymbols(r);s<n.length;s++)t.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(r,n[s])&&(e[n[s]]=r[n[s]]);return e};var Oy=class extends is{constructor(t){if(t.unroll)throw new ue("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(t.cell))throw new ue("It is not possible at the moment to stack convolutional cells.");super(t);this.inputSpec=[new cr({ndim:5})]}call(t,e){return _t(()=>{if(this.cell.dropoutMask!=null&&(pe(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(pe(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),e&&e.constants)throw new ct("ConvRNN2D cell does not support constants");let n=e==null?null:e.mask,s=e==null?null:e.training,o=e==null?null:e.initialState;return super.call(t,{mask:n,training:s,initialState:o})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(t){return _t(()=>{let{stateSize:e}=this.cell,n=t.shape,s=this.computeSingleOutputShape(n),o=[s[0],...s.slice(2)],a=lr(o);return Array.isArray(e)?Array(e.length).fill(a):[a]})}resetStates(t,e=!1){_t(()=>{if(!this.stateful)throw new Fn("Cannot call resetStates() on an RNN Layer that is not stateful.");let n=this.inputSpec[0].shape,s=this.computeSingleOutputShape(n),o=[s[0],...s.slice(2)];if(n[0]==null)throw new ct("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>lr(o)):this.states_=[lr(o)];else if(t==null)pe(this.states_),this.keptStates!=null&&(pe(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>lr(o)):this.states_[0]=lr(o);else{if(Array.isArray(t)||(t=[t]),t.length!==this.states_.length)throw new ct(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${t.length} state value(s). Input received: ${t}`);e?this.keptStates.push(this.states_.slice()):pe(this.states_);for(let l=0;l<this.states_.length;++l){let u=t[l],p=o;if(!E.arraysEqual(u.shape,p))throw new ct(`State ${l} is incompatible with layer ${this.name}: expected shape=${p}, received shape=${u.shape}`);this.states_[l]=u}}this.states_=this.states_.map(l=>Fr(l.clone()))})}computeSingleOutputShape(t){let{dataFormat:e,filters:n,kernelSize:s,padding:o,strides:a,dilationRate:l}=this.cell,u=e==="channelsFirst",p=t[u?3:2],f=t[u?4:3],m=Sn(p,s[0],o,a[0],l[0]),d=Sn(f,s[1],o,a[1],l[1]);return[...t.slice(0,2),...u?[n,m,d]:[m,d,n]]}};Oy.className="ConvRNN2D";var Zp=class extends Dl{constructor(t){let{filters:e,kernelSize:n,strides:s,padding:o,dataFormat:a,dilationRate:l}=t;super(Object.assign({},t,{units:e}));this.filters=e,_r(this.filters,"filters"),this.kernelSize=$a(n,2,"kernelSize"),this.kernelSize.forEach(u=>_r(u,"kernelSize")),this.strides=$a(s||1,2,"strides"),this.strides.forEach(u=>_r(u,"strides")),this.padding=o||"valid",dn(this.padding),this.dataFormat=a||"channelsLast",fr(this.dataFormat),this.dilationRate=$a(l||1,2,"dilationRate"),this.dilationRate.forEach(u=>_r(u,"dilationRate"))}build(t){var e;t=De(t);let n=this.dataFormat==="channelsFirst"?1:t.length-1;if(t[n]==null)throw new ct(`The channel dimension of the input should be defined. Found ${t[n]}`);let s=t[n],o=4,a=this.kernelSize.concat([s,this.filters*o]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);let l=this.kernelSize.concat([this.filters,this.filters*o]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",l,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let u;if(this.unitForgetBias){let p=this.biasInitializer,f=this.filters;u=new(e=class extends wn{apply(d,y){let _=p.apply([f]),v=Wn([f]),C=p.apply([f*2]);return uc([_,v,C])}},e.className="CustomInit",e)}else u=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*o],null,u,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(t,e){return _t(()=>{if(t.length!==3)throw new ct(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${t.length}.`);let n=e.training||!1,s=t[0],o=t[1],a=t[2],l=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=mi({ones:()=>Gr(s),rate:this.dropout,training:n,count:l}));let u=this.dropoutMask,p=(zt,Mt,jt)=>!Mt||!Mt[jt]?zt:ft(Mt[jt],zt),f=p(s,u,0),m=p(s,u,1),d=p(s,u,2),y=p(s,u,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=mi({ones:()=>Gr(o),rate:this.recurrentDropout,training:n,count:l}));let _=this.recurrentDropoutMask,v=p(o,_,0),C=p(o,_,1),N=p(o,_,2),A=p(o,_,3),B=3,[P,L,Z,K]=Yr(this.kernel.read(),l,B),[et,it,xt,wt]=this.useBias?Yr(this.bias.read(),l):[null,null,null,null];f=this.inputConv(f,P,et,this.padding),m=this.inputConv(m,L,it,this.padding),d=this.inputConv(d,Z,xt,this.padding),y=this.inputConv(y,K,wt,this.padding);let[St,yt,Nt,ht]=Yr(this.recurrentKernel.read(),l,B);v=this.recurrentConv(v,St),C=this.recurrentConv(C,yt),N=this.recurrentConv(N,Nt),A=this.recurrentConv(A,ht);let It=this.recurrentActivation.apply(Ot(f,v)),Ft=this.recurrentActivation.apply(Ot(m,C)),Ct=Ot(ft(Ft,a),ft(It,this.activation.apply(Ot(d,N)))),Dt=ft(this.recurrentActivation.apply(Ot(y,A)),this.activation.apply(Ct));return[Dt,Dt,Ct]})}getConfig(){let t=super.getConfig(),{units:e}=t,n=xB(t,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},n,s)}inputConv(t,e,n,s){let o=Bn(t,e,this.strides,s||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return n?vn(o,n,this.dataFormat):o}recurrentConv(t,e){return Bn(t,e,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Zp.className="ConvLSTM2DCell";At.registerClass(Zp);var rd=class extends Oy{constructor(t){let e=new Zp(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}};rd.className="ConvLSTM2D";At.registerClass(rd);var Jp=class extends _e{constructor(t){super(t);this.rate=Math.max(Math.min(t.rate,1),0),this.noiseShape=t.noiseShape,this.seed=t.seed,this.supportsMasking=!0}getNoiseShape(t){if(this.noiseShape==null)return this.noiseShape;let e=t.shape,n=[];for(let s=0;s<this.noiseShape.length;++s)n.push(this.noiseShape[s]==null?e[s]:this.noiseShape[s]);return n}call(t,e){return _t(()=>{this.invokeCallHook(t,e);let n=xe(t);if(0<this.rate&&this.rate<1){let s=e.training==null?!1:e.training,o=this.getNoiseShape(n);return Ia(()=>hm(n,this.rate,o,this.seed),()=>n,s)}return t})}getConfig(){let t={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},e=super.getConfig();return Object.assign(t,e),t}dispose(){return super.dispose()}};Jp.className="Dropout";At.registerClass(Jp);var nd=class extends Jp{constructor(t){super(t);this.inputSpec=[{ndim:3}]}getNoiseShape(t){let e=t.shape;return[e[0],1,e[2]]}};nd.className="SpatialDropout1D";At.registerClass(nd);var sd=class extends _e{constructor(t){super(t);if(this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",t.batchInputShape==null&&t.inputShape==null&&t.inputDim!=null){let e=null;t.batchSize!=null&&(e=t.batchSize),this.batchInputShape=[e,t.inputDim]}this.units=t.units,_r(this.units,"units"),this.activation=Ds(t.activation),t.useBias!=null&&(this.useBias=t.useBias),this.kernelInitializer=Ke(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=Ke(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=dr(t.kernelConstraint),this.biasConstraint=dr(t.biasConstraint),this.kernelRegularizer=Ye(t.kernelRegularizer),this.biasRegularizer=Ye(t.biasRegularizer),this.activityRegularizer=Ye(t.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(t){t=De(t);let e=t[t.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[e,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:e}}],this.built=!0}computeOutputShape(t){t=De(t);let e=t.slice();return e[e.length-1]=this.units,e}call(t,e){return _t(()=>{this.invokeCallHook(t,e);let n=xe(t),s=sm(this.activation.getClassName()),o;return s!=null?o=os(n,this.kernel.read(),s,this.bias?this.bias.read():null):(o=os(n,this.kernel.read()),this.bias!=null&&(o=vn(o,this.bias.read())),this.activation!=null&&(o=this.activation.apply(o))),o})}getConfig(){let t={units:this.units,activation:$s(this.activation),useBias:this.useBias,kernelInitializer:tr(this.kernelInitializer),biasInitializer:tr(this.biasInitializer),kernelRegularizer:qe(this.kernelRegularizer),biasRegularizer:qe(this.biasRegularizer),activityRegularizer:qe(this.activityRegularizer),kernelConstraint:mr(this.kernelConstraint),biasConstraint:mr(this.biasConstraint)},e=super.getConfig();return Object.assign(t,e),t}};sd.className="Dense";At.registerClass(sd);var od=class extends _e{constructor(t){t=t||{},super(t),this.inputSpec=[{minNDim:3}],this.dataFormat=t.dataFormat}computeOutputShape(t){t=De(t);for(let e of t.slice(1))if(e==null)throw new ct(`The shape of the input to "Flatten" is not fully defined (got ${t.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[t[0],ss(t,1)]}call(t,e){return _t(()=>{this.invokeCallHook(t,e);let n=xe(t);if(this.dataFormat==="channelsFirst"&&n.rank>1){let s=[0];for(let o=2;o<n.rank;++o)s.push(o);s.push(1),n=n.transpose(s)}return _S(n)})}getConfig(){let t={};this.dataFormat!=null&&(t.dataFormat=this.dataFormat);let e=super.getConfig();return Object.assign(t,e),t}};od.className="Flatten";At.registerClass(od);var id=class extends _e{constructor(t){super(t);this.supportsMasking=!0,this.activation=Ds(t.activation)}call(t,e){return _t(()=>{this.invokeCallHook(t,e);let n=xe(t);return this.activation.apply(n)})}getConfig(){let t={activation:$s(this.activation)},e=super.getConfig();return Object.assign(t,e),t}};id.className="Activation";At.registerClass(id);var ad=class extends _e{constructor(t){super(t);this.n=t.n,this.inputSpec=[{ndim:2}]}computeOutputShape(t){return[t[0],this.n,t[1]]}call(t,e){return _t(()=>(t=xe(t),xS(t,this.n)))}getConfig(){let t={n:this.n},e=super.getConfig();return Object.assign(t,e),t}};ad.className="RepeatVector";At.registerClass(ad);var ld=class extends _e{constructor(t){super(t);this.targetShape=t.targetShape;for(let e=0;e<this.targetShape.length;++e)this.isUnknown(this.targetShape[e])&&(this.targetShape[e]=null)}isUnknown(t){return t<0||t==null}fixUnknownDimension(t,e){let n="Total size of new array must be unchanged.",s=e.slice(),o=1,a=null;for(let u=0;u<s.length;++u){let p=s[u];if(this.isUnknown(p))if(a===null)a=u;else throw new ct("Can only specifiy one unknown dimension.");else o*=p}let l=ss(t);if(a!==null){if(o===0||l%o!=0)throw new ct(n);s[a]=l/o}else if(l!==o)throw new ct(n);return s}computeOutputShape(t){let e=!1;for(let n=0;n<t.length;++n)if(this.isUnknown(t[n])){e=!0;break}return e?t.slice(0,1).concat(this.targetShape):t.slice(0,1).concat(this.fixUnknownDimension(t.slice(1),this.targetShape))}call(t,e){return _t(()=>{this.invokeCallHook(t,e);let n=xe(t),s=n.shape,o=s.slice(0,1).concat(this.fixUnknownDimension(s.slice(1),this.targetShape));return n.reshape(o)})}getConfig(){let t={targetShape:this.targetShape},e=super.getConfig();return Object.assign(t,e),t}};ld.className="Reshape";At.registerClass(ld);var ud=class extends _e{constructor(t){super(t);if(t.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(t.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${t.dims} instead.`);let e=an(1,t.dims.length+1);if(!E.arraysEqual(t.dims.slice().sort(),e))throw new Error("Invalid permutation `dims`: "+JSON.stringify(t.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=t.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new cr({ndim:this.dims.length+1})]}computeOutputShape(t){t=De(t);let e=t.slice();return this.dims.forEach((n,s)=>{e[s+1]=t[n]}),e}call(t,e){return Le(xe(t),this.dimsIncludingBatch)}getConfig(){let t={dims:this.dims},e=super.getConfig();return Object.assign(t,e),t}};ud.className="Permute";At.registerClass(ud);var cd=class extends _e{constructor(t){super(t??{});this.supportsMasking=!0,t!=null?this.maskValue=t.maskValue==null?0:t.maskValue:this.maskValue=0}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={maskValue:this.maskValue};return Object.assign(e,t),e}computeMask(t,e){let n=xe(t),s=-1;return pp(dl(n,this.maskValue),s)}call(t,e){return _t(()=>{this.invokeCallHook(t,e);let n=xe(t),s=-1,o=!0,a=pp(dl(n,this.maskValue),s,o);return n.mul(a.asType(n.dtype))})}};cd.className="Masking";At.registerClass(cd);var pd=class extends _e{constructor(t){super(t);if(this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",t.batchInputShape==null&&t.inputShape==null){let e=null;t.batchSize!=null&&(e=t.batchSize),t.inputLength==null?this.batchInputShape=[e,null]:this.batchInputShape=[e].concat(Xe(t.inputLength))}this.inputDim=t.inputDim,_r(this.inputDim,"inputDim"),this.outputDim=t.outputDim,_r(this.outputDim,"outputDim"),this.embeddingsInitializer=Ke(t.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ye(t.embeddingsRegularizer),this.activityRegularizer=Ye(t.activityRegularizer),this.embeddingsConstraint=dr(t.embeddingsConstraint),this.maskZero=t.maskZero,this.supportsMasking=t.maskZero,this.inputLength=t.inputLength}build(t){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(t){}computeMask(t,e){return _t(()=>this.maskZero?(t=xe(t),dl(t,le(t))):null)}computeOutputShape(t){if(t=De(t),this.inputLength==null)return[...t,this.outputDim];let e=Xe(this.inputLength);if(e.length!==t.length-1)throw new ct(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);{let n=0;for(let s=0;s<e.length;++s){let o=e[s],a=t[s+1];if(o!=null&&a!=null&&o!==a)throw new ct(`"inputLength" is ${this.inputLength}, but received input shape has shape ${t}`);o==null&&(e[n]=a),n++}}return[t[0],...e,this.outputDim]}call(t,e){return _t(()=>{this.invokeCallHook(t,e);let n=xe(t);return n.dtype!=="int32"&&(n=ui(n,"int32")),fm(this.embeddings.read(),n.as1D()).reshape(De(this.computeOutputShape(n.shape)))})}getConfig(){let t={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:tr(this.embeddingsInitializer),embeddingsRegularizer:qe(this.embeddingsRegularizer),activityRegularizer:qe(this.activityRegularizer),embeddingsConstraint:mr(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},e=super.getConfig();return Object.assign(t,e),t}};pd.className="Embedding";At.registerClass(pd);var Da=class extends _e{constructor(t){super(t||{});this.supportsMasking=!0}mergeFunction(t){throw new ue}computeElementwiseOpOutputShape(t,e){if(t==null||e==null)return null;if(t.length<e.length)return this.computeElementwiseOpOutputShape(e,t);if(e.length===0)return t;let n=t.slice(0,t.length-e.length);for(let s=0;s<e.length;++s){let o=t[t.length-e.length+s],a=e[s];if(o==null||a==null||o<0||a<0)n.push(null);else if(o===1)n.push(a);else if(a===1)n.push(o);else{if(o!==a)throw new ct("Operands could not be broadcast together with shapes "+JSON.stringify(t)+" "+JSON.stringify(e));n.push(o)}}return n}build(t){if(Array.isArray(t)&&!Array.isArray(t[0])&&(t=[De(t)]),t=t,t.length<2)throw new ct(`A merge layer should be called on an Array of at least 2 inputs. Got ${t.length} input(s).`);let e=[];for(let o of t)o!=null&&o[0]!==null&&e.push(o[0]);if(e=ns(e),e.length>1)throw new ct(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(t)}.`);let n=t[0]==null?null:t[0].slice(1);for(let o=1;o<t.length;++o){let a=t[o]==null?null:t[o].slice(1);n=this.computeElementwiseOpOutputShape(n,a)}let s=t.map(o=>o.length);t.indexOf(null)===-1&&ns(s).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(t,e){return _t(()=>{if(t=t,this.reshapeRequired){let n=[],s=t.map(o=>o.rank);if(s.indexOf(null)===-1){let o=Ts(s);for(let a of t){let l=a.rank;for(let u=0;u<o-l;++u)a=ci(a,1);n.push(a)}return this.mergeFunction(n)}else{let o=!1;for(let u of t){let p=u.rank;if(p==null){let f=u.shape,m=f[0],d=f.slice(1).concat([m]),y=u.reshape([m].concat(ss(f.slice(1))));y=Le(y,[1,0]),y=y.reshape(d),n.push(y),o=!0}else if(p>1){let f=an(1,p).concat([0]);n.push(Le(u,f)),o=!0}else n.push(u)}let a=this.mergeFunction(n),l=a.rank;if(o){if(l==null){let u=a.shape,p=u.length,f=u[p-1],m=[f].concat(u.slice(0,u.length-1));a=Le(a.reshape([-1,f]),[1,0]).reshape(m)}else if(l>1){let u=[l-1].concat(an(0,l-1));a=Le(a,u)}}return a}}else return this.mergeFunction(t)})}computeOutputShape(t){t=t;let e;t[0]==null?e=null:e=t[0].slice(1);for(let s=1;s<t.length;++s){let o=t[s]==null?null:t[s].slice(1);e=this.computeElementwiseOpOutputShape(e,o)}let n=[];for(let s of t)s!=null&&s[0]!==null&&n.push(s[0]);return n=ns(n),n.length===1?e=n.concat(e):e=[null].concat(e),e}computeMask(t,e){return _t(()=>{if(e==null)return null;if(!Array.isArray(e))throw new ct("`mask` should be an Array");if(!Array.isArray(t))throw new ct("`inputs` should be an Array");if(e.length!==t.length)throw new ct(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${t.length} vs ${e.length})`);if(e.every(s=>s==null))return null;e=e.map(s=>s==null?s:nn(s,0));let n=e[0];for(let s=1;s<e.length-1;++s)n=fn(n,e[s]);return n})}},fd=class extends Da{constructor(t){super(t)}mergeFunction(t){return _t(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Ot(e,t[n]);return e})}};fd.className="Add";At.registerClass(fd);var hd=class extends Da{constructor(t){super(t)}mergeFunction(t){return _t(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=ft(e,t[n]);return e})}};hd.className="Multiply";At.registerClass(hd);var md=class extends Da{constructor(t){super(t)}mergeFunction(t){return _t(()=>{let e=t[0].clone();for(let n=1;n<t.length;++n)e=Ot(e,t[n]);return ft(1/t.length,e)})}};md.className="Average";At.registerClass(md);var dd=class extends Da{constructor(t){super(t)}mergeFunction(t){return _t(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Gn(e,t[n]);return e})}};dd.className="Maximum";At.registerClass(dd);var gd=class extends Da{constructor(t){super(t)}mergeFunction(t){return _t(()=>{let e=t[0];for(let n=1;n<t.length;++n)e=Zu(e,t[n]);return e})}};gd.className="Minimum";At.registerClass(gd);var xd=class extends Da{constructor(t){super(t);this.DEFAULT_AXIS=-1,t==null&&(t={}),this.axis=t.axis==null?this.DEFAULT_AXIS:t.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){if(!(Array.isArray(t)&&Array.isArray(t[0]))||t.length===1)throw new ct("A `Concatenate` layer should be called on a list of at least 2 inputs");t=t;let e=!0;for(let s of t)if(s!=null){e=!1;break}if(e)return;let n=[];for(let s=0;s<t.length;++s){let o=t[s].slice();o.splice(this.axis,1);let a=!1;for(let l of n)if(E.arraysEqual(l,o)){a=!0;break}a||n.push(o)}if(n.length>1)throw new ct("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(t))}mergeFunction(t){return _t(()=>uc(t,this.axis))}computeOutputShape(t){if(!(Array.isArray(t)&&Array.isArray(t[0])))throw new ct("A `Concatenate` layer should be called on a list of inputs.");let e=t,n=e[0].slice(),s=this.axis<0?n.length+this.axis:this.axis;for(let o of e.slice(1)){if(n[s]==null||o[s]==null){n[s]=null;break}n[s]+=o[s]}return n}computeMask(t,e){if(e==null)return null;if(!Array.isArray(e))throw new ct("`mask` should be an array for Concatenate");if(!Array.isArray(t))throw new ct("`inputs` should be an array for Concatenate");if(e.length!==t.length)throw new ct(`Mismatch in the length of mask (${e.length}) and the legnth of inputs (${t.length})`);return _t(()=>{let n=!0;if(e.forEach(a=>{if(a!=null){n=!1;return}}),n)return null;let s=[];for(let a=0;a<t.length;++a)e[a]==null?s.push(Gr(t[a]).asType("bool")):e[a].rank<t[a].rank?s.push(nn(e[a],-1)):s.push(e[a]);let o=ar(s,this.axis);return Nh(o,-1,!1)})}getConfig(){let t={axis:this.axis},e=super.getConfig();return Object.assign(t,e),t}};xd.className="Concatenate";At.registerClass(xd);function Qp(r,t){for(;r<0;)r+=t;return r}function yB(r,t,e){if(r.shape.length>3||t.shape.length>3)throw new ue("batchDot is not implemented for tensors of 4D or higher rank yet");if(E.assert(r.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${r.shape.length}`),E.assert(r.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${t.shape.length}`),typeof e=="number"&&(e=[e,e]),r.dtype==="complex64"||t.dtype==="complex64")throw new ue("batchDot is not implemented for complex64-type Tensors yet.");let n=r.shape.length,s=t.shape.length;e==null&&(e=[n-1,s-2]);let o=e;return _t(()=>{let a;if(n>s){a=n-s;let u=[];for(let p=0;p<a;++p)u.push(1);t=t.reshape(t.shape.concat(u))}else if(s>n){a=s-n;let u=[];for(let p=0;p<a;++p)u.push(1);r=r.reshape(r.shape.concat(u))}else a=0;let l;if(r.shape.length===2&&t.shape.length===2)o[0]===o[1]?l=r.mul(t).sum(o[0]):l=r.transpose([1,0]).mul(t).sum(o[1]);else{let u=o[0]!==r.shape.length-1,p=o[1]===t.shape.length-1;l=r.matMul(t,u,p)}if(a>0){let u;n>s?u=n+s-3:u=n-1;let p=[];for(let f=u;f<u+a;++f)p.push(f);l=l.squeeze(p)}return l.shape.length===1&&(l=l.expandDims(1)),l})}var yd=class extends Da{constructor(t){super(t);this.axes=t.axes,this.normalize=t.normalize==null?!1:t.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(t){E.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0],n=t[1];if(e.length>3||n.length>3)throw new ue("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(e,n);if(e[s[0]]!==n[s[1]])throw new ct(`Dimension incompatibility: ${e[s[0]]} !== ${n[s[1]]}`)}mergeFunction(t){if(t.length!==2)throw new ct(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${t.length} input(s).`);let e=t[0],n=t[1],s;return Array.isArray(this.axes)?s=this.axes.map((o,a)=>Qp(o,t[a].shape.length)):s=[Qp(this.axes,e.shape.length),Qp(this.axes,n.shape.length)],this.normalize&&(e=Bp(e,s[0]),n=Bp(n,s[1])),yB(e,n,s)}interpretAxes(t,e){let n;return Array.isArray(this.axes)?n=this.axes:n=[Qp(this.axes,t.length),Qp(this.axes,e.length)],n}computeOutputShape(t){E.assert(Array.isArray(t)&&t.length===2&&Array.isArray(t[0])&&Array.isArray(t[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");let e=t[0].slice(),n=t[1].slice();if(e.length>3||n.length>3)throw new ue("Dot layer does not support tensors of 4D or higher rank yet.");let s=this.interpretAxes(e,n);e.splice(s[0],1),n.splice(s[1],1),n.splice(0,1);let o=e.concat(n);return o.length===1&&o.push(1),o}computeMask(t,e){return null}getConfig(){let t={axes:this.axes,normalize:this.normalize},e=super.getConfig();return Object.assign(t,e),t}};yd.className="Dot";At.registerClass(yd);var _d=class extends _e{constructor(t){super(t);this.supportsMasking=!0,this.stddev=t.stddev}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={stddev:this.stddev};return Object.assign(e,t),e}call(t,e){return _t(()=>{this.invokeCallHook(t,e);let n=xe(t);return Ia(()=>cc(n.shape,0,this.stddev).add(n),()=>n,e.training||!1)})}};_d.className="GaussianNoise";At.registerClass(_d);var bd=class extends _e{constructor(t){super(t);this.supportsMasking=!0,this.rate=t.rate}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return _t(()=>{this.invokeCallHook(t,e);let n=xe(t);return this.rate>0&&this.rate<1?Ia(()=>{let o=Math.sqrt(this.rate/(1-this.rate));return n.mul(cc(n.shape,1,o))},()=>n,e.training||!1):n})}};bd.className="GaussianDropout";At.registerClass(bd);var vd=class extends _e{constructor(t){super(t);this.supportsMasking=!0,this.rate=t.rate,this.noiseShape=t.noiseShape}_getNoiseShape(t){return this.noiseShape||xe(t).shape}computeOutputShape(t){return t}getConfig(){let t=super.getConfig(),e={rate:this.rate};return Object.assign(e,t),e}call(t,e){return _t(()=>{if(this.rate<1&&this.rate>0){let n=this._getNoiseShape(t);return Ia(()=>{let o=xe(t),a=1.6732632423543772,l=1.0507009873554805,u=-a*l,p=Zn(Sa(n),this.rate);p=ui(p,"float32");let f=((1-this.rate)*(1+this.rate*u**2))**-.5,m=-f*u*this.rate;return o.mul(p).add(p.add(-1).mul(u)).mul(f).add(m)},()=>xe(t),e.training||!1)}return t})}};vd.className="AlphaDropout";At.registerClass(vd);function tf(r,t,e,n,s,o=.001){let a;if(r.rank===2)a=qw(r,t,e,n,s,o);else if(r.rank===3)a=Hw(r,t,e,n,s,o);else if(r.rank===4)a=Kw(r,t,e,n,s,o);else throw new ue(`batchNormalization is not implemented for array of rank ${r.rank} yet`);return a}function _B(r,t,e,n,s=.001){return _t(()=>{let o=gp(r,n),a=o.mean,l=o.variance;return[tf(r,a,l,e,t,s),a,l]})}function bB(r,t,e,n,s=.001){return _t(()=>{let o=gp(r,n),a=o.mean,l=o.variance,u=[];for(let _ of an(0,r.rank))n.indexOf(_)!==-1?u.push(1):u.push(r.shape[_]);let p=a.reshape(u),f=l.reshape(u),m=t==null?null:t.reshape(u),d=e==null?null:e.reshape(u);return[tf(r,p,f,d,m,s),a,l]})}function vB(r,t,e,n,s=.001){return E.arraysEqual(n.slice().sort(),an(0,r.rank-1))?_B(r,t,e,n,s):bB(r,t,e,n,s)}var wd=class extends _e{constructor(t){t==null&&(t={}),super(t),this.supportsMasking=!0,this.axis=t.axis==null?-1:t.axis,this.momentum=t.momentum==null?.99:t.momentum,this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Ke(t.betaInitializer||"zeros"),this.gammaInitializer=Ke(t.gammaInitializer||"ones"),this.movingMeanInitializer=Ke(t.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=Ke(t.movingVarianceInitializer||"ones"),this.betaConstraint=dr(t.betaConstraint),this.gammaConstraint=dr(t.gammaConstraint),this.betaRegularizer=Ye(t.betaRegularizer),this.gammaRegularizer=Ye(t.gammaRegularizer)}build(t){t=De(t);let e=this.axis>=0?this.axis:this.axis+t.length,n=t[e];if(n==null)throw new ct(`Axis ${e} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(t)}.`);this.inputSpec=[new cr({ndim:t.length,axes:{[e]:n}})];let s=[n];this.scale&&(this.gamma=this.addWeight("gamma",s,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",s,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",s,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",s,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(t,e){return _t(()=>{let n=e.training==null?!1:e.training,s=xe(t),o=s.shape,a=o.length,l=an(0,a),u=this.axis>=0?this.axis:this.axis+a;l.splice(u,1);let p=ts(1,a);p[u]=o[u];let f=l.slice();f.sort();let m=!E.arraysEqual(f,an(0,a).slice(0,a-1)),d=()=>{if(m){let A=this.movingMean.read().reshape(p),B=this.movingVariance.read().reshape(p),P=this.center?this.beta.read().reshape(p):null,L=this.scale?this.gamma.read().reshape(p):null;return tf(s,A,B,P,L,this.epsilon)}else return tf(s,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!n)return d();let[y,_,v]=vB(s,this.gamma.read(),this.beta.read(),l,this.epsilon),C=(A,B,P)=>{_t(()=>{let L=1-P,Z=A.read(),K=Z.sub(B).mul(L);A.write(Z.sub(K))})};return(()=>{C(this.movingMean,_,this.momentum),C(this.movingVariance,v,this.momentum)})(),y})}getConfig(){let t={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:tr(this.betaInitializer),gammaInitializer:tr(this.gammaInitializer),movingMeanInitializer:tr(this.movingMeanInitializer),movingVarianceInitializer:tr(this.movingVarianceInitializer),betaRegularizer:qe(this.betaRegularizer),gammaRegularizer:qe(this.gammaRegularizer),betaConstraint:mr(this.betaConstraint),gammaConstraint:mr(this.gammaConstraint)},e=super.getConfig();return Object.assign(t,e),t}};wd.className="BatchNormalization";At.registerClass(wd);var Cd=class extends _e{constructor(t){if(t==null&&(t={}),super(t),this.axis=t.axis==null?-1:t.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(let e of this.axis)if(!Number.isInteger(e))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=t.epsilon==null?.001:t.epsilon,this.center=t.center==null?!0:t.center,this.scale=t.scale==null?!0:t.scale,this.betaInitializer=Ke(t.betaInitializer||"zeros"),this.gammaInitializer=Ke(t.gammaInitializer||"ones"),this.betaRegularizer=Ye(t.betaRegularizer),this.gammaRegularizer=Ye(t.gammaRegularizer),this.supportsMasking=!0}build(t){t=De(t);let e=t.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let o=0;o<this.axis.length;++o)this.axis[o]<0&&(this.axis[o]+=e);for(let o of this.axis)if(o<0||o>=e)throw new Error(`Invalid axis: ${o}`);if(this.axis.length!==ns(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);let n=this.axis.map(o=>t[o]),s=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,s):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,s):this.beta=null,this.built=!0}call(t,e){let n=xe(t),s=n.shape,o=s.length;return _t(()=>{let a=!0,{mean:l,variance:u}=gp(n,this.axis,a),p=ts(1,o);for(let v of this.axis)p[v]=s[v];let f=v=>v!=null&&v.shape.length!==o&&this.axis!==[o-1]?v.reshape(p):v,m=f(this.gamma.read()),d=f(this.beta.read()),y=[],_=[];for(let v=0;v<o;++v)this.axis.indexOf(v)!==-1?(y.push(s[v]),_.push(1)):(y.push(1),_.push(s[v]));return l=l.tile(y),u=u.tile(y),m=m.tile(_),d=d.tile(_),tf(n,l,u,d,m,this.epsilon)})}getConfig(){let t={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:tr(this.betaInitializer),gammaInitializer:tr(this.gammaInitializer),betaRegularizer:qe(this.betaRegularizer),gammaRegularizer:qe(this.gammaRegularizer)},e=super.getConfig();return Object.assign(t,e),t}};Cd.className="LayerNormalization";At.registerClass(Cd);function wB(r,t,e){return _t(()=>{if(r.rank!==4)throw new ct(`temporalPadding expects input tensor to be 4-D, but received a ${r.rank}-D tensor.`);if(t==null&&(t=[[1,1],[1,1]]),t.length!==2||t[0].length!==2||t[1].length!==2)throw new ct("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(e==null&&(e=mn()),e!=="channelsLast"&&e!=="channelsFirst")throw new ct(`Unknown data format: ${e}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let n;return e==="channelsFirst"?n=[[0,0],[0,0],t[0],t[1]]:n=[[0,0],t[0],t[1],[0,0]],Ju(r,n)})}var kd=class extends _e{constructor(t){if(t==null&&(t={}),super(t),this.dataFormat=t.dataFormat==null?mn():t.dataFormat,t.padding==null)this.padding=[[1,1],[1,1]];else if(typeof t.padding=="number")this.padding=[[t.padding,t.padding],[t.padding,t.padding]];else{if(t.padding=t.padding,t.padding.length!==2)throw new ct(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${t.padding.length} array.`);let e,n;if(typeof t.padding[0]=="number")e=[t.padding[0],t.padding[0]],n=[t.padding[1],t.padding[1]];else{if(t.padding=t.padding,t.padding[0].length!==2)throw new ct(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${t.padding[0].length} array.`);if(e=t.padding[0],t.padding[1].length!==2)throw new ct(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${t.padding[1].length} array.`);n=t.padding[1]}this.padding=[e,n]}this.inputSpec=[new cr({ndim:4})]}computeOutputShape(t){t=De(t);let e,n;return this.dataFormat==="channelsFirst"?(t[2]!=null&&t[2]>=0?e=t[2]+this.padding[0][0]+this.padding[0][1]:e=null,t[3]!=null&&t[3]>=0?n=t[3]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],t[1],e,n]):(t[1]!=null&&t[1]>=0?e=t[1]+this.padding[0][0]+this.padding[0][1]:e=null,t[2]!=null&&t[2]>=0?n=t[2]+this.padding[1][0]+this.padding[1][1]:n=null,[t[0],e,n,t[3]])}call(t,e){return _t(()=>wB(xe(t),this.padding,this.dataFormat))}getConfig(){let t={padding:this.padding,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}};kd.className="ZeroPadding2D";At.registerClass(kd);function Sd(r,t,e,n,s,o){return _t(()=>{fr(s),Jx(o),dn(n),e==null&&(e=[1,1]),n==null&&(n="valid"),s==null&&(s=mn()),o==null&&(o="max"),r=Hp(r,s);let a,l=n==="same"?"same":"valid";return o==="max"?a=Yu(r,t,e,l):a=Wu(r,t,e,l),s==="channelsFirst"&&(a=Le(a,[0,3,1,2])),a})}function JS(r,t,e,n,s,o){return _t(()=>{fr(s),Jx(o),dn(n),e==null&&(e=[1,1,1]),n==null&&(n="valid"),s==null&&(s=mn()),o==null&&(o="max"),r=$y(r,s);let a,l=n==="same"?"same":"valid";return o==="max"?a=xC(r,t,e,l):a=Uw(r,t,e,l),s==="channelsFirst"&&(a=Le(a,[0,4,1,2,3])),a})}var Py=class extends _e{constructor(t){if(t.poolSize==null&&(t.poolSize=2),super(t),typeof t.poolSize=="number")this.poolSize=[t.poolSize];else if(Array.isArray(t.poolSize)&&t.poolSize.length===1&&typeof t.poolSize[0]=="number")this.poolSize=t.poolSize;else throw new ct(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.poolSize)}`);if(_r(this.poolSize,"poolSize"),t.strides==null)this.strides=this.poolSize;else if(typeof t.strides=="number")this.strides=[t.strides];else if(Array.isArray(t.strides)&&t.strides.length===1&&typeof t.strides[0]=="number")this.strides=t.strides;else throw new ct(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(t.strides)}`);_r(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,dn(this.padding),this.inputSpec=[new cr({ndim:3})]}computeOutputShape(t){t=De(t);let e=Sn(t[1],this.poolSize[0],this.padding,this.strides[0]);return[t[0],e,t[2]]}call(t,e){return _t(()=>{this.invokeCallHook(t,e),t=ci(xe(t),2);let n=this.poolingFunction(xe(t),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return rc(n,[2])})}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides},e=super.getConfig();return Object.assign(t,e),t}},Id=class extends Py{constructor(t){super(t)}poolingFunction(t,e,n,s,o){return fr(o),dn(s),Sd(t,e,n,s,o,"max")}};Id.className="MaxPooling1D";At.registerClass(Id);var Nd=class extends Py{constructor(t){super(t)}poolingFunction(t,e,n,s,o){return fr(o),dn(s),Sd(t,e,n,s,o,"avg")}};Nd.className="AveragePooling1D";At.registerClass(Nd);var Ly=class extends _e{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==2)throw new ct(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides];_r(this.poolSize,"poolSize"),_r(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,fr(this.dataFormat),dn(this.padding),this.inputSpec=[new cr({ndim:4})]}computeOutputShape(t){t=De(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2];return e=Sn(e,this.poolSize[0],this.padding,this.strides[0]),n=Sn(n,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n]:[t[0],e,n,t[3]]}call(t,e){return _t(()=>(this.invokeCallHook(t,e),this.poolingFunction(xe(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Td=class extends Ly{constructor(t){super(t)}poolingFunction(t,e,n,s,o){return fr(o),dn(s),Sd(t,e,n,s,o,"max")}};Td.className="MaxPooling2D";At.registerClass(Td);var Ed=class extends Ly{constructor(t){super(t)}poolingFunction(t,e,n,s,o){return fr(o),dn(s),Sd(t,e,n,s,o,"avg")}};Ed.className="AveragePooling2D";At.registerClass(Ed);var zy=class extends _e{constructor(t){if(t.poolSize==null&&(t.poolSize=[2,2,2]),super(t),this.poolSize=Array.isArray(t.poolSize)?t.poolSize:[t.poolSize,t.poolSize,t.poolSize],t.strides==null)this.strides=this.poolSize;else if(Array.isArray(t.strides)){if(t.strides.length!==3)throw new ct(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${t.strides.length}.`);this.strides=t.strides}else this.strides=[t.strides,t.strides,t.strides];_r(this.poolSize,"poolSize"),_r(this.strides,"strides"),this.padding=t.padding==null?"valid":t.padding,this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,fr(this.dataFormat),dn(this.padding),this.inputSpec=[new cr({ndim:5})]}computeOutputShape(t){t=De(t);let e=this.dataFormat==="channelsFirst"?t[2]:t[1],n=this.dataFormat==="channelsFirst"?t[3]:t[2],s=this.dataFormat==="channelsFirst"?t[4]:t[3];return e=Sn(e,this.poolSize[0],this.padding,this.strides[0]),n=Sn(n,this.poolSize[1],this.padding,this.strides[1]),s=Sn(s,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[t[0],t[1],e,n,s]:[t[0],e,n,s,t[4]]}call(t,e){return _t(()=>(this.invokeCallHook(t,e),this.poolingFunction(xe(t),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){let t={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Ad=class extends zy{constructor(t){super(t)}poolingFunction(t,e,n,s,o){return fr(o),dn(s),JS(t,e,n,s,o,"max")}};Ad.className="MaxPooling3D";At.registerClass(Ad);var $d=class extends zy{constructor(t){super(t)}poolingFunction(t,e,n,s,o){return fr(o),dn(s),JS(t,e,n,s,o,"avg")}};$d.className="AveragePooling3D";At.registerClass($d);var My=class extends _e{constructor(t){super(t);this.inputSpec=[new cr({ndim:3})]}computeOutputShape(t){return[t[0],t[2]]}call(t,e){throw new ue}},Dd=class extends My{constructor(t){super(t||{})}call(t,e){return _t(()=>{let n=xe(t);return hr(n,1)})}};Dd.className="GlobalAveragePooling1D";At.registerClass(Dd);var Rd=class extends My{constructor(t){super(t||{})}call(t,e){return _t(()=>{let n=xe(t);return Xr(n,1)})}};Rd.className="GlobalMaxPooling1D";At.registerClass(Rd);var By=class extends _e{constructor(t){super(t);this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,fr(this.dataFormat),this.inputSpec=[new cr({ndim:4})]}computeOutputShape(t){return t=t,this.dataFormat==="channelsLast"?[t[0],t[3]]:[t[0],t[1]]}call(t,e){throw new ue}getConfig(){let t={dataFormat:this.dataFormat},e=super.getConfig();return Object.assign(t,e),t}},Fd=class extends By{call(t,e){return _t(()=>{let n=xe(t);return this.dataFormat==="channelsLast"?hr(n,[1,2]):hr(n,[2,3])})}};Fd.className="GlobalAveragePooling2D";At.registerClass(Fd);var Od=class extends By{call(t,e){return _t(()=>{let n=xe(t);return this.dataFormat==="channelsLast"?Xr(n,[1,2]):Xr(n,[2,3])})}};Od.className="GlobalMaxPooling2D";At.registerClass(Od);var Vy=class extends _e{constructor(t){super(t);this.layer=t.layer}build(t){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(t){this.layer!=null&&(this.layer.trainable=t)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(t){this.layer.setWeights(t)}getConfig(){let t={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},e=super.getConfig();return Object.assign(t,e),t}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(t)}static fromConfig(t,e,n={}){let s=e.layer,o=Cn(s,n);delete e.layer;let a={layer:o};return Object.assign(a,e),new t(a)}},Pd=class extends Vy{constructor(t){super(t);this.supportsMasking=!0}build(t){if(t=De(t),t.length<3)throw new ct(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(t)}`);this.inputSpec=[{shape:t}];let e=[t[0]].concat(t.slice(2));this.layer.built||(this.layer.build(e),this.layer.built=!0),super.build(t)}computeOutputShape(t){t=De(t);let e=[t[0]].concat(t.slice(2)),n=this.layer.computeOutputShape(e),s=t[1];return[n[0],s].concat(n.slice(1))}call(t,e){return _t(()=>(t=xe(t),Fy((a,l)=>[xe(this.layer.call(a,e)),[]],t,[],!1,null,null,!1,!0)[1]))}};Pd.className="TimeDistributed";At.registerClass(Pd);function CB(r){to(pS,"BidirectionalMergeMode",r)}var kB="concat",Ld=class extends Vy{constructor(t){super(t);let e=t.layer.getConfig(),n={};n.className=t.layer.getClassName(),n.config=e,this.forwardLayer=Cn(n),e.goBackwards=e.goBackwards!==!0;let s={};if(s.className=t.layer.getClassName(),s.config=e,this.backwardLayer=Cn(s),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=t.mergeMode===void 0?kB:t.mergeMode,CB(this.mergeMode),t.weights)throw new ue("weights support is not implemented for Bidirectional layer yet.");this._stateful=t.layer.stateful,this.returnSequences=t.layer.returnSequences,this.returnState=t.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=t.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(t){this._trainable=t,this.forwardLayer!=null&&(this.forwardLayer.trainable=t),this.backwardLayer!=null&&(this.backwardLayer.trainable=t)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(t){let e=t.length,n=Math.floor(e/2);this.forwardLayer.setWeights(t.slice(0,n)),this.backwardLayer.setWeights(t.slice(n))}computeOutputShape(t){let e=this.forwardLayer.computeOutputShape(t);Array.isArray(e)&&Array.isArray(e[0])||(e=[e]),e=e;let n,s,o;return this.returnState&&(o=e.slice(1)),n=e[0],n=n,this.mergeMode==="concat"?(n[n.length-1]*=2,s=[n]):this.mergeMode==null?s=[n,n.slice()]:s=[n],this.returnState?this.mergeMode==null?s.concat(o).concat(o.slice()):[n].concat(o).concat(o.slice()):Or(s)}apply(t,e){let n=e==null?null:e.initialState,s=e==null?null:e.constants;e==null&&(e={});let o=Ry(t,n,s,this.numConstants);if(t=o.inputs,n=o.initialState,s=o.constants,Array.isArray(t)&&(n=t.slice(1),t=t[0]),(n==null||n.length===0)&&s==null)return super.apply(t,e);let a=[],l=[];if(n!=null){let p=n.length;if(p%2>0)throw new ct("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");e.initialState=n,a.push(...n);let f=n.map(m=>new cr({shape:m.shape}));this.forwardLayer.stateSpec=f.slice(0,p/2),this.backwardLayer.stateSpec=f.slice(p/2),l.push(...f)}if(s!=null)throw new ue("Support for constants in Bidirectional layers is not implemented yet.");let u=a[0]instanceof xn;for(let p of a)if(p instanceof xn!==u)throw new ct("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(u){let p=[t].concat(a),f=this.inputSpec.concat(l),m=this.inputSpec;this.inputSpec=f;let d=super.apply(p,e);return this.inputSpec=m,d}else return super.apply(t,e)}call(t,e){return _t(()=>{let n=e.initialState,s,o;if(n==null)s=this.forwardLayer.call(t,e),o=this.backwardLayer.call(t,e);else{let u=n.slice(0,n.length/2),p=n.slice(n.length/2);s=this.forwardLayer.call(t,Object.assign(e,{initialState:u})),o=this.backwardLayer.call(t,Object.assign(e,{initialState:p}))}let a;this.returnState&&(Array.isArray(s)&&(a=s.slice(1).concat(o.slice(1))),s=s[0],o=o[0]),this.returnSequences&&(o=Qn(o,1));let l;return this.mergeMode==="concat"?l=uc([s,o]):this.mergeMode==="sum"?l=Ot(s,o):this.mergeMode==="ave"?l=ft(.5,Ot(s,o)):this.mergeMode==="mul"?l=ft(s,o):this.mergeMode==null&&(l=[s,o]),this.returnState?this.mergeMode==null?l.concat(a):[l].concat(a):l})}resetStates(t){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(t){Ns(this.forwardLayer.name,()=>{this.forwardLayer.build(t)}),Ns(this.backwardLayer.name,()=>{this.backwardLayer.build(t)}),this.built=!0}computeMask(t,e){Array.isArray(e)&&(e=e[0]);let n;if(this.returnSequences?this.mergeMode==null?n=[e,e]:n=e:this.mergeMode==null?n=[null,null]:n=null,this.returnState){let o=this.forwardLayer.states.map(a=>null);return Array.isArray(n)?n.concat(o).concat(o):[n].concat(o).concat(o)}else return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(t){super.setFastWeightInitDuringBuild(t),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(t),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(t)}getConfig(){let t={mergeMode:this.mergeMode},e=super.getConfig();return Object.assign(t,e),t}static fromConfig(t,e){let n=Cn(e.layer);if(delete e.layer,e.numConstants!=null)throw new ue("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");let s=e;return s.layer=n,new t(s)}};Ld.className="Bidirectional";At.registerClass(Ld);var Gy;(function(r){r[r.DT_INVALID=0]="DT_INVALID",r[r.DT_FLOAT=1]="DT_FLOAT",r[r.DT_DOUBLE=2]="DT_DOUBLE",r[r.DT_INT32=3]="DT_INT32",r[r.DT_UINT8=4]="DT_UINT8",r[r.DT_INT16=5]="DT_INT16",r[r.DT_INT8=6]="DT_INT8",r[r.DT_STRING=7]="DT_STRING",r[r.DT_COMPLEX64=8]="DT_COMPLEX64",r[r.DT_INT64=9]="DT_INT64",r[r.DT_BOOL=10]="DT_BOOL",r[r.DT_QINT8=11]="DT_QINT8",r[r.DT_QUINT8=12]="DT_QUINT8",r[r.DT_QINT32=13]="DT_QINT32",r[r.DT_BFLOAT16=14]="DT_BFLOAT16",r[r.DT_FLOAT_REF=101]="DT_FLOAT_REF",r[r.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",r[r.DT_INT32_REF=103]="DT_INT32_REF",r[r.DT_UINT8_REF=104]="DT_UINT8_REF",r[r.DT_INT16_REF=105]="DT_INT16_REF",r[r.DT_INT8_REF=106]="DT_INT8_REF",r[r.DT_STRING_REF=107]="DT_STRING_REF",r[r.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",r[r.DT_INT64_REF=109]="DT_INT64_REF",r[r.DT_BOOL_REF=110]="DT_BOOL_REF",r[r.DT_QINT8_REF=111]="DT_QINT8_REF",r[r.DT_QUINT8_REF=112]="DT_QUINT8_REF",r[r.DT_QINT32_REF=113]="DT_QINT32_REF",r[r.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"})(Gy||(Gy={}));var QS;(function(r){let t;(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t=r.CheckpointFormatVersion||(r.CheckpointFormatVersion={}))})(QS||(QS={}));var bI=Wc(xp());var iI=Wc(xp());function eI(r,t){return tI(r,t)}function tI(r,t,e=new Map,n=new Set){if(r==null)return null;if(n.has(r))throw new Error("Circular references are not supported.");if(e.has(r))return e.get(r);let s=t(r);if(s.recurse&&s.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(s.recurse)if(Cc(r)){let o=Array.isArray(r)?[]:{};n.add(r);for(let a in r){let l=r[a],u=tI(l,t,e,n);o[a]=u}return n.delete(r),o}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return e.set(r,s.value),s.value}function nI(r,t=Wy){return rI(r,t)}function rI(r,t,e=new Set){let n=r[0];if(e.has(n))throw new Error("Circular references are not supported.");let s=t(r);if(s.recurse&&s.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(s.recurse)if(Cc(n)){let o=Array.isArray(n)?[]:{};e.add(n);for(let a in n){let l=r.map(p=>p[a]),u=rI(l,t,e);o[a]=u}return e.delete(n),o}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return s.value}function Wy(r){return r===null?null:Cc(r[0])?{value:null,recurse:!0}:{value:r,recurse:!1}}function Cc(r){return r!=null&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||typeof r=="object"&&!(r instanceof Ae))}function sI(r){return r==null||QB(r)||Array.isArray(r)||typeof r=="object"&&r instanceof Ae||E.isTypedArray(r)}function QB(r){return r===null||typeof r!="object"&&typeof r!="function"}function oI(r){return eI(r,t4)}function t4(r){return r instanceof Ae?{value:r.clone(),recurse:!1}:Cc(r)?{value:null,recurse:!0}:{value:r,recurse:!1}}var ef=class{constructor(t){if(this.capacity=t,this.begin=0,this.end=0,t==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(t<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(t),this.doubledCapacity=2*t}wrap(t){for(;t<0;)t+=this.doubledCapacity;return t%this.doubledCapacity}get(t){if(t<0)throw new RangeError("Can't get item at a negative index.");return this.data[t%this.capacity]}set(t,e){if(t<0)throw new RangeError("Can't set item at a negative index.");this.data[t%this.capacity]=e}length(){let t=this.end-this.begin;return t<0&&(t=this.doubledCapacity+t),t}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,t),this.end=this.wrap(this.end+1)}pushAll(t){for(let e of t)this.push(e)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);let t=this.get(this.end);return this.set(this.end,void 0),t}unshift(t){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,t)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let t=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),t}shuffleExcise(t){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");let e=this.wrap(this.begin+t),n=this.get(e);return this.set(e,this.pop()),n}};var kc=class extends ef{constructor(){super(kc.INITIAL_CAPACITY)}isFull(){return!1}push(t){super.isFull()&&this.expand(),super.push(t)}unshift(t){super.isFull()&&this.expand(),super.unshift(t)}expand(){let t=this.capacity*2,e=new Array(t),n=this.length();for(let s=0;s<n;s++)e[s]=this.get(this.wrap(this.begin+s));this.data=e,this.capacity=t,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}};kc.INITIAL_CAPACITY=32;function lI(r){return new aI(r)}function Uy(r){return new uI(r)}function cI(r,t){return new jy(r,t)}var Jr=class{async toArray(){let t=[],e=await this.next();for(;!e.done;)t.push(e.value),e=await this.next();return t}async toArrayForTest(){let t=this.prefetch(100),e=[],n=await t.next();for(;!n.done;)e.push(n.value),n=await t.next();return e}async resolveFully(){let t=await this.next();for(;!t.done;)t=await this.next()}async resolveWhile(t){let e=await this.next(),n=t(e.value);for(;!e.done&&n;)e=await this.next(),n=t(e.value)}handleErrors(t){return new xI(this,t)}filter(t){return new dI(this,t)}map(t){return new gI(this,t)}mapAsync(t){return new qy(this,t)}serialMapAsync(t){return new qy(this,t).serial()}flatmap(t){return new yI(this,t)}async forEachAsync(t){return this.map(t).resolveFully()}async serialForEach(t){return this.serialMapAsync(t).resolveWhile(e=>e===!0)}rowMajorBatch(t,e=!0){return new mI(this,t,e)}columnMajorBatch(t,e=!0,n=Wy){return this.rowMajorBatch(t,e).map(o=>nI(o,n))}concatenate(t,e){return new jy(lI([this,t]),e)}take(t){return t<0||t==null?this:new hI(this,t)}skip(t){return t<0||t==null?this:new fI(this,t)}prefetch(t){return new Hy(this,t)}shuffle(t,e){return new _I(this,t,e)}serial(){return new pI(this)}},aI=class extends Jr{constructor(t){super();this.items=t,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};let t=this.items[this.trav];return this.trav++,{value:oI(t),done:!1}}},uI=class extends Jr{constructor(t){super();this.nextFn=t}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(t){throw t.message=`Error thrown while iterating through a dataset: ${t.message}`,t}}},pI=class extends Jr{constructor(t){super();this.upstream=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}},fI=class extends Jr{constructor(t,e){super();this.upstream=t,this.maxCount=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){let t=await this.upstream.next();if(t.done)return t;pe(t.value)}return this.upstream.next()}},hI=class extends Jr{constructor(t,e){super();this.upstream=t,this.maxCount=e,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}},mI=class extends Jr{constructor(t,e,n=!0){super();this.upstream=t,this.batchSize=e,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){let t=[];for(;t.length<this.batchSize;){let e=await this.upstream.next();if(e.done)return this.enableSmallLastBatch&&t.length>0?{value:t,done:!1}:{value:null,done:!0};t.push(e.value)}return{value:t,done:!1}}},dI=class extends Jr{constructor(t,e){super();this.upstream=t,this.predicate=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){let t=await this.upstream.next();if(t.done||this.predicate(t.value))return t;pe(t.value)}}},gI=class extends Jr{constructor(t,e){super();this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Map`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=bs.getTensorsInContainer(t.value),n=this.transform(t.value),s=bs.getTensorsInContainer(n);for(let o of e)bs.isTensorInList(o,s)||o.dispose();return{value:n,done:!1}}},xI=class extends Jr{constructor(t,e){super();this.upstream=t,this.handler=e,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(t){if(!this.handler(t))return{value:null,done:!0}}}},qy=class extends Jr{constructor(t,e){super();this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){let t=await this.upstream.next();if(t.done)return{value:null,done:!0};let e=bs.getTensorsInContainer(t.value),n=await this.transform(t.value),s=bs.getTensorsInContainer(n);for(let o of e)bs.isTensorInList(o,s)||o.dispose();return{value:n,done:!1}}},Md=class extends Jr{constructor(){super();this.outputQueue=new kc,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}},yI=class extends Md{constructor(t,e){super();this.upstream=t,this.transform=e}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){let t=await this.upstream.next();if(t.done)return!1;let e=bs.getTensorsInContainer(t.value),n=this.transform(t.value),s=bs.getTensorsInContainer(n);this.outputQueue.pushAll(n);for(let o of e)bs.isTensorInList(o,s)||o.dispose();return!0}},jy=class extends Jr{constructor(t,e){super();this.baseErrorHandler=e,this.lastRead=null,this.iterator=null,this.moreIterators=t}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(t){if(await t,this.iterator==null){let n=await this.moreIterators.next();if(n.done)return{value:null,done:!0};this.iterator=n.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}let e=await this.iterator.next();return e.done?(this.iterator=null,this.readFromChain(t)):e}},Ky;(function(r){r[r.FAIL=0]="FAIL",r[r.SHORTEST=1]="SHORTEST",r[r.LONGEST=2]="LONGEST"})(Ky||(Ky={}));var Hy=class extends Jr{constructor(t,e){super();this.upstream=t,this.bufferSize=e,this.buffer=new ef(e)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){let t=this.upstream.next();this.buffer.push(t)}}next(){return this.refill(),this.buffer.shift()}},_I=class extends Hy{constructor(t,e,n){super(t,e);this.upstream=t,this.windowSize=e,this.upstreamExhausted=!1,this.random=iI.alea(n||E.now().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(t){return Math.floor(this.random()*t)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){let t=this.chooseIndex(),e=await this.buffer.shuffleExcise(t);if(e.done)this.upstreamExhausted=!0;else return this.refill(),e}return{value:null,done:!0}}};var Sc=class{constructor(){this.size=null}batch(t,e=!0){let n=this;E.assert(t>0,()=>`batchSize needs to be positive, but it is
      ${t}`);let s;return this.size===Infinity||this.size==null?s=this.size:e?s=Math.ceil(this.size/t):s=Math.floor(this.size/t),Rs(async()=>(await n.iterator()).columnMajorBatch(t,e,r4),s)}concatenate(t){let e=this,n;return this.size===Infinity||t.size===Infinity?n=Infinity:this.size!=null&&t.size!=null?n=this.size+t.size:n=null,Rs(async()=>(await e.iterator()).concatenate(await t.iterator()),n)}filter(t){let e=this,n;return this.size===Infinity?n=Infinity:n=null,Rs(async()=>(await e.iterator()).filter(s=>_t(()=>t(s))),n)}async forEachAsync(t){return(await this.iterator()).forEachAsync(t)}map(t){let e=this;return Rs(async()=>(await e.iterator()).map(n=>_t(()=>t(n))),this.size)}mapAsync(t){let e=this;return Rs(async()=>(await e.iterator()).mapAsync(t),this.size)}prefetch(t){if(t==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");let e=this;return Rs(async()=>(await e.iterator()).prefetch(t),this.size)}repeat(t){let e=this,n;return this.size!=null&&t>0?n=this.size*t:t===0?n=0:this.size!=null&&(t===void 0||t<0)?n=Infinity:n=null,Rs(async()=>{let s=Uy(async()=>({value:await e.iterator(),done:!1}));return cI(s.take(t))},n)}skip(t){let e=this,n;return this.size!=null&&t>=0&&this.size>=t?n=this.size-t:this.size!=null&&(this.size<t||t===void 0||t<0)?n=0:n=null,Rs(async()=>(await e.iterator()).skip(t),n)}shuffle(t,e,n=!0){if(t==null||t<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);let s=this,o=bI.alea(e||E.now().toString());return Rs(async()=>{let a=o.int32();return n&&(a+=o.int32()),(await s.iterator()).shuffle(t,a.toString())},this.size)}take(t){let e=this,n;return this.size!=null&&this.size>t?n=t:this.size!=null&&this.size<=t?n=this.size:n=null,Rs(async()=>(await e.iterator()).take(t),n)}async toArray(){if(this.size===Infinity)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===Infinity)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Sc.MAX_BUFFER_SIZE=1e4;function Rs(r,t=null){return new class extends Sc{constructor(){super(...arguments);this.size=t}async iterator(){return r()}}}function r4(r){if(r===null)return null;let t=r[0];return sI(t)?{value:n4(r),recurse:!1}:{value:null,recurse:!0}}function n4(r){if(r.length===0)throw new Error("Can't make a batch of zero elements.");return r[0]instanceof Ae?Zr(r):ei(r)}var DBt=Symbol("out"),RBt=Symbol("field"),FBt=Symbol("quote"),OBt=Symbol("quoteafterquote"),PBt=Symbol("quoteinquote");function $t(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&E.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the CPU backend.`)})}var h4=sn.whereImpl,Xy=class extends Ka{constructor(){super();this.blockSize=48,this.firstUse=!0,this.data=new Kc(this,_a())}write(t,e,n){this.firstUse&&(this.firstUse=!1,vt().get("IS_NODE")&&H.warn(`
============================
Hi there \u{1F44B}. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.
============================`));let s={};return this.data.set(s,{values:t,dtype:n,refCount:1}),s}makeTensorInfo(t,e,n){let s;if(e==="string"&&n!=null&&n.length>0&&E.isString(n[0])){let o=n.map(a=>E.encodeString(a));s=this.write(o,t,e)}else s=this.write(n,t,e);return{dataId:s,shape:t,dtype:e}}incRef(t){let e=this.data.get(t);e.refCount++}decRef(t){if(this.data.has(t)){let e=this.data.get(t);e.refCount--}}move(t,e,n,s){this.data.set(t,{values:e,dtype:s,refCount:1})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(t){let{dtype:e,complexTensorInfos:n}=this.data.get(t);if(e==="complex64"){let s=this.readSync(n.real.dataId),o=this.readSync(n.imag.dataId);return H.mergeRealAndImagArrays(s,o)}return this.data.get(t).values}bufferSync(t){let e=this.readSync(t.dataId),n=e;if(t.dtype==="string")try{n=e.map(s=>E.decodeString(s))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return ae(t.shape,t.dtype,n)}makeOutput(t,e,n){let s=this.write(t,e,n);return _a().makeTensorFromDataId(s,e,n,this)}disposeData(t){if(this.data.has(t)){let{complexTensorInfos:e}=this.data.get(t);e!=null&&(this.disposeData(e.real.dataId),this.disposeData(e.imag.dataId)),this.data.delete(t)}}disposeIntermediateTensorInfo(t){let e=t.dataId;if(this.data.has(e)){let n=this.data.get(e);n.refCount--,n.refCount<1&&this.disposeData(e)}}async time(t){let e=E.now();return t(),{kernelMs:E.now()-e}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(t){$t([t],"where");let e=this.readSync(t.dataId);return h4(t.shape,e)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}};var a_={};Yn(a_,{addImpl:()=>NI,bincountImpl:()=>rf,bincountReduceImpl:()=>Yy,ceilImpl:()=>EI,concatImpl:()=>Zy,expImpl:()=>$I,expm1Impl:()=>RI,floorImpl:()=>OI,gatherV2Impl:()=>Qy,greaterImpl:()=>LI,lessImpl:()=>MI,linSpaceImpl:()=>t_,logImpl:()=>VI,maxImpl:()=>e_,maximumImpl:()=>WI,minimumImpl:()=>jI,multiplyImpl:()=>Bd,negImpl:()=>KI,notEqualImpl:()=>YI,prodImpl:()=>QI,rangeImpl:()=>r_,rsqrtImpl:()=>eN,simpleAbsImpl:()=>vI,sliceImpl:()=>nN,squaredDifferenceImpl:()=>oN,stridedSliceImpl:()=>n_,subImpl:()=>aN,tileImpl:()=>s_,topKImpl:()=>o_,transposeImpl:()=>sf,uniqueImpl:()=>i_});function vI(r){let t=new Float32Array(r.length);for(let e=0;e<r.length;++e)t[e]=Math.abs(r[e]);return t}var m4=r=>{let{x:t}=r.inputs,e=r.backend;$t(t,"abs");let n=new Float32Array(E.sizeFromShape(t.shape)),s=e.data.get(t.dataId).values;return n=vI(s),e.makeOutput(n,t.shape,"float32")},wI={kernelName:ki,backendName:"cpu",kernelFunc:m4};function $e(r){return(t,e,n,s,o)=>{let a=H.assertAndGetBroadcastShape(t,e),l=a.length,u=E.computeStrides(a),p=E.sizeFromShape(a),f=E.getTypedArrayFromDType(o,p),m=t.length,d=e.length,y=E.computeStrides(t),_=E.computeStrides(e),v=H.getBroadcastDims(t,a),C=H.getBroadcastDims(e,a);if(v.length+C.length===0)for(let N=0;N<f.length;++N)f[N]=r(n[N%n.length],s[N%s.length]);else for(let N=0;N<f.length;++N){let A=E.indexToLoc(N,l,u),B=A.slice(-m);v.forEach(K=>B[K]=0);let P=E.locToIndex(B,m,y),L=A.slice(-d);C.forEach(K=>L[K]=0);let Z=E.locToIndex(L,d,_);f[N]=r(n[P],s[Z])}return[f,a]}}function $r(r){let{inputs:t,backend:e}=r,{real:n,imag:s}=t,o=e.data.get(n.dataId).values,a=e.data.get(s.dataId).values,l=e.makeTensorInfo(n.shape,"complex64"),u=e.data.get(l.dataId);return u.complexTensorInfos={real:e.makeTensorInfo(n.shape,"float32",o),imag:e.makeTensorInfo(s.shape,"float32",a)},l}var CI={kernelName:uu,backendName:"cpu",kernelFunc:$r};function Ic(r,t,e="float32"){if(e==="complex64"){let s=Ic(r,t,"float32"),o=Ic(r,t,"float32");return $r({inputs:{real:s,imag:o},backend:r})}let n=E.makeZerosTypedArray(E.sizeFromShape(t),e);return r.makeTensorInfo(t,e,n)}function Qr(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var kI={kernelName:Gi,backendName:"cpu",kernelFunc:Qr};function as(r){let{inputs:t,backend:e}=r,{input:n}=t,s=e.data.get(n.dataId).complexTensorInfos.real,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}var SI={kernelName:Iu,backendName:"cpu",kernelFunc:as};function ls(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{dtype:o}=n;if(o==="complex64"){if(s.dtype==="complex64")return Qr({inputs:{x:s},backend:e});let a=Ic(e,s.shape,s.dtype),l=ls({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),u=$r({inputs:{real:l,imag:a},backend:e});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}if(s.dtype==="complex64"){let a=as({inputs:{input:s},backend:e}),l=ls({inputs:{x:a},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(a),l}if(!E.hasEncodingLoss(s.dtype,o)){let a=Qr({inputs:{x:s},backend:e});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32"){let a=e.data.get(s.dataId).values,l=Int32Array.from(a);return e.makeTensorInfo(s.shape,"int32",l)}if(o==="bool"){let a=e.data.get(s.dataId).values,l=E.toTypedArray([0],s.dtype),[u,p]=$e((f,m)=>f!==m?1:0)(s.shape,[],a,l,"bool");return e.makeTensorInfo(p,"bool",u)}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}var II={kernelName:Ws,backendName:"cpu",kernelFunc:ls};function Me(r,t,e,n){return e==null?({inputs:s,backend:o})=>{let{a,b:l}=s,u=o;$t([a,l],r);let p=u.data.get(a.dataId).values,f=u.data.get(l.dataId).values,m=n||a.dtype,[d,y]=t(a.shape,l.shape,p,f,m);return u.makeTensorInfo(y,m,d)}:({inputs:s,backend:o})=>{let{a,b:l}=s,u=o;if(a.dtype==="complex64"||l.dtype==="complex64"){let p=ls({inputs:{x:a},backend:u,attrs:{dtype:"complex64"}}),f=u.data.get(p.dataId),m=f.complexTensorInfos.real,d=f.complexTensorInfos.imag,y=u.data.get(m.dataId).values,_=u.data.get(d.dataId).values,v=ls({inputs:{x:l},backend:u,attrs:{dtype:"complex64"}}),C=u.data.get(v.dataId),N=C.complexTensorInfos.real,A=C.complexTensorInfos.imag,B=u.data.get(N.dataId).values,P=u.data.get(A.dataId).values,[L,Z,K]=e(a.shape,l.shape,y,_,B,P),et=u.makeTensorInfo(K,"float32",L),it=u.makeTensorInfo(K,"float32",Z),xt=$r({inputs:{real:et,imag:it},backend:u});return u.disposeIntermediateTensorInfo(p),u.disposeIntermediateTensorInfo(v),u.disposeIntermediateTensorInfo(et),u.disposeIntermediateTensorInfo(it),xt}else{let p=u.data.get(a.dataId).values,f=u.data.get(l.dataId).values,m=n||a.dtype,[d,y]=t(a.shape,l.shape,p,f,m);return u.makeTensorInfo(y,m,d)}}}function Nc(r){return(t,e,n,s,o,a)=>{let l=H.assertAndGetBroadcastShape(t,e),u=E.sizeFromShape(l),p=l.length,f=E.computeStrides(l),m=E.getTypedArrayFromDType("float32",u),d=E.getTypedArrayFromDType("float32",u),y=H.getBroadcastDims(t,l),_=H.getBroadcastDims(e,l),v=H.mergeRealAndImagArrays(n,s),C=H.mergeRealAndImagArrays(o,a),N=t.length,A=E.computeStrides(t),B=e.length,P=E.computeStrides(e);if(y.length+_.length===0)for(let L=0;L<m.length;L++){let Z=L%v.length,K=L%C.length,et=r(v[Z*2],v[Z*2+1],C[K*2],C[K*2+1]);m[L]=et.real,d[L]=et.imag}else for(let L=0;L<m.length;L++){let Z=E.indexToLoc(L,p,f),K=Z.slice(-N);y.forEach(St=>K[St]=0);let et=E.locToIndex(K,N,A),it=Z.slice(-B);_.forEach(St=>it[St]=0);let xt=E.locToIndex(it,B,P),wt=r(v[et*2],v[et*2+1],C[xt*2],C[xt*2+1]);m[L]=wt.real,d[L]=wt.imag}return[m,d,l]}}var NI=$e((r,t)=>r+t),d4=Nc((r,t,e,n)=>({real:r+e,imag:t+n})),di=Me(_s,NI,d4),TI={kernelName:_s,backendName:"cpu",kernelFunc:di};function rf(r,t,e,n,s){let o=E.sizeFromShape(n),a=E.makeZerosTypedArray(s,e);for(let l=0;l<r.length;l++){let u=r[l];if(u<0)throw new Error("Input x must be non-negative!");u>=s||(o>0?a[u]+=t[l]:a[u]+=1)}return a}function Yy(r,t,e,n=!1){let s=r.shape[0],o=r.shape[1],a=ae([s,e],t.dtype);for(let l=0;l<s;l++)for(let u=0;u<o;u++){let p=r.get(l,u);if(p<0)throw new Error("Input x must be non-negative!");p>=e||(n?a.set(1,l,p):t.size>0?a.set(a.get(l,p)+t.get(l,u),l,p):a.set(a.get(l,p)+1,l,p))}return a}function us(r){return(t,e,n)=>{let s=E.getTypedArrayFromDType(e,t.length);for(let o=0;o<t.length;++o)s[o]=r(t[o],n);return s}}function he(r,t,e){return({inputs:n,attrs:s,backend:o})=>{let{x:a}=n;if($t(a,r),a.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let l=o,u=l.data.get(a.dataId).values,p=E.sizeFromShape(a.shape),f=e||a.dtype,m=E.getArrayFromDType(f,p);for(let d=0;d<p;++d)m[d]=t(u[d],s);return l.makeTensorInfo(a.shape,f,m)}}function cs(r,t,e){return({inputs:n,attrs:s,backend:o})=>{let{x:a}=n;if($t(a,r),a.dtype==="string"||e==="string")throw new Error("unaryKernelFunc does not support string input/output");let l=o,u=l.data.get(a.dataId).values,p=e||a.dtype,f=t(u,p,s);return l.makeTensorInfo(a.shape,p,f)}}var EI=us(r=>Math.ceil(r)),g4=cs(mo,EI),AI={kernelName:mo,backendName:"cpu",kernelFunc:g4};function Zy(r,t,e,n){let s=E.getArrayFromDType(e,E.sizeFromShape(t));if(n&&e!=="string"){let o=0;r.forEach(a=>{let l=E.sizeFromShape(a.shape);s.set(a.vals,o),o+=l})}else{let o=0;r.forEach(a=>{let l=e==="string"?H.fromUint8ToStringArray(a.vals):a.vals,u=0;for(let p=0;p<a.shape[0];++p){let f=p*t[1]+o;for(let m=0;m<a.shape[1];++m)s[f+m]=l[u++]}o+=a.shape[1]})}return s}var $I=us(r=>Math.exp(r)),Jy=cs(wo,$I),DI={kernelName:wo,backendName:"cpu",kernelFunc:Jy};var RI=us(r=>Math.expm1(r)),x4=cs(Co,RI),FI={kernelName:Co,backendName:"cpu",kernelFunc:x4};var OI=us(r=>Math.floor(r)),y4=cs(ko,OI),PI={kernelName:ko,backendName:"cpu",kernelFunc:y4};function Qy(r,t,e){let n=ae(e,r.dtype);for(let s=0;s<n.size;++s){let a=n.indexToLoc(s).slice(),l=a[0],u=a[2],p=t.locToIndex([l,u]);a[2]=t.values[p];let f=r.locToIndex(a);n.values[s]=r.values[f]}return n}var LI=$e((r,t)=>r>t?1:0),_4=Me(Qa,LI,null,"bool"),zI={kernelName:Qa,backendName:"cpu",kernelFunc:_4};var MI=$e((r,t)=>r<t?1:0),b4=Me(tl,MI,null,"bool"),BI={kernelName:tl,backendName:"cpu",kernelFunc:b4};function t_(r,t,e){let n=(t-r)/(e-1),s=E.makeZerosTypedArray(e,"float32");s[0]=r;for(let o=1;o<s.length;o++)s[o]=s[o-1]+n;return s}var VI=us(r=>Math.log(r)),v4=cs(Ao,VI),GI={kernelName:Ao,backendName:"cpu",kernelFunc:v4};function e_(r,t,e,n){let s=E.getTypedArrayFromDType(n,E.sizeFromShape(e));for(let o=0;o<s.length;++o){let a=o*t,l=r[a];for(let u=0;u<t;++u){let p=r[a+u];p>l&&(l=p)}s[o]=l}return s}var WI=$e((r,t)=>Math.max(r,t)),w4=Me(Do,WI),UI={kernelName:Do,backendName:"cpu",kernelFunc:w4};var jI=$e((r,t)=>Math.min(r,t)),C4=Me(Ro,jI),qI={kernelName:Ro,backendName:"cpu",kernelFunc:C4};var Bd=$e((r,t)=>r*t),k4=Nc((r,t,e,n)=>({real:r*e-t*n,imag:r*n+t*e})),nf=Me(Oo,Bd,k4),HI={kernelName:Oo,backendName:"cpu",kernelFunc:nf};function KI(r,t,e){let n=E.createScalarValue(-1,e);return Bd([],t,n,r,e)}function S4(r){let{inputs:t,backend:e}=r,{x:n}=t;$t(n,"neg");let s=e.data.get(n.dataId).values,[o,a]=KI(s,n.shape,n.dtype);return e.makeTensorInfo(a,n.dtype,o)}var XI={kernelName:Zi,backendName:"cpu",kernelFunc:S4};var YI=$e((r,t)=>r!==t?1:0),I4=Me(ol,YI,null,"bool"),ZI={kernelName:ol,backendName:"cpu",kernelFunc:I4};function sf(r,t,e,n,s){let o=t.length,a=E.sizeFromShape(t),l=E.computeStrides(t),u=E.computeStrides(s),p=E.getTypedArrayFromDType(e,E.sizeFromShape(s));for(let f=0;f<a;++f){let m=E.indexToLoc(f,o,l),d=new Array(m.length);for(let _=0;_<d.length;_++)d[_]=m[n[_]];let y=E.locToIndex(d,o,u);p[y]=r[f]}return p}function Nr(r){let{inputs:t,attrs:e,backend:n}=r,{x:s}=t,{perm:o}=e;$t(s,"transpose");let a=s.shape.length,l=new Array(a);for(let m=0;m<l.length;m++)l[m]=s.shape[o[m]];let u=n.data.get(s.dataId).values,p=sf(u,s.shape,s.dtype,o,l);return{dataId:n.write(p,l,s.dtype),shape:l,dtype:s.dtype}}var JI={kernelName:ha,backendName:"cpu",kernelFunc:Nr};function QI(r,t,e,n){let[s,o]=H.computeOutAndReduceShapes(r,n),a=Br(t,"int32"),l=E.makeZerosTypedArray(E.sizeFromShape(s),a),u=E.sizeFromShape(o);for(let p=0;p<l.length;++p){let f=p*u,m=1;for(let d=0;d<u;++d)m*=e[f+d];l[p]=m}return{outVals:l,outShape:s,outDtype:a}}function N4(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n;$t(s,"prod");let l=s.shape.length,u=E.parseAxisParam(o,s.shape),p=H.getAxesPermutation(u,l),f=u,m=s,d=[];p!=null&&(m=Nr({inputs:{x:s},backend:e,attrs:{perm:p}}),d.push(m),f=H.getInnerMostAxes(f.length,l));let y=e.data.get(m.dataId).values,{outVals:_,outShape:v,outDtype:C}=QI(m.shape,m.dtype,y,f),N=v;return a&&(N=H.expandShapeToKeepDim(v,u)),d.forEach(A=>e.disposeIntermediateTensorInfo(A)),e.makeTensorInfo(N,C,_)}var tN={kernelName:ku,backendName:"cpu",kernelFunc:N4};function r_(r,t,e,n){let s=r===t,o=r<t&&e<0,a=t<r&&e>1;if(s||o||a)return E.makeZerosTypedArray(0,n);let l=Math.abs(Math.ceil((t-r)/e)),u=E.makeZerosTypedArray(l,n);t<r&&e===1&&(e=-1),u[0]=r;for(let p=1;p<u.length;p++)u[p]=u[p-1]+e;return u}var eN=us(r=>1/Math.sqrt(r)),T4=cs(Vo,eN),rN={kernelName:Vo,backendName:"cpu",kernelFunc:T4};function nN(r,t,e,n,s){let o=pn.isSliceContinous(n,t,e),a=E.sizeFromShape(e),l=E.computeStrides(n);if(o){let m=pn.computeFlatOffset(t,l);return s==="string"?r.slice(m,m+a):r.subarray(m,m+a)}let u=s==="string"?H.fromUint8ToStringArray(r):r,p=ae(n,s,u),f=ae(e,s);for(let m=0;m<f.size;++m){let d=f.indexToLoc(m),y=d.map((_,v)=>_+t[v]);f.set(p.get(...y),...d)}return s==="string"?H.fromStringArrayToUint8(f.values):f.values}function ps(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{begin:o,size:a}=n;$t(s,"slice");let[l,u]=pn.parseSliceParams(s,o,a);pn.assertParamsValid(s,l,u);let p=e.data.get(s.dataId).values,f=nN(p,l,u,s.shape,s.dtype);return e.makeTensorInfo(u,s.dtype,f)}var sN={kernelName:la,backendName:"cpu",kernelFunc:ps};var oN=$e((r,t)=>{let e=r-t;return e*e}),E4=Me(Xo,oN),iN={kernelName:Xo,backendName:"cpu",kernelFunc:E4};function n_(r,t,e,n){let s=ae(r,t.dtype);for(let o=0;o<s.size;o++){let a=s.indexToLoc(o),l=new Array(a.length);for(let u=0;u<l.length;u++)l[u]=a[u]*e[u]+n[u];s.set(t.get(...l),...a)}return s}var aN=$e((r,t)=>r-t),A4=Nc((r,t,e,n)=>({real:r-e,imag:t-n})),of=Me(Yo,aN,A4),lN={kernelName:Yo,backendName:"cpu",kernelFunc:of};function s_(r,t){let e=new Array(r.rank);for(let s=0;s<e.length;s++)e[s]=r.shape[s]*t[s];let n=ae(e,r.dtype);for(let s=0;s<n.values.length;++s){let o=n.indexToLoc(s),a=new Array(r.rank);for(let u=0;u<a.length;u++)a[u]=o[u]%r.shape[u];let l=r.locToIndex(a);n.values[s]=r.values[l]}return n}function o_(r,t,e,n,s){let o=t[t.length-1],[a,l]=[r.length/o,o],u=E.getTypedArrayFromDType(e,a*n),p=E.getTypedArrayFromDType("int32",a*n);for(let m=0;m<a;m++){let d=m*l,y=r.subarray(d,d+l),_=[];for(let A=0;A<y.length;A++)_.push({value:y[A],index:A});_.sort((A,B)=>B.value-A.value);let v=m*n,C=u.subarray(v,v+n),N=p.subarray(v,v+n);for(let A=0;A<n;A++)C[A]=_[A].value,N[A]=_[A].index}let f=t.slice();return f[f.length-1]=n,[ae(f,e,u),ae(f,"int32",p)]}function i_(r,t,e,n){let s=E.parseAxisParam(t,e)[0],o=[1,e[0],1];for(let _=0;_<s;_++)o[0]*=e[_];o[1]=e[s];for(let _=s+1;_<e.length;_++)o[2]*=e[_];let a={},l=new Int32Array(e[s]),u=new er(o,n,r),p=[],f=o[0]===1&&o[2]===1;for(let _=0;_<e[s];_++){let v;if(f)v=r[_].toString();else{let C=[];for(let N=0;N<o[0];N++)for(let A=0;A<o[2];A++)C.push(u.get(N,_,A));v=C.join(",")}if(a[v]!==void 0)l[_]=a[v];else{let C=Object.keys(a).length;a[v]=C,l[_]=C,p.push(_)}}let m=o.slice();m[1]=Object.keys(a).length;let d=new er(m,n);p.forEach((_,v)=>{for(let C=0;C<o[0];C++)for(let N=0;N<o[2];N++)d.set(u.get(C,_,N),C,v,N)});let y=e.slice();return y[s]=m[1],{outputValues:d.values,outputShape:y,indices:l}}Sh("cpu",()=>new Xy,1);var l_=he(bo,r=>r>=0?r:Math.exp(r)-1),uN={kernelName:bo,backendName:"cpu",kernelFunc:l_};function u_(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{alpha:o}=n;$t([s],"leakyRelu");let a=E.sizeFromShape(s.shape),l=e.data.get(s.dataId).values,u=E.getTypedArrayFromDType("float32",a);for(let p=0;p<l.length;p++)u[p]=l[p]<0?o*l[p]:l[p];return e.makeTensorInfo(s.shape,"float32",u)}var cN={kernelName:Wi,backendName:"cpu",kernelFunc:u_};var $4=$e((r,t)=>r<0?t*r:r);function c_(r){let{inputs:t,backend:e}=r,{x:n,alpha:s}=t;$t([n,s],"prelu");let o=e.data.get(n.dataId).values,a=e.data.get(s.dataId).values,[l,u]=$4(n.shape,s.shape,o,a,n.dtype);return e.makeTensorInfo(u,n.dtype,l)}var pN={kernelName:ra,backendName:"cpu",kernelFunc:c_};var p_=he(zo,r=>Math.max(0,r)),fN={kernelName:zo,backendName:"cpu",kernelFunc:p_};var f_=he(Mo,r=>Math.min(Math.max(0,r),6)),hN={kernelName:Mo,backendName:"cpu",kernelFunc:f_};function Tc(r,t,e,n,s){if(e==="linear")return Qr({inputs:{x:t},backend:r});if(e==="relu")return p_({inputs:{x:t},backend:r});if(e==="elu")return l_({inputs:{x:t},backend:r});if(e==="relu6")return f_({inputs:{x:t},backend:r});if(e==="prelu")return c_({inputs:{x:t,alpha:n},backend:r});if(e==="leakyrelu")return u_({inputs:{x:t},backend:r,attrs:{alpha:s}});throw new Error(`Activation ${e} has not been implemented for the CPU backend.`)}function Oe(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{shape:o}=n,a=E.sizeFromShape(s.shape),l=E.inferFromImplicitShape(o,a),u=E.sizeFromShape(l);E.assert(a===u,()=>`The new shape (${l}) has ${u} elements and the old shape (${s.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),e.incRef(s.dataId);let p=e.data.get(s.dataId);if(p.complexTensorInfos!=null){let f=p.complexTensorInfos.real,m=p.complexTensorInfos.imag;f.shape=l,m.shape=l}return{dataId:s.dataId,shape:l,dtype:s.dtype}}var mN={kernelName:na,backendName:"cpu",kernelFunc:Oe};function h_(r){let{inputs:t,backend:e,attrs:n}=r,{a:s,b:o}=t,{transposeA:a,transposeB:l}=n;$t([s,o],"matMul");let u=s.shape.length,p=o.shape.length,f=a?s.shape[u-2]:s.shape[u-1],m=l?o.shape[p-1]:o.shape[p-2],d=a?s.shape[u-1]:s.shape[u-2],y=l?o.shape[p-2]:o.shape[p-1],_=s.shape.slice(0,-2),v=o.shape.slice(0,-2),C=E.sizeFromShape(_),N=E.sizeFromShape(v),A=C===N||C===1||N===1;E.assert(u>=2&&p>=2&&A,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${_}) and (${v}).`);let P=(C>N?s.shape.slice(0,-2):o.shape.slice(0,-2)).concat([d,y]);E.assert(f===m,()=>`Error in matMul: inner shapes (${f}) and (${m}) of Tensors with shapes ${s.shape} and ${o.shape} and transposeA=${a} and transposeB=${l} must match.`);let L=a?[C,f,d]:[C,d,f],Z=l?[N,y,m]:[N,m,y],K=Oe({inputs:{x:s},backend:e,attrs:{shape:L}}),et=Oe({inputs:{x:o},backend:e,attrs:{shape:Z}}),it=a?K.shape[1]:K.shape[2],xt=a?K.shape[2]:K.shape[1],wt=l?et.shape[1]:et.shape[2],St=Math.max(C,N),yt=e.data.get(K.dataId).values,Nt=e.data.get(et.dataId).values,ht=E.computeStrides(K.shape),It=E.computeStrides(et.shape),[Ft,Ct,Dt]=a?[ht[0],1,ht[1]]:[ht[0],ht[1],1],[zt,Mt,jt]=l?[1,It[1],It[0]]:[It[1],1,It[0]],qt=xt*wt,Bt=ae([St,xt,wt],K.dtype),Ht=Bt.values,Zt=e.blockSize;for(let ne=0;ne<St;ne++)for(let Qt=0;Qt<xt;Qt+=Zt)for(let te=0;te<wt;te+=Zt)for(let oe=0;oe<it;oe+=Zt){let Re=Math.min(Qt+Zt,xt),We=Math.min(te+Zt,wt),xr=Math.min(oe+Zt,it);for(let nr=Qt;nr<Re;nr++)for(let sr=te;sr<We;sr++){let or=0;for(let pr=oe;pr<xr;pr++){let wr=Math.min(ne,C-1)*Ft,Kn=Math.min(ne,N-1)*jt,Pe=yt[wr+nr*Ct+pr*Dt],Tn=Nt[pr*zt+sr*Mt+Kn];or+=Pe*Tn}Ht[ne*qt+(nr*wt+sr)]+=or}}return e.disposeIntermediateTensorInfo(K),e.disposeIntermediateTensorInfo(et),e.makeTensorInfo(P,Bt.dtype,Bt.values)}var dN={kernelName:Ei,backendName:"cpu",kernelFunc:h_};function D4(r){let{inputs:t,backend:e,attrs:n}=r,{a:s,b:o,bias:a,preluActivationWeights:l}=t,{transposeA:u,transposeB:p,activation:f,leakyreluAlpha:m}=n,d,y,_,v=[];d=h_({inputs:{a:s,b:o},attrs:{transposeA:u,transposeB:p},backend:e}),a&&(y=di({inputs:{a:d,b:a},backend:e}),v.push(d),d=y),f&&(_=Tc(e,d,f,l,m),v.push(d),d=_);for(let N of v)e.disposeIntermediateTensorInfo(N);return d}var gN={kernelName:il,backendName:"cpu",kernelFunc:D4};var R4=he(ao,r=>Math.acos(r)),xN={kernelName:ao,backendName:"cpu",kernelFunc:R4};var F4=he(lo,r=>Math.acosh(r)),yN={kernelName:lo,backendName:"cpu",kernelFunc:F4};function O4(r){let{inputs:t,backend:e}=r,n=t;$t(t,"addN");let s=n.map(l=>e.data.get(l.dataId).values),o=ae(n[0].shape,n[0].dtype),a=o.values;for(let l=0;l<n.length;l++){let u=s[l];for(let p=0;p<a.length;p++)a[p]+=u[p]}return e.makeTensorInfo(o.shape,o.dtype,o.values)}var _N={kernelName:su,backendName:"cpu",kernelFunc:O4};function P4(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n;$t(s,"all");let l=E.parseAxisParam(o,s.shape),u=l,p=H.getAxesPermutation(u,s.shape.length),f=s;p!=null&&(f=Nr({inputs:{x:s},backend:e,attrs:{perm:p}}),u=H.getInnerMostAxes(u.length,s.shape.length)),H.assertAxesAreInnerMostDims("all",u,f.shape.length);let[m,d]=H.computeOutAndReduceShapes(f.shape,u),y=E.sizeFromShape(d),_=E.makeZerosTypedArray(E.sizeFromShape(m),f.dtype),v=e.data.get(f.dataId).values;for(let N=0;N<_.length;++N){let A=N*y,B=v[A];for(let P=0;P<y;++P){let L=v[A+P];B=B&&L}_[N]=B}p!=null&&e.disposeIntermediateTensorInfo(f);let C=e.makeTensorInfo(m,f.dtype,_);if(a){let N=H.expandShapeToKeepDim(m,l),A=Oe({inputs:{x:C},backend:e,attrs:{shape:N}});return e.disposeIntermediateTensorInfo(C),A}return C}var bN={kernelName:ou,backendName:"cpu",kernelFunc:P4};function L4(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n;$t(s,"any");let l=E.parseAxisParam(o,s.shape),u=l,p=H.getAxesPermutation(u,s.shape.length),f=s;p!=null&&(f=Nr({inputs:{x:s},backend:e,attrs:{perm:p}}),u=H.getInnerMostAxes(u.length,s.shape.length)),H.assertAxesAreInnerMostDims("any",u,f.shape.length);let[m,d]=H.computeOutAndReduceShapes(f.shape,u),y=E.sizeFromShape(d),_=E.makeZerosTypedArray(E.sizeFromShape(m),f.dtype),v=e.data.get(f.dataId).values;for(let N=0;N<_.length;++N){let A=N*y,B=v[A];for(let P=0;P<y;++P){let L=v[A+P];B=B||L}_[N]=B}p!=null&&e.disposeIntermediateTensorInfo(f);let C=e.makeTensorInfo(m,f.dtype,_);if(a){let N=H.expandShapeToKeepDim(m,l),A=Oe({inputs:{x:C},backend:e,attrs:{shape:N}});return e.disposeIntermediateTensorInfo(C),A}return C}var vN={kernelName:iu,backendName:"cpu",kernelFunc:L4};function z4(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o}=n;$t(s,"argMax");let a=E.parseAxisParam(o,s.shape),l=H.getAxesPermutation(a,s.shape.length),u=s,p=[];l!=null&&(u=Nr({inputs:{x:s},backend:e,attrs:{perm:l}}),p.push(u),a=H.getInnerMostAxes(a.length,u.shape.length)),a=[a[0]],H.assertAxesAreInnerMostDims("argMax",a,u.shape.length);let[f,m]=H.computeOutAndReduceShapes(u.shape,a),d=E.sizeFromShape(f),y=E.makeZerosTypedArray(d,"int32"),_=E.sizeFromShape(m),v=e.data.get(u.dataId).values;for(let C=0;C<y.length;++C){let N=C*_,A=v[N],B=0;for(let P=0;P<_;++P){let L=v[N+P];L>A&&(A=L,B=P)}y[C]=B}return p.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.makeTensorInfo(f,"int32",y)}var wN={kernelName:Si,backendName:"cpu",kernelFunc:z4};function M4(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o}=n;$t(s,"argMin");let a=E.parseAxisParam(o,s.shape),l=H.getAxesPermutation(a,s.shape.length),u=s,p=[];l!=null&&(u=Nr({inputs:{x:s},backend:e,attrs:{perm:l}}),p.push(u),a=H.getInnerMostAxes(a.length,u.shape.length)),a=[a[0]],H.assertAxesAreInnerMostDims("argMin",a,u.shape.length);let[f,m]=H.computeOutAndReduceShapes(u.shape,a),d=E.sizeFromShape(f),y=E.makeZerosTypedArray(d,"int32"),_=E.sizeFromShape(m),v=e.data.get(u.dataId).values;for(let C=0;C<y.length;++C){let N=C*_,A=v[N],B=0;for(let P=0;P<_;++P){let L=v[N+P];L<A&&(A=L,B=P)}y[C]=B}return p.forEach(C=>e.disposeIntermediateTensorInfo(C)),e.makeTensorInfo(f,"int32",y)}var CN={kernelName:Ii,backendName:"cpu",kernelFunc:M4};var B4=he(uo,r=>Math.asin(r)),kN={kernelName:uo,backendName:"cpu",kernelFunc:B4};var V4=he(co,r=>Math.asinh(r)),SN={kernelName:co,backendName:"cpu",kernelFunc:V4};var G4=he(po,r=>Math.atan(r)),IN={kernelName:po,backendName:"cpu",kernelFunc:G4};var W4=$e((r,t)=>Math.atan2(r,t)),U4=Me(ho,W4),NN={kernelName:ho,backendName:"cpu",kernelFunc:U4};var j4=he(fo,r=>Math.atanh(r)),TN={kernelName:fo,backendName:"cpu",kernelFunc:j4};function Ec(r,t,e,n,s,o){let a=s.strideHeight,l=s.strideWidth,u=s.dilationHeight,p=s.dilationWidth,f=s.effectiveFilterHeight,m=s.effectiveFilterWidth,d=s.padInfo.top,y=s.padInfo.left,_=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=ae(s.outShape,e),C=v.values,N=s.outShape[1]*s.outShape[2]*s.outShape[3],A=s.outShape[2]*s.outShape[3],B=s.outShape[3];for(let P=0;P<s.batchSize;++P){let L=P*N,Z=P*n[0];for(let K=0;K<s.inChannels;++K)for(let et=0;et<s.outHeight;++et){let it=et*a-d,xt=Math.max(0,it),wt=Math.min(s.inHeight,f+it),St=L+et*A;for(let yt=0;yt<s.outWidth;++yt){let Nt=yt*l-y,ht=Math.max(0,Nt),It=Math.min(s.inWidth,m+Nt),Ft=_,Ct=0,Dt=0;for(let Mt=xt;Mt<wt;Mt+=u){let jt=Z+Mt*n[1];for(let qt=ht;qt<It;qt+=p){let Bt=jt+qt*n[2],Ht=r[Bt+K];o==="max"&&Ht>Ft?Ft=Ht:o==="avg"&&(Ct+=Ht,Dt++)}if(isNaN(Ft))break}let zt=St+yt*B+K;C[zt]=o==="avg"?Ct/Dt:Ft}}}return v}function Vd(r,t,e,n,s=!1,o=!1){let a=ae(n.outShape,"int32"),l=n.strideHeight,u=n.strideWidth,p=n.dilationHeight,f=n.dilationWidth,m=n.effectiveFilterHeight,d=n.effectiveFilterWidth,y=n.padInfo.top,_=n.padInfo.left,v=ae(t,e,r);for(let C=0;C<n.batchSize;++C)for(let N=0;N<n.inChannels;++N)for(let A=0;A<n.outHeight;++A){let B=A*l-y,P=B;for(;P<0;)P+=p;let L=Math.min(n.inHeight,m+B);for(let Z=0;Z<n.outWidth;++Z){let K=Z*u-_,et=K;for(;et<0;)et+=f;let it=Math.min(n.inWidth,d+K),xt=Number.NEGATIVE_INFINITY,wt=-1;for(let St=P;St<L;St+=p){let yt=St-B;for(let Nt=et;Nt<it;Nt+=f){let ht=Nt-K,It=v.get(C,St,Nt,N);It>xt&&(xt=It,s?wt=o?((C*n.inHeight+St)*n.inWidth+Nt)*n.inChannels+N:(St*n.inWidth+Nt)*n.inChannels+N:wt=yt*d+ht)}}a.set(wt,C,A,Z,N)}}return a}function Gd(r,t,e,n,s,o){let a=s.strideDepth,l=s.strideHeight,u=s.strideWidth,p=s.dilationDepth,f=s.dilationHeight,m=s.dilationWidth,d=s.effectiveFilterDepth,y=s.effectiveFilterHeight,_=s.effectiveFilterWidth,v=s.padInfo.front,C=s.padInfo.top,N=s.padInfo.left,A=o==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,B=ae(s.outShape,e),P=B.values,L=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],Z=s.outShape[2]*s.outShape[3]*s.outShape[4],K=s.outShape[3]*s.outShape[4],et=s.outShape[4];for(let it=0;it<s.batchSize;++it){let xt=it*L,wt=it*n[0];for(let St=0;St<s.inChannels;++St)for(let yt=0;yt<s.outDepth;++yt){let Nt=yt*a-v,ht=Nt;for(;ht<0;)ht+=p;let It=Math.min(s.inDepth,d+Nt),Ft=xt+yt*Z;for(let Ct=0;Ct<s.outHeight;++Ct){let Dt=Ct*l-C,zt=Dt;for(;zt<0;)zt+=f;let Mt=Math.min(s.inHeight,y+Dt),jt=Ft+Ct*K;for(let qt=0;qt<s.outWidth;++qt){let Bt=qt*u-N,Ht=Bt;for(;Ht<0;)Ht+=m;let Zt=Math.min(s.inWidth,_+Bt),ne=jt+qt*et,Qt=A,te=0,oe=0;for(let We=ht;We<It;We+=p){let xr=wt+We*n[1];for(let nr=zt;nr<Mt;nr+=f){let sr=xr+nr*n[2];for(let or=Ht;or<Zt;or+=m){let pr=sr+or*n[3],wr=r[pr+St];if(o==="max"&&wr>Qt?Qt=wr:o==="avg"&&(te+=wr,oe++),isNaN(Qt))break}if(isNaN(Qt))break}if(isNaN(Qt))break}let Re=ne+St;P[Re]=o==="avg"?te/oe:Qt}}}}return B}function EN(r,t){let e=ae(t.outShape,"int32"),n=t.strideDepth,s=t.strideHeight,o=t.strideWidth,a=t.dilationDepth,l=t.dilationHeight,u=t.dilationWidth,p=t.effectiveFilterDepth,f=t.effectiveFilterHeight,m=t.effectiveFilterWidth,d=t.padInfo.front,y=t.padInfo.top,_=t.padInfo.left;for(let v=0;v<t.batchSize;++v)for(let C=0;C<t.inChannels;++C)for(let N=0;N<t.outDepth;++N){let A=N*n-d,B=A;for(;B<0;)B+=a;let P=Math.min(t.inDepth,p+A);for(let L=0;L<t.outHeight;++L){let Z=L*s-y,K=Z;for(;K<0;)K+=l;let et=Math.min(t.inHeight,f+Z);for(let it=0;it<t.outWidth;++it){let xt=it*o-_,wt=xt;for(;wt<0;)wt+=u;let St=Math.min(t.inWidth,m+xt),yt=Number.NEGATIVE_INFINITY,Nt=-1;for(let ht=B;ht<P;ht+=a){let It=ht-A;for(let Ft=K;Ft<et;Ft+=l){let Ct=Ft-Z;for(let Dt=wt;Dt<St;Dt+=u){let zt=Dt-xt,Mt=r.get(v,ht,Ft,Dt,C);Mt>=yt&&(yt=Mt,Nt=It*f*m+Ct*f+zt)}}}e.set(Nt,v,N,L,it,C)}}}return e}function q4(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t;$t(s,"avgPool");let{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=n,p=1;E.assert(H.eitherStridesOrDilationsAreOne(a,p),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let f=H.computePool2DInfo(s.shape,o,a,p,l,u),m;if(f.filterWidth===1&&f.filterHeight===1&&E.arraysEqual(f.inShape,f.outShape))m=Qr({inputs:{x:s},backend:e});else{let d=e.data.get(s.dataId).values,y=E.computeStrides(s.shape),_=Ec(d,s.shape,s.dtype,y,f,"avg");m=e.makeTensorInfo(f.outShape,s.dtype,_.values)}return m}var AN={kernelName:Ni,backendName:"cpu",kernelFunc:q4};function H4(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:u,dataFormat:p}=n;$t(s,"avgPool3d");let f=H.computePool3DInfo(s.shape,o,a,1,l,u,p),m=e.data.get(s.dataId).values,d=Gd(m,s.shape,s.dtype,E.computeStrides(s.shape),f,"avg");return e.makeTensorInfo(d.shape,"float32",d.values)}var $N={kernelName:Ti,backendName:"cpu",kernelFunc:H4};function K4(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,input:o}=t,{filterSize:a,strides:l,pad:u,dimRoundingMode:p}=n;$t([s,o],"avgPool3DGrad");let f=H.computePool3DInfo(o.shape,a,l,1,u,p),m=f.strideDepth,d=f.strideHeight,y=f.strideWidth,_=f.filterDepth,v=f.filterHeight,C=f.filterWidth,N=f.dilationDepth,A=f.dilationHeight,B=f.dilationWidth,P=f.effectiveFilterDepth,L=f.effectiveFilterHeight,Z=f.effectiveFilterWidth,K=P-1-f.padInfo.front,et=Z-1-f.padInfo.left,it=L-1-f.padInfo.top,xt=ae(o.shape,"float32"),wt=1/(_*v*C),St=e.bufferSync(s);for(let yt=0;yt<f.batchSize;++yt)for(let Nt=0;Nt<f.inChannels;++Nt)for(let ht=0;ht<f.inDepth;++ht)for(let It=0;It<f.inHeight;++It)for(let Ft=0;Ft<f.inWidth;++Ft){let Ct=ht-K,Dt=It-it,zt=Ft-et,Mt=0;for(let jt=0;jt<P;jt+=N){let qt=(Ct+jt)/m;if(!(qt<0||qt>=f.outDepth||Math.floor(qt)!==qt))for(let Bt=0;Bt<L;Bt+=A){let Ht=(Dt+Bt)/d;if(!(Ht<0||Ht>=f.outHeight||Math.floor(Ht)!==Ht))for(let Zt=0;Zt<Z;Zt+=B){let ne=(zt+Zt)/y;if(ne<0||ne>=f.outWidth||Math.floor(ne)!==ne)continue;Mt+=St.get(yt,qt,Ht,ne,Nt)}}}xt.set(Mt*wt,yt,ht,It,Ft,Nt)}return e.makeTensorInfo(xt.shape,xt.dtype,xt.values)}var DN={kernelName:lu,backendName:"cpu",kernelFunc:K4};function X4(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,input:o}=t,a=o;$t([s,o],"avgPoolGrad");let{filterSize:l,strides:u,pad:p}=n,f=H.computePool2DInfo(a.shape,l,u,1,p),m=f.strideHeight,d=f.strideWidth,y=f.filterHeight,_=f.filterWidth,v=f.dilationHeight,C=f.dilationWidth,N=f.effectiveFilterHeight,A=f.effectiveFilterWidth,B=A-1-f.padInfo.left,P=N-1-f.padInfo.top,L=ae(a.shape,"float32"),Z=1/(y*_),K=e.data.get(s.dataId).values,et=ae(s.shape,"float32",K);for(let it=0;it<f.batchSize;++it)for(let xt=0;xt<f.inChannels;++xt)for(let wt=0;wt<f.inHeight;++wt)for(let St=0;St<f.inWidth;++St){let yt=wt-P,Nt=St-B,ht=0;for(let It=0;It<N;It+=v){let Ft=(yt+It)/m;if(!(Ft<0||Ft>=f.outHeight||Math.floor(Ft)!==Ft))for(let Ct=0;Ct<A;Ct+=C){let Dt=(Nt+Ct)/d;if(Dt<0||Dt>=f.outWidth||Math.floor(Dt)!==Dt)continue;ht+=et.get(it,Ft,Dt,xt)}}L.set(ht*Z,it,wt,St,xt)}return e.makeTensorInfo(L.shape,L.dtype,L.values)}var RN={kernelName:au,backendName:"cpu",kernelFunc:X4};function Y4(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,scale:o,offset:a,mean:l,variance:u}=t;E.assert(l.shape.length===u.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E.assert(a==null||l.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E.assert(o==null||l.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),$t([s,l,u,o,a],"batchNorm");let{varianceEpsilon:p}=n;p==null&&(p=.001);let f=e.data.get(s.dataId).values,m=e.data.get(l.dataId).values,d=e.data.get(u.dataId).values,y=o?e.data.get(o.dataId).values:new Float32Array([1]),_=a?e.data.get(a.dataId).values:new Float32Array([0]),v=new Float32Array(f.length),C=_.length,N=y.length,A=d.length,B=m.length,P=0,L=0,Z=0,K=0;for(let et=0;et<f.length;++et)v[et]=_[P++]+(f[et]-m[L++])*y[Z++]/Math.sqrt(d[K++]+p),P>=C&&(P=0),L>=B&&(L=0),Z>=N&&(Z=0),K>=A&&(K=0);return e.makeTensorInfo(s.shape,s.dtype,v)}var FN={kernelName:Bi,backendName:"cpu",kernelFunc:Y4};function Z4(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{blockShape:o,crops:a}=n;$t([s],"batchToSpaceND");let l=o.reduce((N,A)=>N*A),u=H.getReshaped(s.shape,o,l),p=H.getPermuted(u.length,o.length),f=H.getReshapedPermuted(s.shape,o,l),m=H.getSliceBeginCoords(a,o.length),d=H.getSliceSize(f,a,o.length),y=Oe({inputs:{x:s},backend:e,attrs:{shape:u}}),_=Nr({inputs:{x:y},backend:e,attrs:{perm:p}}),v=Oe({inputs:{x:_},backend:e,attrs:{shape:f}}),C=ps({inputs:{x:v},backend:e,attrs:{begin:m,size:d}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(v),C}var ON={kernelName:Ai,backendName:"cpu",kernelFunc:Z4};function J4(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,weights:o}=t,{size:a}=n,l=e.data.get(s.dataId).values,u=e.data.get(o.dataId).values,p=rf(l,u,o.dtype,o.shape,a);return e.makeTensorInfo([a],o.dtype,p)}var PN={kernelName:Xf,backendName:"cpu",kernelFunc:J4};var Q4=he(go,(r,t)=>{let e=t;return r>e.clipValueMax?e.clipValueMax:r<e.clipValueMin?e.clipValueMin:r}),LN={kernelName:go,backendName:"cpu",kernelFunc:Q4};var tV=r=>{let{x:t}=r.inputs,e=r.backend,n=new Float32Array(E.sizeFromShape(t.shape)),s=e.data.get(t.dataId),o=s.complexTensorInfos.real,a=s.complexTensorInfos.imag,l=e.data.get(o.dataId).values,u=e.data.get(a.dataId).values;for(let p=0;p<l.length;p++){let f=l[p],m=u[p];n[p]=Math.hypot(f,m)}return e.makeOutput(n,t.shape,"float32")},zN={kernelName:$i,backendName:"cpu",kernelFunc:tV};function eo(r){let{inputs:t,backend:e}=r,{input:n}=t,s=e.data.get(n.dataId).complexTensorInfos.imag,o=e.data.get(s.dataId).values;return e.makeTensorInfo(s.shape,s.dtype,o)}var MN={kernelName:bu,backendName:"cpu",kernelFunc:eo};function Ra(r){let{inputs:t,backend:e,attrs:n}=r,{axis:s}=n,o=E.parseAxisParam(s,t[0].shape)[0],a=H.computeOutShape(t.map(v=>v.shape),o);if(E.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let l=t.filter(v=>E.sizeFromShape(v.shape)>0);if(l.length===1)return Qr({inputs:{x:l[0]},backend:e});let u=l.map(v=>v.shape);if(H.assertParamsConsistent(u,o),l[0].dtype==="complex64"){let v=l.map(P=>as({inputs:{input:P},backend:e})),C=l.map(P=>eo({inputs:{input:P},backend:e})),N=Ra({inputs:v,backend:e,attrs:{axis:o}}),A=Ra({inputs:C,backend:e,attrs:{axis:o}}),B=$r({inputs:{real:N,imag:A},backend:e});return v.forEach(P=>e.disposeIntermediateTensorInfo(P)),C.forEach(P=>e.disposeIntermediateTensorInfo(P)),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(A),B}let p=l.map(v=>{let C=E.sizeFromShape(v.shape.slice(o));return Oe({inputs:{x:v},backend:e,attrs:{shape:[-1,C]}})}),f=p.map(v=>({vals:e.data.get(v.dataId).values,shape:v.shape}));a=H.computeOutShape(p.map(v=>v.shape),1);let m=p[0].shape[0]===1,d=Zy(f,a,t[0].dtype,m),y=H.computeOutShape(l.map(v=>v.shape),o),_=e.makeTensorInfo(y,t[0].dtype,d);return p.forEach(v=>e.disposeIntermediateTensorInfo(v)),_}var BN={kernelName:Di,backendName:"cpu",kernelFunc:Ra};function m_(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o}=t,{strides:a,pad:l,dataFormat:u,dilations:p,dimRoundingMode:f}=n;$t([s,o],"conv2d");let m=H.convertConv2DDataFormat(u),d=H.computeConv2DInfo(s.shape,o.shape,a,p,l,f,!1,m),y=d.filterHeight,_=d.filterWidth,v=d.dilationHeight,C=d.dilationWidth,N=d.padInfo.left,A=d.padInfo.top,B=d.dataFormat==="channelsLast",P=new er(d.outShape,s.dtype),L=E.computeStrides(s.shape),Z=E.computeStrides(o.shape),K=L[0],et=B?L[1]:L[2],it=B?L[2]:1,xt=B?1:L[1],wt=P.strides[0],St=B?P.strides[1]:P.strides[2],yt=B?P.strides[2]:1,Nt=B?1:P.strides[1],ht=e.data.get(s.dataId).values,It=e.data.get(o.dataId).values,Ft=P.values;for(let Ct=0;Ct<d.batchSize;++Ct){let Dt=Ct*K,zt=Ct*wt;for(let Mt=0;Mt<d.outHeight;++Mt){let jt=zt+Mt*St,qt=Mt*d.strideHeight-A;for(let Bt=0;Bt<y;++Bt){let Ht=qt+Bt*v;if(Ht<0||Ht>=d.inHeight)continue;let Zt=Bt*Z[0],ne=Dt+Ht*et;for(let Qt=0;Qt<d.outWidth;++Qt){let te=jt+Qt*yt,oe=Qt*d.strideWidth-N;for(let Re=0;Re<_;++Re){let We=oe+Re*C;if(We<0||We>=d.inWidth)continue;let xr=Zt+Re*Z[1],nr=ne+We*it,sr=xr;for(let or=0;or<d.inChannels;++or){let pr=ht[nr+or*xt];for(let wr=0;wr<d.outChannels;++wr)Ft[te+wr*Nt]+=pr*It[sr+wr];sr+=d.outChannels}}}}}}return e.makeTensorInfo(P.shape,P.dtype,Ft)}var VN={kernelName:Ri,backendName:"cpu",kernelFunc:m_};function eV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,dy:o}=t,{strides:a,pad:l,dataFormat:u,dimRoundingMode:p,filterShape:f}=n;$t([s,o],"conv2dBackpropFilter");let m=H.convertConv2DDataFormat(u),d=H.computeConv2DInfo(s.shape,f,a,1,l,p,!1,m),{strideHeight:y,strideWidth:_,filterHeight:v,filterWidth:C}=d,N=d.dataFormat==="channelsLast",A=new er(d.filterShape,"float32"),B=d.padInfo.left,P=d.padInfo.top,L=e.data.get(s.dataId).values,Z=e.data.get(o.dataId).values,K=new er(s.shape,s.dtype,L),et=new er(o.shape,o.dtype,Z);for(let it=0;it<v;++it){let xt=Math.max(0,Math.ceil((P-it)/y)),wt=Math.min(d.outHeight,(d.inHeight+P-it)/y);for(let St=0;St<C;++St){let yt=Math.max(0,Math.ceil((B-St)/_)),Nt=Math.min(d.outWidth,(d.inWidth+B-St)/_);for(let ht=0;ht<d.inChannels;++ht)for(let It=0;It<d.outChannels;++It){let Ft=0;for(let Ct=0;Ct<d.batchSize;++Ct)for(let Dt=xt;Dt<wt;++Dt){let zt=it+Dt*y-P;for(let Mt=yt;Mt<Nt;++Mt){let jt=St+Mt*_-B;N?Ft+=K.get(Ct,zt,jt,ht)*et.get(Ct,Dt,Mt,It):Ft+=K.get(Ct,ht,zt,jt)*et.get(Ct,It,Dt,Mt)}}A.set(Ft,it,St,ht,It)}}}return e.makeTensorInfo(A.shape,A.dtype,A.values)}var GN={kernelName:cu,backendName:"cpu",kernelFunc:eV};function rV(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,filter:o}=t,{inputShape:a,strides:l,pad:u,dataFormat:p,dimRoundingMode:f}=n;$t([s,o],"conv2dBackpropInput");let m=E.computeStrides(o.shape),d=E.computeStrides(s.shape),y=H.convertConv2DDataFormat(p),_=H.computeConv2DInfo(a,o.shape,l,1,u,f,!1,y),v=new er(_.inShape,"float32"),C=v.values,N=e.data.get(s.dataId).values,A=e.data.get(o.dataId).values,[B,P,L]=m,{batchSize:Z,filterHeight:K,filterWidth:et,inChannels:it,inHeight:xt,inWidth:wt,outChannels:St,outHeight:yt,outWidth:Nt,strideHeight:ht,strideWidth:It}=_;y=_.dataFormat;let Ft=K-1-_.padInfo.top,Ct=et-1-_.padInfo.left,Dt=y==="channelsLast",zt=v.strides[0],Mt=Dt?v.strides[1]:v.strides[2],jt=Dt?v.strides[2]:1,qt=Dt?1:v.strides[1],Bt=d[0],Ht=Dt?d[1]:d[2],Zt=Dt?d[2]:1,ne=Dt?1:d[1];for(let Qt=0;Qt<Z;++Qt)for(let te=0;te<it;++te)for(let oe=0;oe<xt;++oe){let Re=oe-Ft,We=Math.max(0,Math.ceil(Re/ht)),xr=Math.min(yt,(K+Re)/ht);for(let nr=0;nr<wt;++nr){let sr=nr-Ct,or=Math.max(0,Math.ceil(sr/It)),pr=Math.min(Nt,(et+sr)/It),wr=0;for(let Pe=We;Pe<xr;++Pe){let Tn=Pe*ht-Re;for(let Ue=or;Ue<pr;++Ue){let Ls=Ue*It-sr,ye=Bt*Qt+Ht*Pe+Zt*Ue,i=B*(K-1-Tn)+P*(et-1-Ls)+L*te;for(let c=0;c<St;++c){let h=N[ye+ne*c],g=A[i+c];wr+=h*g}}}let Kn=zt*Qt+Mt*oe+jt*nr+qt*te;C[Kn]=wr}}return e.makeTensorInfo(v.shape,v.dtype,v.values)}var WN={kernelName:Fi,backendName:"cpu",kernelFunc:rV};function nV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o}=t,{strides:a,pad:l,dilations:u}=n;$t([s,o],"conv3d");let p=H.computeConv3DInfo(s.shape,o.shape,a,u,l),{filterDepth:f,filterHeight:m,filterWidth:d,dilationDepth:y,dilationHeight:_,dilationWidth:v,padInfo:C}=p,N=C.front,A=C.left,B=C.top,P=new er(p.outShape,s.dtype),L=e.data.get(s.dataId).values,Z=e.data.get(o.dataId).values,K=P.values,et=E.computeStrides(s.shape),it=E.computeStrides(o.shape);for(let xt=0;xt<p.batchSize;++xt){let wt=xt*et[0],St=xt*P.strides[0];for(let yt=0;yt<p.outDepth;++yt){let Nt=St+yt*P.strides[1],ht=yt*p.strideDepth-N;for(let It=0;It<f;++It){let Ft=ht+It*y;if(Ft<0||Ft>=p.inDepth)continue;let Ct=It*it[0],Dt=wt+Ft*et[1];for(let zt=0;zt<p.outHeight;++zt){let Mt=Nt+zt*P.strides[2],jt=zt*p.strideHeight-B;for(let qt=0;qt<m;++qt){let Bt=jt+qt*_;if(Bt<0||Bt>=p.inHeight)continue;let Ht=Ct+qt*it[1],Zt=Dt+Bt*et[2];for(let ne=0;ne<p.outWidth;++ne){let Qt=Mt+ne*p.outChannels,te=ne*p.strideWidth-A;for(let oe=0;oe<d;++oe){let Re=te+oe*v;if(Re<0||Re>=p.inWidth)continue;let We=Ht+oe*it[2],xr=Zt+Re*p.inChannels,nr=We;for(let sr=0;sr<p.inChannels;++sr){let or=L[xr+sr];for(let pr=0;pr<p.outChannels;++pr)K[Qt+pr]+=or*Z[nr+pr];nr+=p.outChannels}}}}}}}}return e.makeTensorInfo(P.shape,P.dtype,P.values)}var UN={kernelName:Oi,backendName:"cpu",kernelFunc:nV};function sV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,dy:o}=t,{strides:a,pad:l,filterShape:u}=n;$t([s,o],"conv3dBackpropFilterV2");let p=E.computeStrides(s.shape),f=E.computeStrides(o.shape),m=H.computeConv3DInfo(s.shape,u,a,1,l),d=m.strideDepth,y=m.strideHeight,_=m.strideWidth,v=m.filterDepth,C=m.filterHeight,N=m.filterWidth,A=new er(m.filterShape,"float32"),B=A.values,[P,L,Z,K]=A.strides,et=e.data.get(o.dataId).values,[it,xt,wt,St]=f,yt=e.data.get(s.dataId).values,[Nt,ht,It,Ft]=p,Ct=m.padInfo.front,Dt=m.padInfo.left,zt=m.padInfo.top;for(let Mt=0;Mt<v;++Mt){let jt=Math.max(0,Math.ceil((Ct-Mt)/d)),qt=Math.min(m.outDepth,(m.inDepth+Ct-Mt)/d),Bt=Mt*P;for(let Ht=0;Ht<C;++Ht){let Zt=Math.max(0,Math.ceil((zt-Ht)/y)),ne=Math.min(m.outHeight,(m.inHeight+zt-Ht)/y),Qt=Ht*L+Bt;for(let te=0;te<N;++te){let oe=Math.max(0,Math.ceil((Dt-te)/_)),Re=Math.min(m.outWidth,(m.inWidth+Dt-te)/_),We=te*Z+Qt;for(let xr=0;xr<m.inChannels;++xr){let nr=xr*K+We;for(let sr=0;sr<m.outChannels;++sr){let or=0;for(let pr=0;pr<m.batchSize;++pr){let wr=pr*Nt,Kn=pr*it;for(let Pe=jt;Pe<qt;++Pe){let Ue=(Mt+Pe*d-Ct)*ht+wr,Ls=Pe*xt+Kn;for(let ye=Zt;ye<ne;++ye){let c=(Ht+ye*y-zt)*It+Ue,h=ye*wt+Ls;for(let g=oe;g<Re;++g){let b=(te+g*_-Dt)*Ft+c,k=g*St+h;or+=yt[b+xr]*et[k+sr]}}}}B[nr+sr]=or}}}}}return e.makeTensorInfo(A.shape,A.dtype,A.values)}var jN={kernelName:pu,backendName:"cpu",kernelFunc:sV};function oV(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,filter:o}=t,{pad:a,strides:l,inputShape:u}=n;$t([s],"conv3dBackpropInputV2");let p=E.computeStrides(s.shape),f=E.computeStrides(o.shape),m=H.computeConv3DInfo(u,o.shape,l,1,a),d=new er(m.inShape,"float32"),y=d.values,[_,v,C,N]=d.strides,A=e.data.get(s.dataId).values,[B,P,L,Z]=p,K=e.data.get(o.dataId).values,[et,it,xt,wt]=f,{batchSize:St,filterDepth:yt,filterHeight:Nt,filterWidth:ht,inChannels:It,inDepth:Ft,inHeight:Ct,inWidth:Dt,outChannels:zt,outDepth:Mt,outHeight:jt,outWidth:qt,strideDepth:Bt,strideHeight:Ht,strideWidth:Zt}=m,ne=yt-1-m.padInfo.front,Qt=Nt-1-m.padInfo.top,te=ht-1-m.padInfo.left;for(let oe=0;oe<St;++oe)for(let Re=0;Re<It;++Re)for(let We=0;We<Ft;++We){let xr=We-ne,nr=Math.max(0,Math.ceil(xr/Bt)),sr=Math.min(Mt,(yt+xr)/Bt);for(let or=0;or<Ct;++or){let pr=or-Qt,wr=Math.max(0,Math.ceil(pr/Ht)),Kn=Math.min(jt,(Nt+pr)/Ht);for(let Pe=0;Pe<Dt;++Pe){let Tn=Pe-te,Ue=Math.max(0,Math.ceil(Tn/Zt)),Ls=Math.min(qt,(ht+Tn)/Zt),ye=0;for(let i=nr;i<sr;++i){let c=i*Bt-xr;for(let h=wr;h<Kn;++h){let g=h*Ht-pr;for(let x=Ue;x<Ls;++x){let b=x*Zt-Tn,k=B*oe+P*i+L*h+Z*x,w=et*(yt-1-c)+it*(Nt-1-g)+xt*(ht-1-b)+wt*Re;for(let S=0;S<zt;++S){let I=A[k+S],D=K[w+S];ye+=I*D}}}}y[_*oe+v*We+C*or+N*Pe+Re]=ye}}}return e.makeTensorInfo(d.shape,d.dtype,d.values)}var qN={kernelName:fu,backendName:"cpu",kernelFunc:oV};var iV=he(xo,r=>Math.cos(r)),HN={kernelName:xo,backendName:"cpu",kernelFunc:iV};var aV=he(yo,r=>Math.cosh(r)),KN={kernelName:yo,backendName:"cpu",kernelFunc:aV};function lV(r){let{inputs:t,backend:e,attrs:n}=r,{image:s,boxes:o,boxInd:a}=t,{cropSize:l,method:u,extrapolationValue:p}=n,[f,m,d,y]=s.shape,_=o.shape[0],[v,C]=l,N=ae([_,v,C,y],"float32"),A=e.data.get(o.dataId).values,B=e.data.get(a.dataId).values,P=e.data.get(s.dataId).values,L=E.computeStrides(s.shape),Z=E.computeStrides(N.shape);for(let K=0;K<_;K++){let et=K*4,it=A[et],xt=A[et+1],wt=A[et+2],St=A[et+3],yt=B[K];if(yt>=f)continue;let Nt=v>1?(wt-it)*(m-1)/(v-1):0,ht=C>1?(St-xt)*(d-1)/(C-1):0;for(let It=0;It<v;It++){let Ft=v>1?it*(m-1)+It*Nt:.5*(it+wt)*(m-1);if(Ft<0||Ft>m-1){for(let Ct=0;Ct<C;Ct++)for(let Dt=0;Dt<y;Dt++){let zt=Dt+Ct*Z[2]+It*Z[1]+K*Z[0];N.values[zt]=p}continue}if(u==="bilinear"){let Ct=Math.floor(Ft),Dt=Math.ceil(Ft),zt=Ft-Ct;for(let Mt=0;Mt<C;Mt++){let jt=C>1?xt*(d-1)+Mt*ht:.5*(xt+St)*(d-1);if(jt<0||jt>d-1){for(let Zt=0;Zt<y;Zt++){let ne=Zt+Mt*Z[2]+It*Z[1]+K*Z[0];N.values[ne]=p}continue}let qt=Math.floor(jt),Bt=Math.ceil(jt),Ht=jt-qt;for(let Zt=0;Zt<y;Zt++){let ne=Zt+qt*L[2]+Ct*L[1]+yt*L[0],Qt=P[ne];ne=Zt+Bt*L[2]+Ct*L[1]+yt*L[0];let te=P[ne];ne=Zt+qt*L[2]+Dt*L[1]+yt*L[0];let oe=P[ne];ne=Zt+Bt*L[2]+Dt*L[1]+yt*L[0];let Re=P[ne],We=Qt+(te-Qt)*Ht,xr=oe+(Re-oe)*Ht;ne=Zt+Mt*Z[2]+It*Z[1]+K*Z[0],N.values[ne]=We+(xr-We)*zt}}}else for(let Ct=0;Ct<C;++Ct){let Dt=C>1?xt*(d-1)+Ct*ht:.5*(xt+St)*(d-1);if(Dt<0||Dt>d-1){for(let jt=0;jt<y;jt++){let qt=jt+Ct*Z[2]+It*Z[1]+K*Z[0];N.values[qt]=p}continue}let zt=Math.round(Dt),Mt=Math.round(Ft);for(let jt=0;jt<y;jt++){let qt=jt+zt*L[2]+Mt*L[1]+yt*L[0],Bt=jt+Ct*Z[2]+It*Z[1]+K*Z[0];N.values[Bt]=P[qt]}}}}return e.makeTensorInfo(N.shape,N.dtype,N.values)}var XN={kernelName:Yf,backendName:"cpu",kernelFunc:lV};function uV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,exclusive:a,reverse:l}=n;$t(s,"cumsum");let u=H.getAxesPermutation([o],s.shape.length),p=s;u!=null&&(p=Nr({inputs:{x:s},backend:e,attrs:{perm:u}}));let f=H.getInnerMostAxes(1,s.shape.length)[0];if(f!==p.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${p.shape.length-1} but got axis=${f}`);let m=Br(p.dtype,"int32"),d=E.makeZerosTypedArray(E.sizeFromShape(p.shape),m),y=e.data.get(p.dataId).values,_=p.shape[p.shape.length-1],v=l?(N,A)=>N+_-A-1:(N,A)=>N+A;for(let N=0;N<y.length;N+=_)for(let A=0;A<_;A++){let B=v(N,A);if(A===0)d[B]=a?0:y[B];else{let P=v(N,A-1);d[B]=a?y[P]+d[P]:y[B]+d[P]}}let C=e.makeTensorInfo(p.shape,m,d);if(u!=null){let N=H.getUndoAxesPermutation(u),A=Nr({inputs:{x:C},backend:e,attrs:{perm:N}});return e.disposeIntermediateTensorInfo(C),e.disposeIntermediateTensorInfo(p),A}return C}var YN={kernelName:Pi,backendName:"cpu",kernelFunc:uV};function cV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,weights:o}=t,{size:a,binaryOutput:l}=n;if(s.shape.length===1){let u=e.data.get(s.dataId).values,p=e.data.get(o.dataId).values,f=rf(u,p,o.dtype,o.shape,a);return e.makeTensorInfo([a],o.dtype,f)}else if(s.shape.length===2){let u=e.bufferSync(s),p=e.bufferSync(o),f=Yy(u,p,a,l);return e.makeTensorInfo(f.shape,o.dtype,f.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var ZN={kernelName:Zf,backendName:"cpu",kernelFunc:cV};function pV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{blockSize:o,dataFormat:a}=n;E.assert(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`),E.assert(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);let l=s.shape[0],u=s.shape[1],p=s.shape[2],f=s.shape[3],m=u*o,d=p*o,y=f/(o*o),_=e.data.get(s.dataId).values,v=new Float32Array(l*m*d*y),C=0;for(let N=0;N<l;++N)for(let A=0;A<m;++A){let B=Math.floor(A/o),P=A%o;for(let L=0;L<d;++L){let Z=Math.floor(L/o),K=L%o,et=(P*o+K)*y;for(let it=0;it<y;++it){let wt=it+et+f*(Z+p*(B+u*N));v[C++]=_[wt]}}}return e.makeTensorInfo([l,m,d,y],s.dtype,v)}var JN={kernelName:hu,backendName:"cpu",kernelFunc:pV};function d_(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o}=t,{strides:a,pad:l,dilations:u,dimRoundingMode:p}=n;$t([s,o],"depthwiseConv2DNative");let f=E.computeStrides(s.shape),m=E.computeStrides(o.shape),d=u;d==null&&(d=[1,1]),E.assert(H.eitherStridesOrDilationsAreOne(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);let y=H.computeConv2DInfo(s.shape,o.shape,a,d,l,p,!0),{filterHeight:_,filterWidth:v,dilationHeight:C,dilationWidth:N,padInfo:A}=y,B=A.left,P=A.top,L=y.outChannels/y.inChannels,Z=new er(y.outShape,s.dtype),K=e.data.get(s.dataId).values,et=e.data.get(o.dataId).values,it=Z.values;for(let xt=0;xt<y.batchSize;++xt){let wt=xt*f[0],St=xt*Z.strides[0];for(let yt=0;yt<y.outHeight;++yt){let Nt=St+yt*Z.strides[1],ht=yt*y.strideHeight-B;for(let It=0;It<_;++It){let Ft=ht+It*C;if(Ft<0||Ft>=y.inHeight)continue;let Ct=It*m[0],Dt=wt+Ft*f[1];for(let zt=0;zt<y.outWidth;++zt){let Mt=Nt+zt*Z.strides[2],jt=zt*y.strideWidth-P;for(let qt=0;qt<v;++qt){let Bt=jt+qt*N;if(Bt<0||Bt>=y.inWidth)continue;let Ht=Ct+qt*m[1],Zt=Dt+Bt*y.inChannels,ne=Mt,Qt=Ht;for(let te=0;te<y.inChannels;++te){let oe=K[Zt+te];for(let Re=0;Re<L;++Re)it[ne+Re]+=oe*et[Qt+Re];ne+=L,Qt+=L}}}}}}return e.makeTensorInfo(Z.shape,Z.dtype,Z.values)}var QN={kernelName:Li,backendName:"cpu",kernelFunc:d_};function fV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,dy:o}=t,{strides:a,dilations:l,pad:u,dimRoundingMode:p,filterShape:f}=n;$t([s,o],"depthwiseConv2dNativeBackpropFilter");let m=H.computeConv2DInfo(s.shape,f,a,l,u,p,!0),{strideHeight:d,strideWidth:y,filterHeight:_,filterWidth:v}=m,C=new er(m.filterShape,"float32"),N=m.padInfo.left,A=m.padInfo.top,B=m.outChannels/m.inChannels,P=e.data.get(s.dataId).values,L=new er(s.shape,s.dtype,P),Z=e.data.get(o.dataId).values,K=new er(o.shape,o.dtype,Z);for(let et=0;et<_;++et){let it=Math.max(0,Math.ceil((A-et)/d)),xt=Math.min(m.outHeight,(m.inHeight+A-et)/d);for(let wt=0;wt<v;++wt){let St=Math.max(0,Math.ceil((N-wt)/y)),yt=Math.min(m.outWidth,(m.inWidth+N-wt)/y);for(let Nt=0;Nt<m.outChannels;++Nt){let ht=Math.trunc(Nt/B),It=Nt%B,Ft=0;for(let Ct=0;Ct<m.batchSize;++Ct)for(let Dt=it;Dt<xt;++Dt){let zt=et+Dt*d-A;for(let Mt=St;Mt<yt;++Mt){let jt=wt+Mt*y-N;Ft+=L.get(Ct,zt,jt,ht)*K.get(Ct,Dt,Mt,Nt)}}C.set(Ft,et,wt,ht,It)}}}return e.makeTensorInfo(C.shape,C.dtype,C.values)}var tT={kernelName:mu,backendName:"cpu",kernelFunc:fV};function hV(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,filter:o}=t,{strides:a,dilations:l,pad:u,dimRoundingMode:p,inputShape:f}=n;$t([s,o],"depthwiseConv2DNativeBackpropInput");let m=E.computeStrides(s.shape),d=E.computeStrides(o.shape),y=H.computeConv2DInfo(f,o.shape,a,l,u,p,!0),_=new er(y.inShape,"float32"),v=_.values,[C,N,A]=_.strides,B=e.data.get(s.dataId).values,[P,L,Z]=m,K=e.data.get(o.dataId).values,[et,it,xt]=d,{batchSize:wt,filterHeight:St,filterWidth:yt,inChannels:Nt,inHeight:ht,inWidth:It,outChannels:Ft,outHeight:Ct,outWidth:Dt,strideHeight:zt,strideWidth:Mt}=y,jt=St-1-y.padInfo.top,qt=yt-1-y.padInfo.left,Bt=Ft/Nt;for(let Ht=0;Ht<wt;++Ht)for(let Zt=0;Zt<Nt;++Zt)for(let ne=0;ne<ht;++ne){let Qt=ne-jt,te=Math.max(0,Math.ceil(Qt/zt)),oe=Math.min(Ct,(St+Qt)/zt);for(let Re=0;Re<It;++Re){let We=Re-qt,xr=Math.max(0,Math.ceil(We/Mt)),nr=Math.min(Dt,(yt+We)/Mt),sr=0;for(let or=te;or<oe;++or){let pr=or*zt-Qt;for(let wr=xr;wr<nr;++wr){let Kn=wr*Mt-We,Pe=P*Ht+L*or+Z*wr,Tn=et*(St-1-pr)+it*(yt-1-Kn)+xt*Zt;for(let Ue=0;Ue<Bt;++Ue){let Ls=Zt*Bt+Ue,ye=B[Pe+Ls],i=K[Tn+Ue];sr+=ye*i}}}v[C*Ht+N*ne+A*Re+Zt]=sr}}return e.makeTensorInfo(_.shape,_.dtype,_.values)}var eT={kernelName:du,backendName:"cpu",kernelFunc:hV};function mV(r){let{inputs:t,backend:e}=r,{x:n}=t,s=E.sizeFromShape(n.shape),o=e.data.get(n.dataId).values,a=ae([s,s],n.dtype),l=a.values;for(let p=0;p<o.length;p++)l[p*s+p]=o[p];let u=[...n.shape,...n.shape];return e.makeTensorInfo(u,a.dtype,a.values)}var rT={kernelName:Jf,backendName:"cpu",kernelFunc:mV};var nT={kernelName:zi,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:s}=r,{strides:o,pad:a,dilations:l}=e,u=t,p=u.data.get(n.dataId).values,f=n.shape.length,m=u.data.get(s.dataId).values,d=s.shape.length,{batchSize:y,inHeight:_,inWidth:v,inChannels:C,outHeight:N,outWidth:A,padInfo:B,strideHeight:P,strideWidth:L,filterHeight:Z,filterWidth:K,dilationHeight:et,dilationWidth:it,outShape:xt}=H.computeDilation2DInfo(n.shape,s.shape,o,a,"NHWC",l),wt=E.sizeFromShape(xt),St=xt.length,yt=E.getArrayFromDType(n.dtype,wt);for(let ht=0;ht<y;++ht)for(let It=0;It<N;++It){let Ft=It*P-B.top;for(let Ct=0;Ct<A;++Ct){let Dt=Ct*L-B.left;for(let zt=0;zt<C;++zt){let Mt=Number.MIN_SAFE_INTEGER;for(let qt=0;qt<Z;++qt){let Bt=Ft+qt*et;if(Bt>=0&&Bt<_)for(let Ht=0;Ht<K;++Ht){let Zt=Dt+Ht*it;if(Zt>=0&&Zt<v){let ne=E.locToIndex([ht,Bt,Zt,zt],f,E.computeStrides(n.shape)),Qt=E.locToIndex([qt,Ht,zt],d,E.computeStrides(s.shape)),te=p[ne]+m[Qt];te>Mt&&(Mt=te)}}}let jt=E.locToIndex([ht,It,Ct,zt],St,E.computeStrides(xt));yt[jt]=Mt}}}return{dataId:u.write(E.toTypedArray(yt,n.dtype),xt,n.dtype),shape:xt,dtype:n.dtype}}};var sT={kernelName:tp,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:s,dy:o}=r,{strides:a,pad:l,dilations:u}=e,p=t,f=E.toNestedArray(n.shape,p.data.get(n.dataId).values),m=E.toNestedArray(s.shape,p.data.get(s.dataId).values),{batchSize:d,inHeight:y,inWidth:_,inChannels:v,outHeight:C,outWidth:N,padInfo:A,strideHeight:B,strideWidth:P,filterHeight:L,filterWidth:Z,dilationHeight:K,dilationWidth:et,outShape:it}=H.computeDilation2DInfo(n.shape,s.shape,a,l,"NHWC",u);E.assert(o.rank===it.length,()=>`Error in ${tp}, dy must have the same rank as output ${it.length}, but got ${o.rank}`);let xt=E.toNestedArray(it,p.data.get(o.dataId).values),wt=E.makeZerosNestedTypedArray(s.shape,s.dtype);for(let yt=0;yt<d;++yt)for(let Nt=0;Nt<C;++Nt){let ht=Nt*B-A.top;for(let It=0;It<N;++It){let Ft=It*P-A.left;for(let Ct=0;Ct<v;++Ct){let Dt=Number.MIN_SAFE_INTEGER,zt=0,Mt=0;for(let jt=0;jt<L;++jt){let qt=ht+jt*K;if(qt>=0&&qt<y)for(let Bt=0;Bt<Z;++Bt){let Ht=Ft+Bt*et;if(Ht>=0&&Ht<_){let Zt=f[yt][qt][Ht][Ct]+m[jt][Bt][Ct];Zt>Dt&&(Dt=Zt,zt=jt,Mt=Bt)}}}wt[zt][Mt][Ct]+=xt[yt][Nt][It][Ct]}}}return{dataId:p.write(E.toTypedArray(wt,n.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};var oT={kernelName:Qc,backendName:"cpu",kernelFunc:({inputs:r,backend:t,attrs:e})=>{let{x:n,filter:s,dy:o}=r,{strides:a,pad:l,dilations:u}=e,p=t,f=E.toNestedArray(n.shape,p.data.get(n.dataId).values),m=E.toNestedArray(s.shape,p.data.get(s.dataId).values),{batchSize:d,inHeight:y,inWidth:_,inChannels:v,outHeight:C,outWidth:N,padInfo:A,strideHeight:B,strideWidth:P,filterHeight:L,filterWidth:Z,dilationHeight:K,dilationWidth:et,outShape:it}=H.computeDilation2DInfo(n.shape,s.shape,a,l,"NHWC",u);E.assert(o.rank===it.length,()=>`Error in ${Qc}, dy must have the same rank as output ${it.length}, but got ${o.rank}`);let xt=E.toNestedArray(it,p.data.get(o.dataId).values),wt=E.makeZerosNestedTypedArray(n.shape,n.dtype);for(let yt=0;yt<d;++yt)for(let Nt=0;Nt<C;++Nt){let ht=Nt*B-A.top;for(let It=0;It<N;++It){let Ft=It*P-A.left;for(let Ct=0;Ct<v;++Ct){let Dt=Number.MIN_SAFE_INTEGER,zt=ht<0?0:ht,Mt=Ft<0?0:Ft;for(let jt=0;jt<L;++jt){let qt=ht+jt*K;if(qt>=0&&qt<y)for(let Bt=0;Bt<Z;++Bt){let Ht=Ft+Bt*et;if(Ht>=0&&Ht<_){let Zt=f[yt][qt][Ht][Ct]+m[jt][Bt][Ct];Zt>Dt&&(Dt=Zt,zt=qt,Mt=Ht)}}}wt[yt][zt][Mt][Ct]+=xt[yt][Nt][It][Ct]}}}return{dataId:p.write(E.toTypedArray(wt,n.dtype),n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};function dV(r){let{inputs:t,backend:e}=r,{dy:n,y:s}=t;$t([n,s],"eluGrad");let o=new Float32Array(E.sizeFromShape(s.shape)),a=e.data.get(s.dataId).values,l=e.data.get(n.dataId).values;for(let u=0;u<a.length;++u){let p=a[u];p>=1?o[u]=l[u]:o[u]=l[u]*(p+1)}return e.makeTensorInfo(s.shape,"float32",o)}var iT={kernelName:gu,backendName:"cpu",kernelFunc:dV};var gV=$e((r,t)=>r===t?1:0),g_=Me(Ja,gV,null,"bool"),aT={kernelName:Ja,backendName:"cpu",kernelFunc:g_};var xV=H.ERF_P,yV=H.ERF_A1,_V=H.ERF_A2,bV=H.ERF_A3,vV=H.ERF_A4,wV=H.ERF_A5,CV=he(vo,r=>{let t=Math.sign(r),e=Math.abs(r),n=1/(1+xV*e);return t*(1-((((wV*n+vV)*n+bV)*n+_V)*n+yV)*n*Math.exp(-e*e))}),lT={kernelName:vo,backendName:"cpu",kernelFunc:CV};function Ac(r){let{inputs:t,backend:e,attrs:n}=r,{input:s}=t,{dim:o}=n,a=s.shape.length,l=s.shape.slice(),u=o;return o<0&&(E.assert(-(a+1)<=o,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+o+1),l.splice(u,0,1),Oe({inputs:{x:s},backend:e,attrs:{shape:l}})}var uT={kernelName:Mi,backendName:"cpu",kernelFunc:Ac};var kV=$e((r,t)=>r/t),af=Me(_o,kV),lf={kernelName:_o,backendName:"cpu",kernelFunc:af};function Wd(r,t,e){let n=r.shape,s=n[0],o=n[1],a=e.data.get(r.dataId),l=a.complexTensorInfos.real,u=a.complexTensorInfos.imag,p=[s,o],f=E.sizeFromShape(p),m=E.getTypedArrayFromDType("float32",f),d=E.getTypedArrayFromDType("float32",f);for(let C=0;C<s;C++){let N=ps({inputs:{x:l},backend:e,attrs:{begin:[C,0],size:[1,o]}}),A=ps({inputs:{x:u},backend:e,attrs:{begin:[C,0],size:[1,o]}}),B=$r({inputs:{real:N,imag:A},backend:e}),{real:P,imag:L}=SV(B,t,e),Z=H.mergeRealAndImagArrays(P,L);for(let K=0;K<o;K++){let et=H.getComplexWithIndex(Z,K);m[C*o+K]=et.real,d[C*o+K]=et.imag}e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(A),e.disposeIntermediateTensorInfo(B)}let y=e.makeTensorInfo(p,"float32",m),_=e.makeTensorInfo(p,"float32",d),v=$r({inputs:{real:y,imag:_},backend:e});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),v}function SV(r,t,e){let n=E.sizeFromShape(r.shape),s=e.data.get(r.dataId),o=e.data.get(s.complexTensorInfos.real.dataId).values,a=e.data.get(s.complexTensorInfos.imag.dataId).values;if(IV(n)){let l=x_(o,a,n,t,e),u=[r.shape[0],r.shape[1]];if(t){let p=e.makeTensorInfo(u,"float32",l.real),f=e.makeTensorInfo(u,"float32",l.imag),m=e.makeTensorInfo([],"float32",E.createScalarValue(n,"float32")),d=Qr({inputs:{x:m},backend:e}),y=lf.kernelFunc({inputs:{a:p,b:m},backend:e}),_=lf.kernelFunc({inputs:{a:f,b:d},backend:e}),v=e.data.get(y.dataId).values,C=e.data.get(_.dataId).values;return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),{real:v,imag:C}}return l}else{let l=H.mergeRealAndImagArrays(o,a),u=NV(l,n,t);return H.splitRealAndImagArrays(u)}}function IV(r){return(r&r-1)==0}function x_(r,t,e,n,s){if(e===1)return{real:r,imag:t};let o=H.mergeRealAndImagArrays(r,t),a=e/2,l=H.complexWithEvenIndex(o),u=l.real,p=l.imag,f=[u.length],m=s.makeTensorInfo(f,"float32",u),d=s.makeTensorInfo(f,"float32",p),y=$r({inputs:{real:m,imag:d},backend:s}),_=H.complexWithOddIndex(o),v=_.real,C=_.imag,N=[v.length],A=s.makeTensorInfo(N,"float32",v),B=s.makeTensorInfo(N,"float32",C),P=$r({inputs:{real:A,imag:B},backend:s}),L=x_(u,p,a,n,s),Z=L.real,K=L.imag,et=[Z.length],it=s.makeTensorInfo(et,"float32",Z),xt=s.makeTensorInfo(et,"float32",K),wt=$r({inputs:{real:it,imag:xt},backend:s}),St=x_(v,C,a,n,s),yt=St.real,Nt=St.imag,ht=[yt.length],It=s.makeTensorInfo(ht,"float32",yt),Ft=s.makeTensorInfo(ht,"float32",Nt),Ct=$r({inputs:{real:It,imag:Ft},backend:s}),Dt=H.exponents(e,n),zt=[Dt.real.length],Mt=s.makeTensorInfo(zt,"float32",Dt.real),jt=s.makeTensorInfo(zt,"float32",Dt.imag),qt=$r({inputs:{real:Mt,imag:jt},backend:s}),Bt=nf({inputs:{a:qt,b:Ct},backend:s}),Ht=di({inputs:{a:wt,b:Bt},backend:s}),Zt=of({inputs:{a:wt,b:Bt},backend:s}),ne=as({inputs:{input:Ht},backend:s}),Qt=as({inputs:{input:Zt},backend:s}),te=eo({inputs:{input:Ht},backend:s}),oe=eo({inputs:{input:Zt},backend:s}),Re=Ra({inputs:[ne,Qt],backend:s,attrs:{axis:0}}),We=Ra({inputs:[te,oe],backend:s,attrs:{axis:0}}),xr=s.data.get(Re.dataId).values,nr=s.data.get(We.dataId).values;return s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(d),s.disposeIntermediateTensorInfo(y),s.disposeIntermediateTensorInfo(A),s.disposeIntermediateTensorInfo(B),s.disposeIntermediateTensorInfo(P),s.disposeIntermediateTensorInfo(it),s.disposeIntermediateTensorInfo(xt),s.disposeIntermediateTensorInfo(wt),s.disposeIntermediateTensorInfo(It),s.disposeIntermediateTensorInfo(Ft),s.disposeIntermediateTensorInfo(Ct),s.disposeIntermediateTensorInfo(Mt),s.disposeIntermediateTensorInfo(jt),s.disposeIntermediateTensorInfo(qt),s.disposeIntermediateTensorInfo(Bt),s.disposeIntermediateTensorInfo(Ht),s.disposeIntermediateTensorInfo(Zt),s.disposeIntermediateTensorInfo(ne),s.disposeIntermediateTensorInfo(te),s.disposeIntermediateTensorInfo(Qt),s.disposeIntermediateTensorInfo(oe),s.disposeIntermediateTensorInfo(Re),s.disposeIntermediateTensorInfo(We),{real:xr,imag:nr}}function NV(r,t,e){let n=new Float32Array(t*2);for(let s=0;s<t;s++){let o=0,a=0;for(let l=0;l<t;l++){let u=H.exponent(s*l,t,e),p=H.getComplexWithIndex(r,l);o+=p.real*u.real-p.imag*u.imag,a+=p.real*u.imag+p.imag*u.real}e&&(o/=t,a/=t),H.assignToTypedArray(n,o,a,s)}return n}function TV(r){let{inputs:t,backend:e}=r,{input:n}=t,s=E.sizeFromShape(n.shape),o=n.shape[n.shape.length-1],a=s/o,l=Oe({inputs:{x:n},backend:e,attrs:{shape:[a,o]}}),u=Wd(l,!1,e),p=Oe({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),p}var cT={kernelName:xu,backendName:"cpu",kernelFunc:TV};function uf(r){let{backend:t,attrs:e}=r,{shape:n,value:s,dtype:o}=e,a=o||E.inferDtype(s),l=E.getArrayFromDType(a,E.sizeFromShape(n));return EV(l,s,a),t.makeTensorInfo(n,a,l)}var pT={kernelName:yu,backendName:"cpu",kernelFunc:uf};function EV(r,t,e){r.fill(t)}var fT={kernelName:Qf,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,s=e,o=E.getTypedArrayFromDType(n.dtype,E.sizeFromShape(n.shape)),[a,l,u,p]=n.shape,f=s.data.get(n.dataId).values;for(let d=0;d<a;d++){let y=d*u*l*p;for(let _=0;_<l;_++){let v=_*(u*p);for(let C=0;C<u;C++){let N=C*p;for(let A=0;A<p;A++){let P=[a,_,C,A][2],L=Math.round(u-P),Z=y+v+N+A,K=f[Z];if(L>=0&&L<u){let et=L*p,it=y+v+et+A;K=f[it]}o[Z]=K}}}}return{dataId:s.write(o,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var AV=$e((r,t)=>Math.floor(r/t)),$V=Me(So,AV,null,"int32"),hT={kernelName:So,backendName:"cpu",kernelFunc:$V};function DV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o,bias:a,preluActivationWeights:l}=t,{strides:u,pad:p,dataFormat:f,dilations:m,dimRoundingMode:d,activation:y,leakyreluAlpha:_}=n,v=m_({inputs:{x:s,filter:o},backend:e,attrs:{strides:u,pad:p,dataFormat:f,dilations:m,dimRoundingMode:d}});if(a){let C=v;v=di({inputs:{a:v,b:a},backend:e}),e.disposeIntermediateTensorInfo(C)}if(y){let C=v;v=Tc(e,v,y,l,_),e.disposeIntermediateTensorInfo(C)}return v}var mT={kernelName:al,backendName:"cpu",kernelFunc:DV};function RV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o,bias:a,preluActivationWeights:l}=t,{strides:u,pad:p,dataFormat:f,dilations:m,dimRoundingMode:d,activation:y,leakyreluAlpha:_}=n,v=d_({inputs:{x:s,filter:o},backend:e,attrs:{strides:u,pad:p,dataFormat:f,dilations:m,dimRoundingMode:d}});if(a){let C=v;v=di({inputs:{a:v,b:a},backend:e}),e.disposeIntermediateTensorInfo(C)}if(y){let C=v;v=Tc(e,v,y,l,_),e.disposeIntermediateTensorInfo(C)}return v}var dT={kernelName:ll,backendName:"cpu",kernelFunc:RV};function FV(r){let{inputs:t,backend:e}=r,{params:n,indices:s}=t,o=E.sizeFromShape(n.shape),a=s.shape,l=a[a.length-1],[u,p,f,m]=H.prepareAndValidate(n,s);if(p===0)return e.makeTensorInfo(u,n.dtype,[]);let d=ae([p,f],n.dtype),y=e.data.get(s.dataId).values,_=e.data.get(n.dataId).values;for(let v=0;v<p;v++){let C=[],N=0;for(let A=0;A<l;A++){let B=y[v*l+A];N+=B*m[A],C.push(B)}if(N<0||N>=o/f)throw new Error(`Invalid indices: ${C} does not index into ${n.shape}`);for(let A=0;A<f;A++)d.values[v*f+A]=_[N*f+A]}return e.makeTensorInfo(u,d.dtype,d.values)}var gT={kernelName:th,backendName:"cpu",kernelFunc:FV};function OV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,indices:o}=t,{axis:a,batchDims:l}=n;$t([s,o],"gatherV2");let u=l;l==null&&(u=0);let p=E.sizeFromShape(o.shape),f=E.parseAxisParam(a,s.shape)[0],m=H.segment_util.collectGatherOpShapeInfo(s,o,f,u),d=Oe({inputs:{x:s},backend:e,attrs:{shape:[m.batchSize,m.outerSize,m.dimSize,m.sliceSize]}}),y=Oe({inputs:{x:o},backend:e,attrs:{shape:[m.batchSize,p/m.batchSize]}}),_=[m.batchSize,m.outerSize,p/m.batchSize,m.sliceSize],v=e.bufferSync(y),C=e.bufferSync(d),N=Qy(C,v,_);return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(y),e.makeTensorInfo(m.outputShape,N.dtype,N.values)}var xT={kernelName:Vi,backendName:"cpu",kernelFunc:OV};var PV=$e((r,t)=>r>=t?1:0),LV=Me(Io,PV,null,"bool"),yT={kernelName:Io,backendName:"cpu",kernelFunc:LV};function zV(r){let{inputs:t,backend:e}=r,{input:n}=t,s=E.sizeFromShape(n.shape),o=n.shape[n.shape.length-1],a=s/o,l=Oe({inputs:{x:n},backend:e,attrs:{shape:[a,o]}}),u=Wd(l,!0,e),p=Oe({inputs:{x:u},backend:e,attrs:{shape:n.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(u),p}var _T={kernelName:_u,backendName:"cpu",kernelFunc:zV};var MV=he(No,r=>Number.isFinite(r)?1:0,"bool"),bT={kernelName:No,backendName:"cpu",kernelFunc:MV};var BV=he(To,r=>Math.abs(r)===Infinity?1:0,"bool"),vT={kernelName:To,backendName:"cpu",kernelFunc:BV};var VV=he(Eo,r=>Number.isNaN(r)?1:0,"bool"),wT={kernelName:Eo,backendName:"cpu",kernelFunc:VV};var GV=$e((r,t)=>r<=t?1:0),WV=Me(el,GV,null,"bool"),CT={kernelName:el,backendName:"cpu",kernelFunc:WV};function UV(r){let{backend:t,attrs:e}=r,{start:n,stop:s,num:o}=e,a=t_(n,s,o);return t.makeTensorInfo([a.length],"float32",a)}var kT={kernelName:eh,backendName:"cpu",kernelFunc:UV};var jV=he($o,r=>Math.log1p(r)),ST={kernelName:$o,backendName:"cpu",kernelFunc:jV};var qV=$e((r,t)=>r&&t),HV=Me(rl,qV,null,"bool"),IT={kernelName:rl,backendName:"cpu",kernelFunc:HV};var KV=he(nl,r=>r?0:1,"bool"),NT={kernelName:nl,backendName:"cpu",kernelFunc:KV};var XV=$e((r,t)=>r||t),YV=Me(sl,XV,null,"bool"),TT={kernelName:sl,backendName:"cpu",kernelFunc:YV};function ZV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{depthRadius:o,bias:a,alpha:l,beta:u}=n;$t(s,"LRN");let p=s.shape[3],f=p-1,m=e.data.get(s.dataId).values,d=E.sizeFromShape(s.shape),y=new Float32Array(d);function _(v){let C=v%p,N=v-C+Math.max(0,C-o),A=v-C+Math.min(C+o,f),B=0;for(;N<=A;N++){let P=m[N];B+=P*P}return B}for(let v=0;v<d;v++){let C=_(v),N=m[v]*Math.pow(a+l*C,-u);y[v]=N}return e.makeTensorInfo(s.shape,s.dtype,y)}var ET={kernelName:Ui,backendName:"cpu",kernelFunc:ZV};function JV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,y:o,dy:a}=t,{depthRadius:l,bias:u,alpha:p,beta:f}=n;$t(a,"LRNGrad");let m=E.sizeFromShape(a.shape),d=a.shape[3],y=e.data.get(a.dataId).values,_=e.data.get(s.dataId).values,v=e.data.get(o.dataId).values,C=new Float32Array(m),N=m;for(let A=0;A<N;A++){let B=A%d,P=A-B+Math.max(0,B-l),L=A-B+Math.min(d,B+l+1),Z=0;for(let K=P;K<L;K++)Z+=Math.pow(_[K],2);Z=p*Z+u;for(let K=P;K<L;K++){let et=-2*p*f*_[K]*v[A]/Z;A===K&&(et+=Math.pow(Z,-f)),et*=y[A],C[K]+=et}}return e.makeTensorInfo(a.shape,s.dtype,C)}var AT={kernelName:vu,backendName:"cpu",kernelFunc:JV};function y_(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{reductionIndices:o,keepDims:a}=n,l=e,u=s.shape,p=u.length,f=E.parseAxisParam(o,u),m=f,d=H.getAxesPermutation(m,p),y=l.data.get(s.dataId).values;if(d!=null){let P=new Array(p);for(let L=0;L<P.length;L++)P[L]=u[d[L]];y=sf(y,u,s.dtype,d,P),m=H.getInnerMostAxes(m.length,p),u=P}$t(s,"max"),H.assertAxesAreInnerMostDims("max",m,p);let[_,v]=H.computeOutAndReduceShapes(u,m),C=E.sizeFromShape(v),N=e_(y,C,_,s.dtype),A=l.write(N,_,s.dtype),B=_;return a&&(B=H.expandShapeToKeepDim(_,f)),{dataId:A,shape:B,dtype:s.dtype}}var $T={kernelName:ji,backendName:"cpu",kernelFunc:y_};function QV(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t;$t(s,"maxPool");let{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=n,p=1;E.assert(H.eitherStridesOrDilationsAreOne(a,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let f=H.computePool2DInfo(s.shape,o,a,p,l,u),m;if(f.filterWidth===1&&f.filterHeight===1&&E.arraysEqual(f.inShape,f.outShape))m=Qr({inputs:{x:s},backend:e});else{let d=e.data.get(s.dataId).values,y=E.computeStrides(s.shape),_=Ec(d,s.shape,s.dtype,y,f,"max");m=e.makeTensorInfo(f.outShape,s.dtype,_.values)}return m}var DT={kernelName:qi,backendName:"cpu",kernelFunc:QV};function tG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:u,dataFormat:p}=n;$t(s,"maxPool3d");let f=H.computePool3DInfo(s.shape,o,a,1,l,u,p),m=e.data.get(s.dataId).values,d=Gd(m,s.shape,s.dtype,E.computeStrides(s.shape),f,"max");return e.makeTensorInfo(d.shape,"float32",d.values)}var RT={kernelName:Hi,backendName:"cpu",kernelFunc:tG};function eG(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,input:o}=t,{filterSize:a,strides:l,pad:u,dimRoundingMode:p}=n;$t([s,o],"maxPool3DGrad");let f=H.computePool3DInfo(o.shape,a,l,1,u,p),m=e.bufferSync(o),d=EN(m,f),y=f.strideDepth,_=f.strideHeight,v=f.strideWidth,C=f.dilationDepth,N=f.dilationHeight,A=f.dilationWidth,B=f.effectiveFilterDepth,P=f.effectiveFilterHeight,L=f.effectiveFilterWidth,Z=B-1-f.padInfo.front,K=L-1-f.padInfo.left,et=P-1-f.padInfo.top,it=ae(o.shape,"float32"),xt=e.bufferSync(s);for(let wt=0;wt<f.batchSize;++wt)for(let St=0;St<f.inChannels;++St)for(let yt=0;yt<f.inDepth;++yt)for(let Nt=0;Nt<f.inHeight;++Nt)for(let ht=0;ht<f.inWidth;++ht){let It=yt-Z,Ft=Nt-et,Ct=ht-K,Dt=0;for(let zt=0;zt<B;zt+=C){let Mt=(It+zt)/y;if(!(Mt<0||Mt>=f.outDepth||Math.floor(Mt)!==Mt))for(let jt=0;jt<P;jt+=N){let qt=(Ft+jt)/_;if(!(qt<0||qt>=f.outHeight||Math.floor(qt)!==qt))for(let Bt=0;Bt<L;Bt+=A){let Ht=(Ct+Bt)/v;if(Ht<0||Ht>=f.outWidth||Math.floor(Ht)!==Ht)continue;let Zt=B*P*L-1-d.get(wt,Mt,qt,Ht,St),ne=zt*P*L+jt*L+Bt,Qt=Zt===ne?1:0;if(Qt===0)continue;Dt+=xt.get(wt,Mt,qt,Ht,St)*Qt}}}it.set(Dt,wt,yt,Nt,ht,St)}return e.makeTensorInfo(it.shape,it.dtype,it.values)}var FT={kernelName:Cu,backendName:"cpu",kernelFunc:eG};function rG(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,input:o,output:a}=t,l=o;$t([o,a],"maxPoolGrad");let{filterSize:u,strides:p,pad:f,dimRoundingMode:m}=n,d=H.computePool2DInfo(l.shape,u,p,1,f,m),y=e.data.get(l.dataId).values,_=ae(d.outShape,l.dtype,Vd(y,l.shape,l.dtype,d).values),v=d.strideHeight,C=d.strideWidth,N=d.dilationHeight,A=d.dilationWidth,B=d.effectiveFilterHeight,P=d.effectiveFilterWidth,L=P-1-d.padInfo.left,Z=B-1-d.padInfo.top,K=ae(l.shape,"float32"),et=e.data.get(s.dataId).values,it=ae(s.shape,"float32",et);for(let xt=0;xt<d.batchSize;++xt)for(let wt=0;wt<d.inChannels;++wt)for(let St=0;St<d.inHeight;++St)for(let yt=0;yt<d.inWidth;++yt){let Nt=St-Z,ht=yt-L,It=0;for(let Ft=0;Ft<B;Ft+=N){let Ct=(Nt+Ft)/v;if(!(Ct<0||Ct>=d.outHeight||Math.floor(Ct)!==Ct))for(let Dt=0;Dt<P;Dt+=A){let zt=(ht+Dt)/C;if(zt<0||zt>=d.outWidth||Math.floor(zt)!==zt)continue;let Mt=B*P-1-_.get(xt,Ct,zt,wt),jt=Ft*P+Dt,qt=Mt===jt?1:0;if(qt===0)continue;It+=it.get(xt,Ct,zt,wt)*qt}}K.set(It,xt,St,yt,wt)}return e.makeTensorInfo(K.shape,K.dtype,K.values)}var OT={kernelName:wu,backendName:"cpu",kernelFunc:rG};function PT(r,t,e,n,s){let o=E.computeStrides(t),a=Ec(r,t,e,o,s,"max"),l=Vd(r,t,e,s,!0,n);return[a.values,l.values]}var LT={kernelName:rh,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:s,strides:o,pad:a,includeBatchInIndex:l}=t,u=e;$t(n,"MaxPoolWithArgmax");let p=u.data.get(n.dataId).values,f=H.computePool2DInfo(n.shape,s,o,[1,1],a),[m,d]=PT(p,n.shape,n.dtype,l,f),y=u.write(m,f.outShape,n.dtype),_=u.write(d,f.outShape,n.dtype);return[{dataId:y,shape:f.outShape,dtype:n.dtype},{dataId:_,shape:f.outShape,dtype:"int32"}]}};function Rl(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n;$t(s,"sum");let l;s.dtype==="bool"?l=ls({inputs:{x:s},backend:e,attrs:{dtype:"int32"}}):l=Qr({inputs:{x:s},backend:e});let u=l.shape.length,p=E.parseAxisParam(o,l.shape),f=H.getAxesPermutation(p,u),m=p,d=l;f!=null&&(d=Nr({inputs:{x:l},backend:e,attrs:{perm:f}}),m=H.getInnerMostAxes(m.length,u)),H.assertAxesAreInnerMostDims("sum",m,d.shape.length);let[y,_]=H.computeOutAndReduceShapes(d.shape,m),v=H.upcastType(d.dtype,"int32"),C=Ic(e,y,v),N=E.sizeFromShape(_),A=e.data.get(C.dataId).values,B=e.data.get(d.dataId).values;for(let P=0;P<A.length;++P){let L=P*N,Z=0;for(let K=0;K<N;++K)Z+=B[L+K];A[P]=Z}if(a){let P=H.expandShapeToKeepDim(C.shape,p),L=C;C=Oe({inputs:{x:C},backend:e,attrs:{shape:P}}),e.disposeIntermediateTensorInfo(L)}return e.disposeIntermediateTensorInfo(l),f!=null&&e.disposeIntermediateTensorInfo(d),C}var zT={kernelName:ua,backendName:"cpu",kernelFunc:Rl};function nG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n,l=E.parseAxisParam(o,s.shape),p=H.computeOutAndReduceShapes(s.shape,l)[1],f=E.sizeFromShape(p),m=[],d=e.makeTensorInfo([],"float32",new Float32Array([f]));m.push(d);let y=ls({inputs:{x:s},backend:e,attrs:{dtype:"float32"}});m.push(y);let _=af({inputs:{a:y,b:d},backend:e});m.push(_);let v=Rl({inputs:{x:_},backend:e,attrs:{axis:o,keepDims:a}});return m.forEach(C=>e.disposeIntermediateTensorInfo(C)),v}var MT={kernelName:Ki,backendName:"cpu",kernelFunc:nG};function sG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n;$t(s,"min");let l=E.parseAxisParam(o,s.shape),u=l,p=H.getAxesPermutation(u,s.shape.length),f=s;p!=null&&(f=Nr({inputs:{x:s},backend:e,attrs:{perm:p}}),u=H.getInnerMostAxes(u.length,s.shape.length)),H.assertAxesAreInnerMostDims("min",u,f.shape.length);let[m,d]=H.computeOutAndReduceShapes(f.shape,u),y=E.sizeFromShape(d),_=E.makeZerosTypedArray(E.sizeFromShape(m),f.dtype),v=e.data.get(f.dataId).values;for(let N=0;N<_.length;++N){let A=N*y,B=v[A];for(let P=0;P<y;++P){let L=v[A+P];L<B&&(B=L)}_[N]=B}p!=null&&e.disposeIntermediateTensorInfo(f);let C=e.makeTensorInfo(m,f.dtype,_);if(a){let N=H.expandShapeToKeepDim(m,l),A=Oe({inputs:{x:C},backend:e,attrs:{shape:N}});return e.disposeIntermediateTensorInfo(C),A}return C}var BT={kernelName:Xi,backendName:"cpu",kernelFunc:sG};function oG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{paddings:o,mode:a}=n;$t(s,"mirrorPad");let l=o.map((B,P)=>B[0]+s.shape[P]+B[1]),u=o.map(B=>B[0]),p=o.map((B,P)=>B[0]+s.shape[P]),f=a==="reflect"?0:1,m=e.data.get(s.dataId).values,d=s.shape.length,y=E.computeStrides(s.shape),_=E.sizeFromShape(l),v=l.length,C=E.computeStrides(l),N=E.getTypedArrayFromDType(s.dtype,_);for(let B=0;B<_;B++){let P=E.indexToLoc(B,v,C);for(let Z=0;Z<v;Z++)P[Z]<u[Z]?P[Z]=u[Z]*2-P[Z]-f:P[Z]>=p[Z]&&(P[Z]=(p[Z]-1)*2-P[Z]+f);P=P.map((Z,K)=>Z-u[K]);let L=E.locToIndex(P,d,y);N[B]=m[L]}return{dataId:e.write(N,l,s.dtype),shape:l,dtype:s.dtype}}var VT={kernelName:Yi,backendName:"cpu",kernelFunc:oG};var iG=$e((r,t)=>{let e=r%t;return r<0&&t<0||r>=0&&t>=0?e:(e+t)%t}),aG=Me(Fo,iG),GT={kernelName:Fo,backendName:"cpu",kernelFunc:aG};var UT=Wc(xp());function __(r){let{inputs:t,backend:e,attrs:n}=r,{logits:s}=t,{dim:o}=n,a=s.shape.length,l=o;if(l===-1&&(l=a-1),l!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${l}`);let u=E.parseAxisParam([l],s.shape),p=y_({inputs:{x:s},backend:e,attrs:{reductionIndices:u,keepDims:!1}}),f=H.expandShapeToKeepDim(p.shape,u),m=Oe({inputs:{x:p},backend:e,attrs:{shape:f}}),d=of({inputs:{a:s,b:m},backend:e}),y=Jy({inputs:{x:d},backend:e}),_=Rl({inputs:{x:y},backend:e,attrs:{axis:u,keepDims:!1}}),v=Oe({inputs:{x:_},backend:e,attrs:{shape:f}}),C=af({inputs:{a:y,b:v},backend:e});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(v),C}var WT={kernelName:fa,backendName:"cpu",kernelFunc:__};function lG(r){let{inputs:t,backend:e,attrs:n}=r,{logits:s}=t,{numSamples:o,seed:a,normalized:l}=n;$t(s,"multinomial");let u=l?s:__({inputs:{logits:s},backend:e,attrs:{dim:-1}}),p=u.shape[0],f=u.shape[1],m=e.data.get(u.dataId).values,d=[p,o],y=E.makeZerosTypedArray(E.sizeFromShape(d),"int32");for(let _=0;_<p;++_){let v=_*f,C=new Float32Array(f-1);C[0]=m[v];for(let B=1;B<C.length;++B)C[B]=C[B-1]+m[v+B];let N=UT.alea(a.toString()),A=_*o;for(let B=0;B<o;++B){let P=N();y[A+B]=C.length;for(let L=0;L<C.length;L++)if(P<C[L]){y[A+B]=L;break}}}return l||e.disposeIntermediateTensorInfo(u),e.makeTensorInfo(d,"int32",y)}var jT={kernelName:nh,backendName:"cpu",kernelFunc:lG};var uG=sn.nonMaxSuppressionV3Impl;function cG(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=n;$t(s,"NonMaxSuppression");let p=e.data.get(s.dataId).values,f=e.data.get(o.dataId).values,{selectedIndices:m}=uG(p,f,a,l,u);return e.makeTensorInfo([m.length],"int32",new Int32Array(m))}var qT={kernelName:sh,backendName:"cpu",kernelFunc:cG};var pG=sn.nonMaxSuppressionV4Impl;function fG(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u,padToMaxOutputSize:p}=n;$t(s,"NonMaxSuppressionPadded");let f=e.data.get(s.dataId).values,m=e.data.get(o.dataId).values,{selectedIndices:d,validOutputs:y}=pG(f,m,a,l,u,p);return[e.makeTensorInfo([d.length],"int32",new Int32Array(d)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}var HT={kernelName:oh,backendName:"cpu",kernelFunc:fG};var hG=sn.nonMaxSuppressionV5Impl;function mG(r){let{inputs:t,backend:e,attrs:n}=r,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:p}=n;$t(s,"NonMaxSuppressionWithScore");let f=e.data.get(s.dataId).values,m=e.data.get(o.dataId).values,d=a,y=l,_=u,v=p,{selectedIndices:C,selectedScores:N}=hG(f,m,d,y,_,v);return[e.makeTensorInfo([C.length],"int32",new Int32Array(C)),e.makeTensorInfo([N.length],"float32",new Float32Array(N))]}var KT={kernelName:ih,backendName:"cpu",kernelFunc:mG};function dG(r){let{inputs:t,backend:e,attrs:n}=r,{indices:s}=t,{depth:o,onValue:a,offValue:l}=n;$t(s,"oneHot");let u=E.sizeFromShape(s.shape),p=new Float32Array(u*o);p.fill(l);let f=e.data.get(s.dataId).values;for(let m=0;m<u;++m)f[m]>=0&&f[m]<o&&(p[m*o+f[m]]=a);return e.makeTensorInfo([...s.shape,o],"int32",p)}var XT={kernelName:Qi,backendName:"cpu",kernelFunc:dG};function cf(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(n.dtype==="complex64"){let s=as({inputs:{input:n},backend:e}),o=cf({inputs:{x:s},backend:e}),a=eo({inputs:{input:n},backend:e}),l=cf({inputs:{x:a},backend:e}),u=$r({inputs:{real:o,imag:l},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}else return uf({backend:e,attrs:{shape:n.shape,value:0,dtype:n.dtype}})}var YT={kernelName:ga,backendName:"cpu",kernelFunc:cf};function ZT(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(n.dtype==="complex64"){let s=as({inputs:{input:n},backend:e}),o=ZT({inputs:{x:s},backend:e}),a=eo({inputs:{input:n},backend:e}),l=cf({inputs:{x:a},backend:e}),u=$r({inputs:{real:o,imag:l},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}else return uf({backend:e,attrs:{shape:n.shape,value:1,dtype:n.dtype}})}var JT={kernelName:Ji,backendName:"cpu",kernelFunc:ZT};function b_(r){let{inputs:t,backend:e,attrs:n}=r,{axis:s}=n;if(t.length===1)return Ac({inputs:{input:t[0]},backend:e,attrs:{dim:s}});let o=t[0].shape,a=t[0].dtype;t.forEach(f=>{E.assertShapesMatch(o,f.shape,"All tensors passed to stack must have matching shapes"),E.assert(a===f.dtype,()=>"All tensors passed to stack must have matching dtypes")});let l=[],u=t.map(f=>{let m=Ac({inputs:{input:f},backend:e,attrs:{dim:s}});return l.push(m),m}),p=Ra({inputs:u,backend:e,attrs:{axis:s}});return l.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}var QT={kernelName:ta,backendName:"cpu",kernelFunc:b_};function gG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{paddings:o,constantValue:a}=n;$t(s,"pad");let l=o.map((A,B)=>A[0]+s.shape[B]+A[1]),u=o.map(A=>A[0]),p=e.data.get(s.dataId).values,f=E.sizeFromShape(s.shape),m=s.shape.length,d=E.computeStrides(s.shape),y=E.sizeFromShape(l),_=l.length,v=E.computeStrides(l),C=E.getTypedArrayFromDType(s.dtype,y);a!==0&&C.fill(a);for(let A=0;A<f;A++){let P=E.indexToLoc(A,m,d).map((Z,K)=>Z+u[K]),L=E.locToIndex(P,_,v);C[L]=p[A]}return{dataId:e.write(C,l,s.dtype),shape:l,dtype:s.dtype}}var Ud={kernelName:ea,backendName:"cpu",kernelFunc:gG};var xG=$e((r,t)=>Math.pow(r,t)),yG=Me(Po,xG),t2={kernelName:Po,backendName:"cpu",kernelFunc:yG};function _G(r){let{backend:t,attrs:e}=r,{start:n,stop:s,dtype:o,step:a}=e,l=r_(n,s,a,o);return t.makeTensorInfo([l.length],o,l)}var e2={kernelName:Su,backendName:"cpu",kernelFunc:_G};var bG=he(Lo,r=>1/r),r2={kernelName:Lo,backendName:"cpu",kernelFunc:bG};function vG(r){let{inputs:t,backend:e,attrs:n}=r,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:l}=n;$t(s,"resizeBilinear");let u=E.computeStrides(s.shape),[p,f]=l,[m,d,y,_]=s.shape,v=e.data.get(s.dataId).values,C=new Float32Array(E.sizeFromShape([m,p,f,_])),N=[o&&p>1?d-1:d,o&&f>1?y-1:y],A=[o&&p>1?p-1:p,o&&f>1?f-1:f],B=0,P=N[0]/A[0],L=N[1]/A[1];for(let Z=0;Z<m;Z++)for(let K=0;K<p;K++){let et;a?et=P*(K+.5)-.5:et=P*K;let it=Math.max(0,Math.floor(et)),xt=et-it,wt=Math.min(d-1,Math.ceil(et)),St=Z*u[0]+it*u[1],yt=Z*u[0]+wt*u[1];for(let Nt=0;Nt<f;Nt++){let ht;a?ht=L*(Nt+.5)-.5:ht=L*Nt;let It=Math.max(0,Math.floor(ht)),Ft=ht-It,Ct=Math.min(y-1,Math.ceil(ht)),Dt=St+It*u[2],zt=yt+It*u[2],Mt=St+Ct*u[2],jt=yt+Ct*u[2];for(let qt=0;qt<_;qt++){let Bt=v[Dt+qt],Ht=v[zt+qt],Zt=v[Mt+qt],ne=v[jt+qt],Qt=Bt+(Zt-Bt)*Ft,te=Ht+(ne-Ht)*Ft,oe=Qt+(te-Qt)*xt;C[B++]=oe}}}return e.makeTensorInfo([m,p,f,_],"float32",C)}var n2={kernelName:oa,backendName:"cpu",kernelFunc:vG};function wG(r){let{inputs:t,backend:e,attrs:n}=r,{images:s,dy:o}=t,{alignCorners:a}=n;$t([o,s],"resizeBilinearGrad");let l=E.computeStrides(s.shape),[u,p,f,m]=s.shape,[,d,y]=o.shape,_=new Float32Array(u*p*f*m),v=[a&&d>1?p-1:p,a&&y>1?f-1:f],C=[a&&d>1?d-1:d,a&&y>1?y-1:y],N=v[0]/C[0],A=v[1]/C[1],B=e.data.get(o.dataId).values,P=0;for(let L=0;L<u;L++){let Z=L*l[0];for(let K=0;K<d;K++){let et=K*N,it=Math.floor(et),xt=Math.min(Math.ceil(et),p-1),wt=Z+it*l[1],St=Z+xt*l[1],yt=et-it,Nt=1-yt;for(let ht=0;ht<y;ht++){let It=ht*A,Ft=Math.floor(It),Ct=Math.min(Math.ceil(It),f-1),Dt=It-Ft,zt=1-Dt,Mt=wt+Ft*l[2],jt=wt+Ct*l[2],qt=St+Ft*l[2],Bt=St+Ct*l[2],Ht=Nt*zt,Zt=Nt*Dt,ne=yt*zt,Qt=yt*Dt;for(let te=0;te<m;te++){let oe=B[P++];_[Mt+te]+=oe*Ht,_[jt+te]+=oe*Zt,_[qt+te]+=oe*ne,_[Bt+te]+=oe*Qt}}}}return e.makeTensorInfo([u,f,p,m],"float32",_)}var s2={kernelName:Tu,backendName:"cpu",kernelFunc:wG};function CG(r){let{inputs:t,backend:e,attrs:n}=r,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:l}=n;$t(s,"resizeNearestNeighbor");let u=E.computeStrides(s.shape),[p,f]=l,[m,d,y,_]=s.shape,v=e.data.get(s.dataId).values,C=new Float32Array(m*p*f*_),N=[o&&p>1?d-1:d,o&&f>1?y-1:y],A=[o&&p>1?p-1:p,o&&f>1?f-1:f],B=N[0]/A[0],P=N[1]/A[1],L=0;for(let Z=0;Z<m;Z++){let K=Z*u[0];for(let et=0;et<p;et++){let it=a?B*(et+.5):B*et,xt=Math.min(d-1,o?Math.round(it):Math.floor(it));a&&(xt=Math.max(0,xt));let wt=K+xt*u[1];for(let St=0;St<f;St++){let yt=a?P*(St+.5):P*St,Nt=Math.min(y-1,o?Math.round(yt):Math.floor(yt));a&&(Nt=Math.max(0,Nt));let ht=wt+Nt*u[2];for(let It=0;It<_;It++){let Ft=v[ht+It];C[L++]=Ft}}}}return e.makeTensorInfo([m,p,f,_],s.dtype,C)}var o2={kernelName:sa,backendName:"cpu",kernelFunc:CG};function kG(r){let{inputs:t,backend:e,attrs:n}=r,{images:s,dy:o}=t,{alignCorners:a}=n;$t([o,s],"resizeNearestNeighborGrad");let l=E.computeStrides(s.shape),u=E.computeStrides(o.shape),[p,f,m,d]=s.shape,[,y,_]=o.shape,v=new Float32Array(p*f*m*d),C=e.data.get(o.dataId).values,N=[a&&y>1?f-1:f,a&&_>1?m-1:m],A=[a&&y>1?y-1:y,a&&_>1?_-1:_],B=N[0]/A[0],P=N[1]/A[1],L=1/B,Z=1/P,K=Math.ceil(L)*2+2,et=Math.ceil(Z)*2+2;for(let it=0;it<p;it++){let xt=it*l[0];for(let wt=0;wt<f;wt++){let St=xt+wt*l[1],yt=Math.floor(wt*L),Nt=Math.floor(yt-K/2);for(let ht=0;ht<m;ht++){let It=St+ht*l[2],Ft=Math.floor(ht*Z),Ct=Math.floor(Ft-et/2);for(let Dt=0;Dt<d;Dt++){let zt=0;for(let Mt=0;Mt<K;Mt++){let jt=Mt+Nt;if(jt<0||jt>=y)continue;let qt=xt+jt*u[1],Bt=jt*B,Ht=Math.min(f-1,a?Math.round(Bt):Math.floor(Bt));if(wt===Ht)for(let Zt=0;Zt<et;Zt++){let ne=Zt+Ct;if(ne<0||ne>=_)continue;let Qt=qt+ne*u[2],te=ne*P,oe=Math.min(m-1,a?Math.round(te):Math.floor(te));ht===oe&&(zt+=C[Qt+Dt])}}v[It+Dt]=zt}}}}return e.makeTensorInfo(s.shape,s.dtype,v)}var i2={kernelName:Nu,backendName:"cpu",kernelFunc:kG};function SG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{dims:o}=n;$t(s,"reverse");let a=s.shape.length,l=E.parseAxisParam(o,s.shape);if(a===0)return Qr({inputs:{x:s},backend:e});let u=new er(s.shape,s.dtype),p=e.bufferSync(s);for(let f=0;f<u.size;f++){let m=u.indexToLoc(f),d=m.slice();l.forEach(y=>d[y]=s.shape[y]-1-d[y]),u.set(p.get(...d),...m)}return e.makeTensorInfo(u.shape,u.dtype,u.values)}var a2={kernelName:ia,backendName:"cpu",kernelFunc:SG};var l2={kernelName:uh,backendName:"cpu",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:s,fillValue:o,center:a}=t,l=e,u=E.getTypedArrayFromDType(n.dtype,E.sizeFromShape(n.shape)),[p,f,m,d]=n.shape,[y,_]=H.getImageCenter(a,f,m),v=255,C=Math.sin(s),N=Math.cos(s),A=l.data.get(n.dataId).values;for(let P=0;P<p;P++){let L=P*m*f*d;for(let Z=0;Z<f;Z++){let K=Z*(m*d);for(let et=0;et<m;et++){let it=et*d;for(let xt=0;xt<d;xt++){let wt=[p,Z,et,xt],St=wt[2],yt=wt[1],Nt=(St-y)*N-(yt-_)*C,ht=(St-y)*C+(yt-_)*N;Nt=Math.round(Nt+y),ht=Math.round(ht+_);let It=o;if(typeof o!="number"&&(xt===3?It=v:It=o[xt]),Nt>=0&&Nt<m&&ht>=0&&ht<f){let Ct=ht*(m*d),Dt=Nt*d,zt=L+Ct+Dt+xt;It=A[zt]}let Ft=L+K+it+xt;u[Ft]=It}}}}return{dataId:l.write(u,n.shape,n.dtype),shape:n.shape,dtype:n.dtype}}};var IG=he(Bo,r=>{let t=Math.floor(r);return r-t<.5?Math.floor(r):r-t>.5?Math.ceil(r):t%2==0?t:t+1}),u2={kernelName:Bo,backendName:"cpu",kernelFunc:IG};function jd(r,t,e,n,s,o,a,l,u,p){let f=[n/s,s],m=r.values,d=t.values;if(n===0)return ae(e,t.dtype);let y=ae(f,t.dtype);y.values.fill(u);for(let _=0;_<o;_++){let v=[],C=0;for(let N=0;N<a;N++){let A=m[_*a+N];v.push(A),C+=A*l[N]}if(C<0||C>=n/s)throw new Error(`Invalid indices: ${v} does not index into ${e}`);for(let N=0;N<s;N++)p?y.values[C*s+N]+=d[_*s+N]:y.values[C*s+N]=t.rank===0?d[0]:d[_*s+N]}return y}function NG(r){let{inputs:t,backend:e,attrs:n}=r,{indices:s,updates:o}=t,{shape:a}=n,{sliceRank:l,numUpdates:u,sliceSize:p,strides:f,outputSize:m}=H.calculateShapes(o,s,a),d=!0,y=e.bufferSync(s),_=e.bufferSync(o),v=jd(y,_,a,m,p,u,l,f,0,d);return e.makeTensorInfo(a,v.dtype,v.values)}var c2={kernelName:ah,backendName:"cpu",kernelFunc:NG};function TG(r){let{inputs:t,backend:e}=r,{condition:n,t:s,e:o}=t;$t([n,s,o],"select");let a=n.shape.length,l=e.data.get(n.dataId).values,u=e.data.get(s.dataId).values,p=e.data.get(o.dataId).values,f=Br(s.dtype,o.dtype),m=E.makeZerosTypedArray(E.sizeFromShape(s.shape),f),d=0,y=a===0||a>1||s.shape.length===1?1:E.sizeFromShape(s.shape.slice(1));for(let _=0;_<l.length;_++)for(let v=0;v<y;v++)l[_]===1?m[d++]=u[_]:m[d++]=p[_];return e.makeTensorInfo(s.shape,f,m)}var p2={kernelName:aa,backendName:"cpu",kernelFunc:TG};var EG=H.SELU_SCALEALPHA,AG=H.SELU_SCALE,$G=he(Go,r=>r>=0?AG*r:EG*(Math.exp(r)-1)),f2={kernelName:Go,backendName:"cpu",kernelFunc:$G};var DG=he(qo,r=>1/(1+Math.exp(-r))),h2={kernelName:qo,backendName:"cpu",kernelFunc:DG};var RG=he(jo,r=>r<0?-1:r>0?1:0),m2={kernelName:jo,backendName:"cpu",kernelFunc:RG};var FG=he(Wo,r=>Math.sin(r)),d2={kernelName:Wo,backendName:"cpu",kernelFunc:FG};var OG=he(Uo,r=>Math.sinh(r)),g2={kernelName:Uo,backendName:"cpu",kernelFunc:OG};var PG=11920928955078125e-23,x2=Math.log(PG)+2,LG=he(Ho,r=>{let t=r>-x2,e=r<x2,n=Math.exp(r),s;return e?s=n:t?s=r:s=Math.log(1+n),s}),y2={kernelName:Ho,backendName:"cpu",kernelFunc:LG};function zG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{blockShape:o,paddings:a}=n;$t([s],"spaceToBatchND");let l=E.sizeFromShape(o),u=[[0,0]];u.push(...a);for(let Z=1+o.length;Z<s.shape.length;++Z)u.push([0,0]);let p=Ud.kernelFunc({inputs:{x:s},backend:e,attrs:{paddings:u,constantValue:0}}),f=H.getReshaped(p.shape,o,l,!1),m=H.getPermuted(f.length,o.length,!1),d=H.getReshapedPermuted(p.shape,o,l,!1),v=Oe({inputs:{x:p},backend:e,attrs:{shape:f}}),A=Nr({inputs:{x:v},backend:e,attrs:{perm:m}}),L=Oe({inputs:{x:A},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(A),L}var _2={kernelName:ca,backendName:"cpu",kernelFunc:zG};function MG(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:s,sparseValues:o,defaultValue:a}=t,{outputShape:l}=n,{sliceRank:u,numUpdates:p,sliceSize:f,strides:m,outputSize:d}=H.calculateShapes(o,s,l),y=!1,_=e.bufferSync(s),v=e.bufferSync(o),C=e.data.get(a.dataId).values[0],N=jd(_,v,l,d,f,p,u,m,C,y);return e.makeTensorInfo(l,N.dtype,N.values)}var b2={kernelName:lh,backendName:"cpu",kernelFunc:MG};function BG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{numOrSizeSplits:o,axis:a}=n,l=E.parseAxisParam(a,s.shape)[0],u=H.prepareSplitSize(s,o,l),p=new Array(s.shape.length).fill(0),f=s.shape.slice();return u.map(m=>{let d=[...f];d[l]=m;let y=ps({inputs:{x:s},backend:e,attrs:{begin:p,size:d}});return p[l]+=m,y})}var v2={kernelName:pa,backendName:"cpu",kernelFunc:BG};var VG=he(Ko,r=>Math.sqrt(r)),w2={kernelName:Ko,backendName:"cpu",kernelFunc:VG};var C2={kernelName:Eu,backendName:"cpu",kernelFunc:({inputs:r,backend:t})=>{let{x:e}=r,n=t;$t(e,"square");let s=n.data.get(e.dataId).values,o=new Float32Array(s.length);for(let l=0;l<s.length;++l){let u=s[l];o[l]=u*u}return{dataId:n.write(o,e.shape,e.dtype),shape:e.shape,dtype:e.dtype}}};var GG=he(Qo,(r,t)=>{let e=t;return isNaN(r)?NaN:r>0?1:e.alpha}),k2={kernelName:Qo,backendName:"cpu",kernelFunc:GG};function WG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{begin:o,end:a,strides:l,beginMask:u,endMask:p,ellipsisMask:f,newAxisMask:m,shrinkAxisMask:d}=n;$t(s,"stridedSlice");let{nonStrided:y,$begin:_,$strides:v,size:C,newShape:N,outShape:A}=pn.sliceInfo(s.shape,o,a,l,u,p,f,m,d),B=Oe({inputs:{x:s},backend:e,attrs:{shape:N}}),P;if(y){let Z=ps({inputs:{x:B},backend:e,attrs:{begin:_,size:C}});P=Oe({inputs:{x:Z},backend:e,attrs:{shape:A}}),e.disposeIntermediateTensorInfo(Z)}else if(A.some(Z=>Z===0))P=e.makeTensorInfo(A,s.dtype,[]);else{let Z=e.bufferSync(B),K=n_(A,Z,v,_);P=e.makeTensorInfo(K.shape,K.dtype,K.values)}let L=Oe({inputs:{x:P},backend:e,attrs:{shape:A}});return e.disposeIntermediateTensorInfo(B),e.disposeIntermediateTensorInfo(P),L}var S2={kernelName:Au,backendName:"cpu",kernelFunc:WG};var UG=he(Zo,r=>Math.tan(r)),I2={kernelName:Zo,backendName:"cpu",kernelFunc:UG};var jG=he(Jo,r=>Math.tanh(r)),N2={kernelName:Jo,backendName:"cpu",kernelFunc:jG};function qG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{reps:o}=n;$t(s,"tile");let a=s_(e.bufferSync(s),o);return e.makeTensorInfo(a.shape,a.dtype,a.values)}var T2={kernelName:Us,backendName:"cpu",kernelFunc:qG};function HG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{k:o,sorted:a}=n;$t(s,"topk");let l=e.data.get(s.dataId).values,[u,p]=o_(l,s.shape,s.dtype,o,a);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(p.shape,p.dtype,p.values)]}var E2={kernelName:$u,backendName:"cpu",kernelFunc:HG};function KG(r){let{inputs:t,attrs:e,backend:n}=r,{axis:s}=e,{x:o}=t;$t(o,"unique");let a=n.data.get(o.dataId).values,{outputValues:l,outputShape:u,indices:p}=i_(a,s,o.shape,o.dtype);return[n.makeTensorInfo(u,o.dtype,l),n.makeTensorInfo([p.length],"int32",p)]}var A2={kernelName:Du,backendName:"cpu",kernelFunc:KG};function XG(r){let{inputs:t,backend:e,attrs:n}=r,{value:s}=t,{axis:o}=n;o<0&&(o+=s.shape.length);let a=s.shape.length,l=s.shape[o],u=new Array(a-1),p=0;for(let y=0;y<a;y++)y!==o&&(u[p++]=s.shape[y]);let f=new Array(a).fill(0),m=s.shape.slice();m[o]=1;let d=new Array(l);for(let y=0;y<d.length;y++){f[o]=y;let _=ps({inputs:{x:s},backend:e,attrs:{begin:f,size:m}});d[y]=Oe({inputs:{x:_},backend:e,attrs:{shape:u}}),e.disposeIntermediateTensorInfo(_)}return d}var $2={kernelName:ma,backendName:"cpu",kernelFunc:XG};function YG(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,segmentIds:o}=t,{numSegments:a}=n;$t(s,"unsortedSegmentSum");let l=s.shape.length,u=o.shape.length,p=[],f=[],m=l-u,d=o;for(let _=0;_<m;++_){let v=Ac({inputs:{input:d},backend:e,attrs:{dim:_+1}});d=v,f.push(v)}for(let _=0;_<a;++_){let v=E.createScalarValue(_,"int32"),C=e.makeTensorInfo([],"int32",v),N=g_({inputs:{a:C,b:d},backend:e}),A=ls({inputs:{x:N},backend:e,attrs:{dtype:"float32"}}),B=nf({inputs:{a:A,b:s},backend:e}),P=Rl({inputs:{x:B},backend:e,attrs:{axis:0,keepDims:!1}});p.push(P),f.push(C),f.push(N),f.push(A),f.push(B),f.push(P)}let y=b_({inputs:p,backend:e,attrs:{axis:0}});return f.forEach(_=>e.disposeIntermediateTensorInfo(_)),y}var D2={kernelName:da,backendName:"cpu",kernelFunc:YG};var ZG=[gN,wI,xN,yN,TI,_N,bN,vN,wN,CN,kN,SN,IN,NN,TN,AN,$N,DN,RN,dN,FN,ON,PN,II,AI,LN,CI,zN,BN,GN,WN,VN,jN,qN,UN,HN,KN,XN,YN,ZN,JN,QN,tT,eT,rT,nT,oT,sT,lf,uN,iT,aT,lT,DI,uT,FI,cT,pT,fT,PI,hT,mT,dT,gT,xT,zI,yT,kI,_T,MN,bT,vT,wT,cN,BI,CT,kT,GI,ST,IT,NT,TT,ET,AT,UI,DT,RT,FT,OT,LT,$T,MT,BT,qI,VT,GT,jT,HI,XI,qT,HT,KT,ZI,XT,JT,QT,Ud,t2,pN,tN,e2,SI,r2,fN,hN,mN,n2,s2,o2,i2,a2,l2,u2,rN,c2,p2,f2,h2,m2,d2,g2,sN,WT,y2,_2,b2,v2,w2,C2,iN,k2,S2,lN,zT,I2,N2,T2,E2,JI,A2,$2,D2,YT];for(let r of ZG)ph(r);var Fl={},v_={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function R2(r,t){Fl[r]=t}function qn(r){if(!(r in Fl)){let e=JG(r);if(e!==null)Fl[r]=e;else return console.log("Could not get context for WebGL version",r),null}let t=Fl[r];return t.isContextLost()?(delete Fl[r],qn(r)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),Fl[r])}function QG(r){if(typeof OffscreenCanvas!="undefined"&&r===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function JG(r){if(r!==1&&r!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");let t=QG(r);return t.addEventListener("webglcontextlost",e=>{e.preventDefault(),delete Fl[r]},!1),r===1?t.getContext("webgl",v_)||t.getContext("experimental-webgl",v_):t.getContext("webgl2",v_)}var Fa;(function(r){r[r.DENSE=0]="DENSE",r[r.SHARED_BATCH=1]="SHARED_BATCH"})(Fa||(Fa={}));var tn;(function(r){r[r.RENDER=0]="RENDER",r[r.UPLOAD=1]="UPLOAD",r[r.PIXELS=2]="PIXELS",r[r.DOWNLOAD=3]="DOWNLOAD"})(tn||(tn={}));var Wr;(function(r){r[r.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",r[r.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",r[r.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",r[r.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",r[r.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Wr||(Wr={}));function Ol(r,t){return[t,r]}function F2(r,t){return r*t}function Oa(r){let t=E.sizeFromShape(r),e=Math.ceil(t/4);return E.sizeToSquarishShape(e)}function ro(r,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(r/2))]}function O2(r,t){let[e,n]=ro(r,t);return e*n*4}function pf(r,t){let e=r,n,s,o,a,l,u,p,f,m,d;return vt().getNumber("WEBGL_VERSION")===2?(n=e.R32F,s=e.R16F,o=e.RGBA16F,a=e.RGBA32F,l=e.RED,p=4,f=1,m=e.HALF_FLOAT,d=e.FLOAT):(n=r.RGBA,s=r.RGBA,o=r.RGBA,a=e.RGBA,l=r.RGBA,p=4,f=4,m=t!=null?t.HALF_FLOAT_OES:null,d=r.FLOAT),u=r.RGBA,{internalFormatFloat:n,internalFormatHalfFloat:s,internalFormatPackedHalfFloat:o,internalFormatPackedFloat:a,textureFormatFloat:l,downloadTextureFormat:u,downloadUnpackNumChannels:p,defaultNumChannels:f,textureTypeHalfFloat:m,textureTypeFloat:d}}function ce(r,t){let e=t();return vt().getBool("DEBUG")&&tW(r),e}function tW(r){let t=r.getError();if(t!==r.NO_ERROR)throw new Error("WebGL Error: "+eW(r,t))}var rW=596e-10,nW=65504;function P2(r){return!!(vt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||r===0||rW<Math.abs(r)&&Math.abs(r)<nW)}function eW(r,t){switch(t){case r.NO_ERROR:return"NO_ERROR";case r.INVALID_ENUM:return"INVALID_ENUM";case r.INVALID_VALUE:return"INVALID_VALUE";case r.INVALID_OPERATION:return"INVALID_OPERATION";case r.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case r.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case r.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${t}`}}function ff(r,t){return gi(r,()=>r.getExtension(t),'Extension "'+t+'" not supported on this browser.')}function L2(r,t){let e=gi(r,()=>r.createShader(r.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ce(r,()=>r.shaderSource(e,t)),ce(r,()=>r.compileShader(e)),r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw console.log(r.getShaderInfoLog(e)),new Error("Failed to compile vertex shader.");return e}function z2(r,t){let e=gi(r,()=>r.createShader(r.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ce(r,()=>r.shaderSource(e,t)),ce(r,()=>r.compileShader(e)),r.getShaderParameter(e,r.COMPILE_STATUS)===!1)throw sW(t,r.getShaderInfoLog(e)),new Error("Failed to compile fragment shader.");return e}var oW=/ERROR: [0-9]+:([0-9]+):/g;function sW(r,t){let e=oW.exec(t);if(e==null){console.log(`Couldn't parse line number in error: ${t}`),console.log(r);return}let n=+e[1],s=r.split(`
`),o=s.length.toString().length+2,a=s.map((m,d)=>E.rightPad((d+1).toString(),o)+m),l=0;for(let m=0;m<a.length;m++)l=Math.max(a[m].length,l);let u=a.slice(0,n-1),p=a.slice(n-1,n),f=a.slice(n);console.log(u.join(`
`)),console.log(t.split(`
`)[0]),console.log(`%c ${E.rightPad(p[0],l)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(f.join(`
`))}function M2(r){return gi(r,()=>r.createProgram(),"Unable to create WebGLProgram.")}function B2(r,t){if(ce(r,()=>r.linkProgram(t)),r.getProgramParameter(t,r.LINK_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}function qd(r,t){if(ce(r,()=>r.validateProgram(t)),r.getProgramParameter(t,r.VALIDATE_STATUS)===!1)throw console.log(r.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function V2(r,t){let e=gi(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return ce(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),ce(r,()=>r.bufferData(r.ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function G2(r,t){let e=gi(r,()=>r.createBuffer(),"Unable to create WebGLBuffer");return ce(r,()=>r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e)),ce(r,()=>r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,r.STATIC_DRAW)),e}function W2(r){return gi(r,()=>r.createTexture(),"Unable to create WebGLTexture.")}function U2(r,t){let e=vt().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(r<=0||t<=0){let n=`[${r}x${t}]`;throw new Error("Requested texture size "+n+" is invalid.")}if(r>e||t>e){let n=`[${r}x${t}]`,s=`[${e}x${e}]`;throw new Error("Requested texture size "+n+" greater than WebGL maximum on this browser / GPU "+s+".")}}function j2(r){return gi(r,()=>r.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function w_(r,t,e,n,s,o,a){let l=r.getAttribLocation(t,e);return l===-1?!1:(ce(r,()=>r.bindBuffer(r.ARRAY_BUFFER,n)),ce(r,()=>r.vertexAttribPointer(l,s,r.FLOAT,!1,o,a)),ce(r,()=>r.enableVertexAttribArray(l)),!0)}function aW(r,t,e){iW(r,e),ce(r,()=>r.activeTexture(r.TEXTURE0+e)),ce(r,()=>r.bindTexture(r.TEXTURE_2D,t))}function q2(r,t,e){return gi(r,()=>r.getUniformLocation(t,e),'uniform "'+e+'" not present in program.')}function H2(r,t,e){return r.getUniformLocation(t,e)}function K2(r,t,e,n){ce(r,()=>aW(r,t,n)),ce(r,()=>r.uniform1i(e,n))}function Hd(r,t,e){ce(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,e)),ce(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,t,0))}function C_(r,t){ce(r,()=>r.bindFramebuffer(r.FRAMEBUFFER,t)),ce(r,()=>r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,null,0))}function hf(r){let t=r.checkFramebufferStatus(r.FRAMEBUFFER);if(t!==r.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+lW(r,t))}function lW(r,t){switch(t){case r.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case r.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case r.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${t}`}}function gi(r,t,e){let n=ce(r,()=>t());if(n==null)throw new Error(e);return n}function iW(r,t){let e=r.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,n=t+r.TEXTURE0;if(n<r.TEXTURE0||n>e){let s=`[gl.TEXTURE0, gl.TEXTURE${e}]`;throw new Error(`textureUnit must be in ${s}.`)}}function Pa(r,t=2){return E.sizeFromShape(r.slice(0,r.length-t))}function La(r){if(r.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[r.length>1?r[r.length-2]:1,r[r.length-1]]}function Kd(r){let t=[1,1,1];return r.length===0||r.length===1&&r[0]===1||(t=[Pa(r),...La(r)]),t}function X2(r,t=!1){let e=vt().getNumber("WEBGL_MAX_TEXTURE_SIZE");t&&(e=e*2,r=r.map((s,o)=>o>=r.length-2?E.nearestLargerEven(r[o]):r[o]),r.length===1&&(r=[2,r[0]])),r.length!==2&&(r=E.squeezeShape(r).newShape);let n=E.sizeFromShape(r);if(r.length<=1&&n<=e)return[1,n];if(r.length===2&&r[0]<=e&&r[1]<=e)return r;if(r.length===3&&r[0]*r[1]<=e&&r[2]<=e)return[r[0]*r[1],r[2]];if(r.length===3&&r[0]<=e&&r[1]*r[2]<=e)return[r[0],r[1]*r[2]];if(r.length===4&&r[0]*r[1]*r[2]<=e&&r[3]<=e)return[r[0]*r[1]*r[2],r[3]];if(r.length===4&&r[0]<=e&&r[1]*r[2]*r[3]<=e)return[r[0],r[1]*r[2]*r[3]];if(t){let s=Pa(r),o=2,a=2;return r.length&&([o,a]=La(r)),n=s*(o/2)*(a/2),E.sizeToSquarishShape(n).map(l=>l*2)}return E.sizeToSquarishShape(n)}function Xd(r){return r%2==0}function Pl(r,t){if(r=r.slice(-2),t=t.slice(-2),E.arraysEqual(r,t)||!r.length||!t.length||r[0]===0||r[1]===0||t[0]===0||t[1]===0)return!0;if(r.length!==t.length){let e=r.slice(-1)[0],n=t.slice(-1)[0];if(e===n||Xd(e)&&Xd(n)&&(r[0]===1||t[0]===1))return!0}return r[1]===t[1]&&Xd(r[0])&&Xd(t[0])}var k_,S_;function Y2(r){if(k_==null){let t=qn(r);k_=t.getParameter(t.MAX_TEXTURE_SIZE)}return k_}function Z2(r){if(S_==null){let t=qn(r);S_=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,S_)}function J2(r){if(r===0)return 0;let t,e=qn(r);return Hn(e,"EXT_disjoint_timer_query_webgl2")&&r===2?t=2:Hn(e,"EXT_disjoint_timer_query")?t=1:t=0,t}function Hn(r,t){return r.getExtension(t)!=null}function I_(r){try{if(qn(r)!=null)return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function Q2(r){if(r===0)return!1;let t=qn(r);if(r===1){if(!Hn(t,"OES_texture_float"))return!1}else if(!Hn(t,"EXT_color_buffer_float"))return!1;return N_(t)}function tE(r){if(r===0)return!1;let t=qn(r);if(r===1){if(!Hn(t,"OES_texture_float")||!Hn(t,"WEBGL_color_buffer_float"))return!1}else{if(Hn(t,"EXT_color_buffer_float"))return N_(t);let n="EXT_color_buffer_half_float";if(Hn(t,n)){let s=t.getExtension(n);return uW(t,s)}return!1}return N_(t)}function N_(r){let t=pf(r),e=r.createTexture();r.bindTexture(r.TEXTURE_2D,e);let n=1,s=1;r.texImage2D(r.TEXTURE_2D,0,t.internalFormatFloat,n,s,0,t.textureFormatFloat,t.textureTypeFloat,null);let o=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,o),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,e,0);let a=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(e),r.deleteFramebuffer(o),a}function uW(r,t){let e=pf(r,t),n=r.createTexture();r.bindTexture(r.TEXTURE_2D,n);let s=1,o=1;r.texImage2D(r.TEXTURE_2D,0,e.internalFormatHalfFloat,s,o,0,e.textureFormatFloat,e.textureTypeHalfFloat,null);let a=r.createFramebuffer();r.bindFramebuffer(r.FRAMEBUFFER,a),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,n,0);let l=r.checkFramebufferStatus(r.FRAMEBUFFER)===r.FRAMEBUFFER_COMPLETE;return r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null),r.deleteTexture(n),r.deleteFramebuffer(a),l}function eE(r){return r!==2?!1:qn(r).fenceSync!=null}function no(r,t){Array.isArray(r)||(r=[r]),r.forEach(e=>{e!=null&&E.assert(e.dtype!=="complex64",()=>`${t} does not support complex64 tensors in the WebGL backend.`)})}var we=vt();we.registerFlag("HAS_WEBGL",()=>we.getNumber("WEBGL_VERSION")>0);we.registerFlag("WEBGL_VERSION",()=>I_(2)?2:I_(1)?1:0);we.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);we.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>we.get("WEBGL_VERSION")===2);we.registerFlag("WEBGL_CPU_FORWARD",()=>!0);we.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);we.registerFlag("WEBGL_PACK",()=>we.getBool("HAS_WEBGL"));we.registerFlag("WEBGL_PACK_NORMALIZATION",()=>we.getBool("WEBGL_PACK"));we.registerFlag("WEBGL_PACK_CLIP",()=>we.getBool("WEBGL_PACK"));we.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>!1);we.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>we.getBool("WEBGL_PACK"));we.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>we.getBool("WEBGL_PACK"));we.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>we.getBool("WEBGL_PACK"));we.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>we.getBool("WEBGL_PACK"));we.registerFlag("WEBGL_PACK_REDUCE",()=>we.getBool("WEBGL_PACK"));we.registerFlag("WEBGL_LAZILY_UNPACK",()=>we.getBool("WEBGL_PACK"));we.registerFlag("WEBGL_CONV_IM2COL",()=>we.getBool("WEBGL_PACK"));we.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>Y2(we.getNumber("WEBGL_VERSION")));we.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>Z2(we.getNumber("WEBGL_VERSION")));we.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{let r=we.getNumber("WEBGL_VERSION");return r===0?0:J2(r)});we.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>we.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ap.isMobile());we.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>Q2(we.getNumber("WEBGL_VERSION")));we.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>we.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:we.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));we.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>tE(we.getNumber("WEBGL_VERSION")));we.registerFlag("WEBGL_FENCE_API_ENABLED",()=>eE(we.getNumber("WEBGL_VERSION")));we.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>we.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);we.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,r=>{if(r<0&&r!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${r}.`)});function gr(){let r,t,e,n,s,o,a,l,u,p;return vt().getNumber("WEBGL_VERSION")===2?(r="#version 300 es",t="in",e="out",n="in",s="texture",o="outputColor",a="out vec4 outputColor;",l=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,u="",p=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(r="",t="attribute",e="varying",n="varying",s="texture2D",o="gl_FragColor",a="",l=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,u=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,p=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:r,attribute:t,varyingVs:e,varyingFs:n,texture2D:s,output:o,defineOutput:a,defineSpecialNaN:l,defineSpecialInf:u,defineRound:p}}function Fs(r,t,e="index"){let n=E.computeStrides(t);return n.map((s,o)=>{let a=`int ${r[o]} = ${e} / ${s}`,l=o===n.length-1?`int ${r[o+1]} = ${e} - ${r[o]} * ${s}`:`index -= ${r[o]} * ${s}`;return`${a}; ${l};`}).join("")}function $c(r){let t=E.computeStrides(r).map(e=>e.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${t[0]} + coords.y * ${t[1]} + coords.z;
  }
`}var Yd=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;var T_=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Fa.DENSE;let e=Oa(t),n=gr();this.outputShape=t,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${Fs(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${e[0]}, ${e[1]}));
        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}};var E_=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Fa.DENSE;let e=Oa(t),n=gr();this.outputShape=t,this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${Fs(["r","c","d"],t)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx *
          vec2(${e[0]}, ${e[1]}));
        int index = 4 * (resTexRC.x * ${e[1]} + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}};var A_=class{constructor(t){this.variableNames=["A"],this.outTexUsage=tn.DOWNLOAD;let e=gr();this.outputShape=t,this.userCode=`
      ${Yd}

      void main() {
        float x = getAAtOutCoords();
        ${e.output} = encode_float(x);
      }
    `}};var $_=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=tn.DOWNLOAD;let e=gr();this.outputShape=t,this.userCode=`
      ${Yd}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${e.output} = encode_float(x);
      }
    `}};var D_=class{constructor(t,e,n=!1){this.variableNames=["A"];let s=gr(),[o,a]=e;this.outputShape=t;let l="result";n&&(l="floor(result * 255. + 0.5)"),this.userCode=`
      ${$c(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / ${a};
        int c = imod(flatIndex, ${a});
        vec2 uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${o}.0);
        vec4 values = ${s.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${s.output} = vec4(${l}, 0., 0., 0.);
      }
    `}};var R_=class{constructor(t,e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let s=gr(),[o,a]=e;this.outputShape=t;let l="",u="result";n&&(u="floor(result * 255. + 0.5)");for(let p=0;p<=1;p++)for(let f=0;f<=1;f++){let m=p*2+f;l+=`
          localCoords = coords;
          if(localCoords[2] + ${f} < ${t[2]}) {
            localCoords[2] += ${f};
            if(localCoords[1] + ${p} < ${t[1]}) {
              localCoords[1] += ${p};

              flatIndex = getFlatIndex(localCoords);
              offset = imod(flatIndex, 4);

              flatIndex = idiv(flatIndex, 4, 1.);

              r = flatIndex / ${a};
              c = imod(flatIndex, ${a});
              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${o}.0);
              values = ${s.texture2D}(A, uv);

              if(offset == 0) {
                result[${m}] = values[0];
              } else if(offset == 1) {
                result[${m}] = values[1];
              } else if(offset == 2) {
                result[${m}] = values[2];
              } else {
                result[${m}] = values[3];
              }
            }
          }
        `}this.userCode=`
      ${$c(t)}

      void main() {
        ivec3 coords = getOutputCoords();

        vec4 result = vec4(0.);
        int flatIndex, r, c, offset;
        ivec3 localCoords;
        vec2 uv;
        vec4 values;

        ${l}

        ${s.output} = ${u};
      }
    `}};function rE(r){let t=gr(),e=`${t.version}
    precision highp float;
    ${t.attribute} vec3 clipSpacePos;
    ${t.attribute} vec2 uv;
    ${t.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return L2(r,e)}function nE(r){let t=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return V2(r,t)}function sE(r){let t=new Uint16Array([0,1,2,2,1,3]);return G2(r,t)}function mf(r,t,e,n,s,o){U2(t,e);let a=W2(r),l=r.TEXTURE_2D;return ce(r,()=>r.bindTexture(l,a)),ce(r,()=>r.texParameteri(l,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE)),ce(r,()=>r.texParameteri(l,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE)),ce(r,()=>r.texParameteri(l,r.TEXTURE_MIN_FILTER,r.NEAREST)),ce(r,()=>r.texParameteri(l,r.TEXTURE_MAG_FILTER,r.NEAREST)),ce(r,()=>r.texImage2D(l,0,n,t,e,0,s,o,null)),ce(r,()=>r.bindTexture(r.TEXTURE_2D,null)),a}function F_(r){return r.internalFormatFloat}function oE(r,t,e,n){let[s,o]=Ol(t,e);return mf(r,s,o,F_(n),n.textureFormatFloat,r.FLOAT)}function O_(r){return r.internalFormatHalfFloat}function iE(r,t,e,n){let[s,o]=Ol(t,e);return mf(r,s,o,O_(n),n.textureFormatFloat,n.textureTypeHalfFloat)}function P_(r){return r.downloadTextureFormat}function aE(r,t,e,n){let[s,o]=Ol(t,e);return mf(r,s,o,P_(n),r.RGBA,r.UNSIGNED_BYTE)}function L_(r){return r.internalFormatPackedFloat}function lE(r,t,e,n){let[s,o]=ro(t,e);return mf(r,s,o,L_(n),r.RGBA,r.FLOAT)}function z_(r){return r.internalFormatPackedHalfFloat}function uE(r,t,e,n){let[s,o]=ro(t,e);return mf(r,s,o,z_(n),r.RGBA,n.textureTypeHalfFloat)}function cE(r,t,e){let n=0,s=3*4,o=3*4+2*4;return ce(r,()=>r.bindBuffer(r.ARRAY_BUFFER,e)),w_(r,t,"clipSpacePos",e,3,o,n)&&w_(r,t,"uv",e,2,o,s)}function pE(r,t,e,n,s,o){ce(r,()=>r.bindTexture(r.TEXTURE_2D,t));let a,l,u;s instanceof Uint8Array?(a=new Uint8Array(e*n*4),l=r.UNSIGNED_BYTE,u=r.RGBA):(a=new Float32Array(e*n*4),l=r.FLOAT,u=o.internalFormatPackedFloat),a.set(s),ce(r,()=>r.texImage2D(r.TEXTURE_2D,0,u,e,n,0,r.RGBA,l,a)),ce(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function fE(r,t,e){ce(r,()=>r.bindTexture(r.TEXTURE_2D,t)),e.data instanceof Uint8Array?ce(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,e.width,e.height,0,r.RGBA,r.UNSIGNED_BYTE,e.data)):ce(r,()=>r.texImage2D(r.TEXTURE_2D,0,r.RGBA,r.RGBA,r.UNSIGNED_BYTE,e)),ce(r,()=>r.bindTexture(r.TEXTURE_2D,null))}function hE(r,t,e,n){let s=r.createBuffer();ce(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,s));let l=4*4*t*e;return ce(r,()=>r.bufferData(r.PIXEL_PACK_BUFFER,l,r.STREAM_READ)),ce(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,0)),ce(r,()=>r.bindBuffer(r.PIXEL_PACK_BUFFER,null)),s}function mE(r,t,e){let n=r,s=new Float32Array(e);return n.bindBuffer(n.PIXEL_PACK_BUFFER,t),n.getBufferSubData(n.PIXEL_PACK_BUFFER,0,s),n.bindBuffer(n.PIXEL_PACK_BUFFER,null),s}function dE(r,t,e,n){let[s,o]=Ol(t,e),a=4,l=new Uint8Array(F2(t*e,a));return ce(r,()=>r.readPixels(0,0,s,o,n.downloadTextureFormat,r.UNSIGNED_BYTE,l)),new Float32Array(l.buffer)}function gE(r,t,e,n,s,o,a,l){let u=r,p=new Float32Array(O2(o,a));return u.bindBuffer(u.PIXEL_PACK_BUFFER,t),u.getBufferSubData(u.PIXEL_PACK_BUFFER,0,p),u.bindBuffer(u.PIXEL_PACK_BUFFER,null),p}function xE(r,t,e){let n=new Float32Array(t*e*4);return ce(r,()=>r.readPixels(0,0,e,t,r.RGBA,r.FLOAT,n)),n}var M_=class{constructor(t){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];let e=vt().getNumber("WEBGL_VERSION");t!=null?(this.gl=t,R2(e,t)):this.gl=qn(e);let n="WEBGL_color_buffer_float",s="EXT_color_buffer_half_float";if(vt().getNumber("WEBGL_VERSION")===1){let o="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=ff(this.gl,o),Hn(this.gl,a))this.textureHalfFloatExtension=ff(this.gl,a);else if(vt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),Hn(this.gl,s))this.colorBufferHalfFloatExtension=ff(this.gl,s);else if(vt().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",Hn(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else if(Hn(this.gl,s))this.colorBufferHalfFloatExtension=this.gl.getExtension(s);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=nE(this.gl),this.indexBuffer=sE(this.gl),this.framebuffer=j2(this.gl),this.textureConfig=pf(this.gl,this.textureHalfFloatExtension)}get debug(){return vt().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");let t=this.gl;ce(t,()=>t.finish()),ce(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,null)),ce(t,()=>t.deleteFramebuffer(this.framebuffer)),ce(t,()=>t.bindBuffer(t.ARRAY_BUFFER,null)),ce(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,null)),ce(t,()=>t.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(t,e){return this.throwIfDisposed(),oE(this.gl,t,e,this.textureConfig)}createFloat16MatrixTexture(t,e){return this.throwIfDisposed(),iE(this.gl,t,e,this.textureConfig)}createUnsignedBytesMatrixTexture(t,e){return this.throwIfDisposed(),aE(this.gl,t,e,this.textureConfig)}uploadPixelDataToTexture(t,e){this.throwIfDisposed(),fE(this.gl,t,e)}uploadDenseMatrixToTexture(t,e,n,s){this.throwIfDisposed(),pE(this.gl,t,e,n,s,this.textureConfig)}createFloat16PackedMatrixTexture(t,e){return this.throwIfDisposed(),uE(this.gl,t,e,this.textureConfig)}createPackedMatrixTexture(t,e){return this.throwIfDisposed(),lE(this.gl,t,e,this.textureConfig)}deleteMatrixTexture(t){this.throwIfDisposed(),this.outputTexture===t&&(C_(this.gl,this.framebuffer),this.outputTexture=null),ce(this.gl,()=>this.gl.deleteTexture(t))}downloadByteEncodedFloatMatrixFromOutputTexture(t,e,n){return this.downloadMatrixDriver(t,()=>dE(this.gl,e,n,this.textureConfig))}downloadPackedMatrixFromBuffer(t,e,n,s,o,a){return gE(this.gl,t,e,n,s,o,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(t,e){return mE(this.gl,t,e)}createBufferFromTexture(t,e,n){this.bindTextureToFrameBuffer(t);let s=hE(this.gl,e,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),s}createAndWaitForFence(){let t=this.createFence(this.gl);return this.pollFence(t)}createFence(t){let e,n;if(vt().getBool("WEBGL_FENCE_API_ENABLED")){let s=t,o=s.fenceSync(s.SYNC_GPU_COMMANDS_COMPLETE,0);t.flush(),n=()=>{let a=s.clientWaitSync(o,0,0);return a===s.ALREADY_SIGNALED||a===s.CONDITION_SATISFIED},e=o}else vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(e=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(e,vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:e,isFencePassed:n}}downloadMatrixFromPackedTexture(t,e,n){return this.downloadMatrixDriver(t,()=>xE(this.gl,e,n))}createProgram(t){this.throwIfDisposed();let e=this.gl,n=z2(e,t),s=rE(e),o=M2(e);return ce(e,()=>e.attachShader(o,s)),ce(e,()=>e.attachShader(o,n)),B2(e,o),this.debug&&qd(e,o),this.vertexAttrsAreBound||(this.setProgram(o),this.vertexAttrsAreBound=cE(e,this.program,this.vertexBuffer)),o}deleteProgram(t){this.throwIfDisposed(),t===this.program&&(this.program=null),t!=null&&ce(this.gl,()=>this.gl.deleteProgram(t))}setProgram(t){this.throwIfDisposed(),this.program=t,this.program!=null&&this.debug&&qd(this.gl,this.program),ce(this.gl,()=>this.gl.useProgram(t))}getUniformLocation(t,e,n=!0){return this.throwIfDisposed(),n?q2(this.gl,t,e):H2(this.gl,t,e)}getAttributeLocation(t,e){return this.throwIfDisposed(),ce(this.gl,()=>this.gl.getAttribLocation(t,e))}getUniformLocationNoThrow(t,e){return this.throwIfDisposed(),this.gl.getUniformLocation(t,e)}setInputMatrixTexture(t,e,n){this.throwIfDisposed(),this.throwIfNoProgram(),K2(this.gl,t,e,n)}setOutputMatrixTexture(t,e,n){this.setOutputMatrixTextureDriver(t,n,e)}setOutputPackedMatrixTexture(t,e,n){this.throwIfDisposed();let[s,o]=ro(e,n);this.setOutputMatrixTextureDriver(t,s,o)}setOutputMatrixWriteRegion(t,e,n,s){this.setOutputMatrixWriteRegionDriver(n,t,s,e)}setOutputPackedMatrixWriteRegion(t,e,n,s){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&qd(this.gl,this.program),hf(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();let t=this.gl;this.debug&&this.debugValidate(),ce(t,()=>t.drawElements(t.TRIANGLES,6,t.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ce(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=ff(this.gl,vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let n=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=n.createQuery();return n.beginQuery(s.TIME_ELAPSED_EXT,o),o}let t=this.getQueryTimerExtensionWebGL1(),e=t.createQueryEXT();return t.beginQueryEXT(t.TIME_ELAPSED_EXT,e),e}endQuery(){if(vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){let e=this.gl,n=this.getQueryTimerExtensionWebGL2();e.endQuery(n.TIME_ELAPSED_EXT);return}let t=this.getQueryTimerExtensionWebGL1();t.endQueryEXT(t.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(t){return await E.repeatedTry(()=>this.disposed||this.isQueryAvailable(t,vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(t,vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(t,e){if(e===0)return null;if(e===2){let n=this.gl;return n.getQueryParameter(t,n.QUERY_RESULT)/1e6}else{let n=this.getQueryTimerExtensionWebGL1();return n.getQueryObjectEXT(t,n.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(t,e){if(e===0)return!0;if(e===2){let n=this.gl,s=this.getQueryTimerExtensionWebGL2(),o=n.getQueryParameter(t,n.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),o&&!this.disjoint}else{let n=this.getQueryTimerExtensionWebGL1(),s=n.getQueryObjectEXT(t,n.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),s&&!this.disjoint}}pollFence(t){return new Promise(e=>{this.addItemToPoll(()=>t.isFencePassed(),()=>e())})}pollItems(){let t=cW(this.itemsToPoll.map(e=>e.isDoneFn));for(let e=0;e<=t;++e){let{resolveFn:n}=this.itemsToPoll[e];n()}this.itemsToPoll=this.itemsToPoll.slice(t+1)}addItemToPoll(t,e){this.itemsToPoll.push({isDoneFn:t,resolveFn:e}),!(this.itemsToPoll.length>1)&&E.repeatedTry(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(t){this.throwIfDisposed(),Hd(this.gl,t,this.framebuffer),this.debug&&hf(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Hd(this.gl,this.outputTexture,this.framebuffer),this.debug&&hf(this.gl)):C_(this.gl,this.framebuffer)}downloadMatrixDriver(t,e){this.bindTextureToFrameBuffer(t);let n=e();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(t,e,n){this.throwIfDisposed();let s=this.gl;Hd(s,t,this.framebuffer),this.debug&&hf(s),this.outputTexture=t,ce(s,()=>s.viewport(0,0,e,n)),ce(s,()=>s.scissor(0,0,e,n))}setOutputMatrixWriteRegionDriver(t,e,n,s){this.throwIfDisposed(),ce(this.gl,()=>this.gl.scissor(t,e,n,s))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}};function cW(r){let t=0;for(;t<r.length&&r[t]();++t);return t-1}var{getBroadcastDims:yE}=H;function _E(r,t,e,n){let s=[];r.forEach(_=>{let v=E.sizeFromShape(_.shapeInfo.logicalShape);_.shapeInfo.isUniform?s.push(`uniform float ${_.name}${v>1?`[${v}]`:""};`):(s.push(`uniform sampler2D ${_.name};`),s.push(`uniform int offset${_.name};`))});let o=s.join(`
`),a=r.map(_=>pW(_,t,n)).join(`
`),l=t.texShape,u=gr(),p=mW(u),f,m,d=xW(u);return t.isPacked?(f=fW(t.logicalShape,l),m=gW(u)):(f=hW(t.logicalShape,l),m=dW(u)),n&&(d+=yW),[d,p,m,o,f,a,e].join(`
`)}function Dc(r){let t=r.shapeInfo.logicalShape;switch(t.length){case 0:return _W(r);case 1:return bW(r);case 2:return vW(r);case 3:return wW(r);case 4:return CW(r);case 5:return kW(r);case 6:return SW(r);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function bE(r){switch(r.shapeInfo.logicalShape.length){case 0:return IW(r);case 1:return NW(r);case 2:return TW(r);case 3:return EW(r);default:return AW(r)}}function pW(r,t,e=!1){let n="";e?n+=bE(r):n+=Dc(r);let s=r.shapeInfo.logicalShape,o=t.logicalShape;return s.length<=o.length&&(e?n+=$W(r,t):n+=DW(r,t)),n}function fW(r,t){switch(r.length){case 0:return vE();case 1:return RW(r,t);case 2:return PW(r,t);case 3:return FW(r,t);default:return OW(r,t)}}function hW(r,t){switch(r.length){case 0:return vE();case 1:return LW(r,t);case 2:return GW(r,t);case 3:return zW(r,t);case 4:return MW(r,t);case 5:return BW(r,t);case 6:return VW(r,t);default:throw new Error(`${r.length}-D output sampling is not yet supported`)}}function mW(r){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${r.texture2D}(textureSampler, uv).r;
    }
  `}function dW(r){return`
    void setOutput(float val) {
      ${r.output} = vec4(val, 0, 0, 0);
    }
  `}function gW(r){return`
    void setOutput(vec4 val) {
      ${r.output} = val;
    }
  `}function xW(r){return`${r.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${r.varyingFs} vec2 resultUV;
    ${r.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${r.defineSpecialNaN}
    ${r.defineSpecialInf}
    ${r.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${WW}
    ${UW}
    ${jW}
  `}var WW=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,UW=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,jW=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,yW=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function vE(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function RW(r,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];return e[0]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${e[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return 2 * (resTexRC.x * ${e[1]} + resTexRC.y);
    }
  `}function LW(r,t){return t[0]===1?`
      int getOutputCoords() {
        return int(resultUV.x * ${t[1]}.0);
      }
    `:t[1]===1?`
      int getOutputCoords() {
        return int(resultUV.y * ${t[0]}.0);
      }
    `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      return resTexRC.x * ${t[1]} + resTexRC.y;
    }
  `}function FW(r,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],n=Math.ceil(r[2]/2),s=n*Math.ceil(r[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec3(b, r, c);
    }
  `}function zW(r,t){let e=Fs(["r","c","d"],r);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${e}
      return ivec3(r, c, d);
    }
  `}function OW(r,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],n=Math.ceil(r[r.length-1]/2),s=n*Math.ceil(r[r.length-2]/2),o=s,a="",l="b, r, c";for(let u=2;u<r.length-1;u++)o*=r[r.length-u-1],a=`
      int b${u} = index / ${o};
      index -= b${u} * ${o};
    `+a,l=`b${u}, `+l;return`
    ivec${r.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec${r.length}(${l});
    }
  `}function MW(r,t){let e=Fs(["r","c","d","d2"],r);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      ${e}
      return ivec4(r, c, d, d2);
    }
  `}function BW(r,t){let e=Fs(["r","c","d","d2","d3"],r);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${t[0]},
                             ${t[1]}));

      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function VW(r,t){let e=Fs(["r","c","d","d2","d3","d4"],r);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;

      ${e}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function PW(r,t){let e=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(E.arraysEqual(r,t))return`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `;let n=Math.ceil(r[1]/2);return`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = 2 * (index / ${n});
      int c = imod(index, ${n}) * 2;

      return ivec2(r, c);
    }
  `}function GW(r,t){return E.arraysEqual(r,t)?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));
      }
    `:r[1]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:r[0]===1?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${t[0]}, ${t[1]}));
        int index = resTexRC.x * ${t[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${t[0]}, ${t[1]}));
      int index = resTexRC.x * ${t[1]} + resTexRC.y;
      int r = index / ${r[1]};
      int c = index - r * ${r[1]};
      return ivec2(r, c);
    }
  `}function Ll(r){return`offset${r}`}function IW(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),n=gr();return`
    vec4 ${e}() {
      return ${n.texture2D}(${t}, halfCR);
    }
  `}function _W(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`float ${e}() {return ${t};}`;let[n,s]=r.shapeInfo.texShape;if(n===1&&s===1)return`
      float ${e}() {
        return sampleTexture(${t}, halfCR);
      }
    `;let[o,a]=r.shapeInfo.texShape,l=Ll(t);return`
    float ${e}() {
      vec2 uv = uvFromFlat(${o}, ${a}, ${l});
      return sampleTexture(${t}, uv);
    }
  `}function NW(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1),n=r.shapeInfo.texShape,s=[Math.ceil(n[0]/2),Math.ceil(n[1]/2)],o=gr();return`
    vec4 ${e}(int index) {
      vec2 uv = packedUVfrom1D(
        ${s[0]}, ${s[1]}, index);
      return ${o.texture2D}(${t}, uv);
    }
  `}function bW(r){let t=r.name,e="get"+t.charAt(0).toUpperCase()+t.slice(1);if(r.shapeInfo.isUniform)return`
      float ${e}(int index) {
        ${Rc(r)}
      }
    `;let n=r.shapeInfo.texShape,s=n[0],o=n[1];if(o===1&&s===1)return`
      float ${e}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;let a=Ll(t);return o===1?`
      float ${e}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?`
      float ${e}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
    float ${e}(int index) {
      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function TW(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=r.shapeInfo.texShape,o=s[0],a=s[1],l=gr();if(s!=null&&E.arraysEqual(t,s))return`
      vec4 ${n}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${e}, uv);
      }
    `;let u=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],p=Math.ceil(t[1]/2);return`
    vec4 ${n}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p}, ${u[0]}, ${u[1]}, row, col);
      return ${l.texture2D}(${e}, uv);
    }
  `}function vW(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=r.shapeInfo.texShape;if(s!=null&&E.arraysEqual(t,s)){let m=s[0],d=s[1];return`
    float ${n}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${d}.0, ${m}.0);
      return sampleTexture(${e}, uv);
    }
  `}let{newShape:o,keptDims:a}=E.squeezeShape(t),l=o;if(l.length<t.length){let m=Fc(r,l),d=["row","col"];return`
      ${Dc(m)}
      float ${n}(int row, int col) {
        return ${n}(${Oc(d,a)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Rc(r)}
      }
    `;let u=s[0],p=s[1],f=Ll(e);return p===1?`
    float ${n}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${u}.0);
      return sampleTexture(${e}, uv);
    }
  `:u===1?`
    float ${n}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);
      return sampleTexture(${e}, uv);
    }
  `:`
  float ${n}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${f};
    vec2 uv = uvFromFlat(${u}, ${p}, index);
    return sampleTexture(${e}, uv);
  }
`}function EW(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=r.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){let m=t.slice(1),d=[1,2],y=Fc(r,m),_=["b","row","col"];return`
        ${bE(y)}
        vec4 ${n}(int b, int row, int col) {
          return ${n}(${Oc(_,d)});
        }
      `}let a=o[0],l=o[1],u=Math.ceil(t[2]/2),p=u*Math.ceil(t[1]/2),f=gr();return`
    vec4 ${n}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${a}, ${l}, ${p}, ${u}, b, row, col);
      return ${f.texture2D}(${e}, uv);
    }
  `}function wW(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=E.squeezeShape(t),u=a;if(u.length<t.length){let _=Fc(r,u),v=["row","col","depth"];return`
        ${Dc(_)}
        float ${n}(int row, int col, int depth) {
          return ${n}(${Oc(v,l)});
        }
      `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${o}, 1)));
        ${Rc(r)}
      }
    `;let p=r.shapeInfo.texShape,f=p[0],m=p[1],d=r.shapeInfo.flatOffset;if(m===s&&d==null)return`
        float ${n}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${m}.0, ${f}.0);
          return sampleTexture(${e}, uv);
        }
      `;if(m===o&&d==null)return`
    float ${n}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${m}.0, ${f}.0);
      return sampleTexture(${e}, uv);
    }
  `;let y=Ll(e);return`
      float ${n}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${o} + depth + ${y};
        vec2 uv = uvFromFlat(${f}, ${m}, index);
        return sampleTexture(${e}, uv);
      }
  `}function AW(r){let t=r.shapeInfo.logicalShape,e=t.length,n=r.name,s="get"+n.charAt(0).toUpperCase()+n.slice(1),o=r.shapeInfo.texShape,a=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=a[0],u=a[1],p=Math.ceil(t[e-1]/2),f=p*Math.ceil(t[e-2]/2),m="int b, int row, int col",d=`b * ${f} + (row / 2) * ${p} + (col / 2)`;for(let _=2;_<e-1;_++)m=`int b${_}, `+m,f*=t[e-_-1],d=`b${_} * ${f} + `+d;let y=gr();return`
    vec4 ${s}(${m}) {
      int index = ${d};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${l});
      return ${y.texture2D}(${n}, uv);
    }
  `}function CW(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[3],o=t[2]*s,a=t[1]*o,{newShape:l,keptDims:u}=E.squeezeShape(t);if(l.length<t.length){let _=Fc(r,l),v=["row","col","depth","depth2"];return`
      ${Dc(_)}
      float ${n}(int row, int col, int depth, int depth2) {
        return ${n}(${Oc(v,u)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${s}, 1)));
        ${Rc(r)}
      }
    `;let p=r.shapeInfo.flatOffset,f=r.shapeInfo.texShape,m=f[0],d=f[1];if(d===a&&p==null)return`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${d}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(d===s&&p==null)return`
      float ${n}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${d}.0, ${m}.0);
        return sampleTexture(${e}, uv);
      }
    `;let y=Ll(e);return`
    float ${n}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${m}, ${d}, index + ${y});
      return sampleTexture(${e}, uv);
    }
  `}function kW(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),s=t[4],o=t[3]*s,a=t[2]*o,l=t[1]*a,{newShape:u,keptDims:p}=E.squeezeShape(t);if(u.length<t.length){let v=Fc(r,u),C=["row","col","depth","depth2","depth3"];return`
      ${Dc(v)}
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        return ${n}(${Oc(C,p)});
      }
    `}if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${l}, ${a}, ${o}, ${s})) +
          depth3;
        ${Rc(r)}
      }
    `;let f=r.shapeInfo.flatOffset,m=r.shapeInfo.texShape,d=m[0],y=m[1];if(y===l&&f==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${y}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(y===s&&f==null)return`
      float ${n}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]},
               ${t[2]*t[3]}, ${t[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${y}.0, ${d}.0);
        return sampleTexture(${e}, uv);
      }
    `;let _=Ll(e);return`
    float ${n}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${l} + col * ${a} + depth * ${o} +
          depth2 * ${s} + depth3 + ${_};
      vec2 uv = uvFromFlat(${d}, ${y}, index);
      return sampleTexture(${e}, uv);
    }
  `}function SW(r){let t=r.shapeInfo.logicalShape,e=r.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),{newShape:s,keptDims:o}=E.squeezeShape(t);if(s.length<t.length){let C=Fc(r,s),N=["row","col","depth","depth2","depth3","depth4"];return`
      ${Dc(C)}
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${n}(${Oc(N,o)});
      }
    `}let a=t[5],l=t[4]*a,u=t[3]*l,p=t[2]*u,f=t[1]*p;if(r.shapeInfo.isUniform)return`
      float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${f}, ${p}, ${u}, ${l})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Rc(r)}
      }
    `;let m=r.shapeInfo.flatOffset,d=r.shapeInfo.texShape,y=d[0],_=d[1];if(_===f&&m==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${p}, ${u}, ${l}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${_}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;if(_===a&&m==null)return`
      float ${n}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${t[1]*t[2]*t[3]*t[4]},
               ${t[2]*t[3]*t[4]},
               ${t[3]*t[4]},
               ${t[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${_}.0, ${y}.0);
        return sampleTexture(${e}, uv);
      }
    `;let v=Ll(e);return`
    float ${n}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${f} + col * ${p} + depth * ${u} +
          depth2 * ${l} + depth3 * ${a} + depth4 + ${v};
      vec2 uv = uvFromFlat(${y}, ${_}, index);
      return sampleTexture(${e}, uv);
    }
  `}function Rc(r){let t=r.name,e=E.sizeFromShape(r.shapeInfo.logicalShape);return e<2?`return ${t};`:`
    for (int i = 0; i < ${e}; i++) {
      if (i == index) {
        return ${t}[i];
      }
    }
  `}function $W(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),s="get"+n+"AtOutCoords",o=r.shapeInfo.logicalShape.length,a=t.logicalShape.length,l=yE(r.shapeInfo.logicalShape,t.logicalShape),u=be(a),p=a-o,f,m=["x","y","z","w","u","v"];o===0?f="":a<2&&l.length>=1?f="coords = 0;":f=l.map(A=>`coords.${m[A+p]} = 0;`).join(`
`);let d="";a<2&&o>0?d="coords":d=r.shapeInfo.logicalShape.map((A,B)=>`coords.${m[B+p]}`).join(", ");let y="return outputValue;",v=E.sizeFromShape(r.shapeInfo.logicalShape)===1,N=E.sizeFromShape(t.logicalShape)===1;if(o===1&&!v&&!N)y=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(v&&!N)a===1?y=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:y=`
        return vec4(outputValue.x);
      `;else if(l.length){let A=o-2,B=o-1;l.indexOf(A)>-1&&l.indexOf(B)>-1?y="return vec4(outputValue.x);":l.indexOf(A)>-1?y="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":l.indexOf(B)>-1&&(y="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${s}() {
      ${u} coords = getOutputCoords();
      ${f}
      vec4 outputValue = get${n}(${d});
      ${y}
    }
  `}function DW(r,t){let e=r.name,n=e.charAt(0).toUpperCase()+e.slice(1),s="get"+n+"AtOutCoords",o=t.texShape,a=r.shapeInfo.texShape,l=r.shapeInfo.logicalShape.length,u=t.logicalShape.length;if(!r.shapeInfo.isUniform&&l===u&&r.shapeInfo.flatOffset==null&&E.arraysEqual(a,o))return`
      float ${s}() {
        return sampleTexture(${e}, resultUV);
      }
    `;let p=be(u),f=yE(r.shapeInfo.logicalShape,t.logicalShape),m=u-l,d,y=["x","y","z","w","u","v"];l===0?d="":u<2&&f.length>=1?d="coords = 0;":d=f.map(v=>`coords.${y[v+m]} = 0;`).join(`
`);let _="";return u<2&&l>0?_="coords":_=r.shapeInfo.logicalShape.map((v,C)=>`coords.${y[C+m]}`).join(", "),`
    float ${s}() {
      ${p} coords = getOutputCoords();
      ${d}
      return get${n}(${_});
    }
  `}function be(r){if(r<=1)return"int";if(r===2)return"ivec2";if(r===3)return"ivec3";if(r===4)return"ivec4";if(r===5)return"ivec5";if(r===6)return"ivec6";throw Error(`GPU for rank ${r} is not yet supported`)}function Fc(r,t){let e=JSON.parse(JSON.stringify(r));return e.shapeInfo.logicalShape=t,e}function Oc(r,t){return t.map(e=>r[e]).join(", ")}function wE(r,t,e,n){let s=t.userCode,o=e.map((y,_)=>{let v={logicalShape:y.shape,texShape:y.isUniform?null:y.texData.texShape,isUniform:y.isUniform,isPacked:y.isUniform?!1:y.texData.isPacked,flatOffset:null};return y.texData!=null&&y.texData.slice!=null&&y.texData.slice.flatOffset>0&&(v.flatOffset=y.texData.slice.flatOffset),{name:t.variableNames[_],shapeInfo:v}}),a=o.map(y=>y.shapeInfo),l={logicalShape:n.shape,texShape:n.texData.texShape,isUniform:!1,isPacked:n.texData.isPacked,flatOffset:null},u=_E(o,l,s,t.packedInputs),p=r.createProgram(u),f=null,m=r.getUniformLocation(p,"NAN",!1);vt().getNumber("WEBGL_VERSION")===1&&(f=r.getUniformLocation(p,"INFINITY",!1));let d={};for(let y=0;y<t.variableNames.length;y++){let _=t.variableNames[y],v=!1;d[_]=r.getUniformLocation(p,_,v),d[`offset${_}`]=r.getUniformLocation(p,`offset${_}`,v)}return{program:t,source:u,webGLProgram:p,uniformLocations:d,inShapeInfos:a,outShapeInfo:l,infLoc:f,nanLoc:m}}function CE(r,t){if(r.length!==t.length)throw Error(`Binary was compiled with ${r.length} inputs, but was executed with ${t.length} inputs`);r.forEach((e,n)=>{let s=e.logicalShape,o=t[n],a=o.shape;if(!E.arraysEqual(s,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${s} and ${a} must match`);if(e.isUniform&&o.isUniform)return;let l=e.texShape,u=o.isUniform?null:o.texData.texShape;if(!E.arraysEqual(l,u))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${l} and ${u} must match`)})}function kE(r,t,e,n,s){CE(t.inShapeInfos,e),CE([t.outShapeInfo],[n]);let o=n.texData.texture,a=n.texData.texShape;n.texData.isPacked?r.setOutputPackedMatrixTexture(o,a[0],a[1]):r.setOutputMatrixTexture(o,a[0],a[1]),r.setProgram(t.webGLProgram),vt().getNumber("WEBGL_VERSION")===1&&t.infLoc!==null&&r.gl.uniform1f(t.infLoc,Infinity),t.nanLoc!==null&&r.gl.uniform1f(t.nanLoc,NaN),e.forEach((l,u)=>{let p=t.program.variableNames[u],f=t.uniformLocations[p],m=t.uniformLocations[`offset${p}`];if(f!=null){if(l.isUniform){if(E.sizeFromShape(l.shape)<2)r.gl.uniform1f(f,l.uniformValues[0]);else{let d=l.uniformValues;d instanceof Float32Array||(d=new Float32Array(d)),r.gl.uniform1fv(f,d)}return}l.texData.slice!=null&&m!=null&&r.gl.uniform1i(m,l.texData.slice.flatOffset),r.setInputMatrixTexture(l.texData.texture,f,u)}}),s!=null&&s(r,t.webGLProgram),r.executeProgram()}function SE(r,t,e){let n="";t.concat(e).forEach(a=>{let l=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0,u=a.isUniform?"uniform":a.texData.texShape;n+=`${a.shape}_${u}_${l}`});let s=r.userCode,o=r.constructor.name;return o+="_"+n+"_"+s,o}var{addImpl:IE,bincountImpl:Zd,bincountReduceImpl:NE,ceilImpl:TE,concatImpl:EE,expImpl:AE,expm1Impl:$E,floorImpl:DE,gatherV2Impl:RE,greaterImpl:FE,lessImpl:OE,linSpaceImpl:PE,logImpl:LE,maxImpl:zE,maximumImpl:ME,minimumImpl:BE,multiplyImpl:VE,negImpl:GE,prodImpl:WE,rangeImpl:UE,rsqrtImpl:jE,simpleAbsImpl:Jd,sliceImpl:qE,stridedSliceImpl:HE,subImpl:KE,tileImpl:XE,topKImpl:YE,transposeImpl:Pc,uniqueImpl:ZE}=a_;function B_(r,t){return["x","y","z","w","u","v"].slice(0,t).map(e=>`${r}.${e}`)}function br(r,t){return t===1?[r]:B_(r,t)}function JE(r,t){if(r===1)return"rc";let e="";for(let n=0;n<r;n++)e+=t[n],n<r-1&&(e+=",");return e}var V_=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=t;let e=t.length;if(e===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{let n=br("rc",e),s=be(e),o=qW(e,t,n),a=HW(e,t[t.length-1],t[t.length-2],n),l=KW(t,n);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${o}) {
            setOutput(vec4(0));
          } else {
            ${a}

            setOutput(vec4(${l}));
          }
        }
      `}}};function XW(r,t){let e=[];for(let n=0;n<=1;n++)for(let s=0;s<=1;s++){let o=`${n===0?"r":"rp1"}, ${s===0?"c":"cp1"}`;for(let a=2;a<r;a++)o=`${t[t.length-1-a]},`+o;e.push(o)}return e}function qW(r,t,e){if(r===1)return`rc > ${t[0]}`;let n="";for(let s=r-2;s<r;s++)n+=`${e[s]} >= ${t[s]}`,s<r-1&&(n+="||");return n}function HW(r,t,e,n){if(r===1)return"";let s=n.slice(-2);return`
    int r = ${s[0]};
    int c = ${s[1]};
    int rp1 = r + 1;
    int cp1 = c + 1;

    bool cEdge = cp1 >= ${t};
    bool rEdge = rp1 >= ${e};
  `}function KW(r,t){let e=r.length,n=XW(e,t);return e===1?`getA(rc),
            rc + 1 >= ${r[0]} ? 0. : getA(rc + 1),
            0, 0`:`getA(${n[0]}),
          cEdge ? 0. : getA(${n[1]}),
          rEdge ? 0. : getA(${n[2]}),
          rEdge || cEdge ? 0. : getA(${n[3]})`}var df=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let n="";for(let s=0;s<4;s++){let o="thisRC = rc;";s%2==1&&(o+="thisRC.z += 1;"),s>1&&(o+="thisRC.y += 1;"),n+=`
        ${o}
        ${s>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${s}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${s>0?"}":""}
      `}this.userCode=`
      ${YW(e)}
      ${$c(t)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${t[1]};
        int cols = ${t[2]};

        ${n}

        setOutput(result);
      }
    `}};function YW(r){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${Fs(["r","c","d"],r)}
      return ivec3(r, c, d);
    }
  `}var G_=class{constructor(t){this.gpgpu=t,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(t,e,n){let s=tA(e,n),o=eA(t,s,n);o in this.freeTextures||(this.freeTextures[o]=[]),o in this.usedTextures||(this.usedTextures[o]=[]);let a=QE(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[o].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();let u=this.freeTextures[o].shift();return this.usedTextures[o].push(u),u}let l;return s===Wr.PACKED_2X2_FLOAT32?l=this.gpgpu.createPackedMatrixTexture(t[0],t[1]):s===Wr.PACKED_2X2_FLOAT16?l=this.gpgpu.createFloat16PackedMatrixTexture(t[0],t[1]):s===Wr.UNPACKED_FLOAT32?l=this.gpgpu.createFloat32MatrixTexture(t[0],t[1]):s===Wr.UNPACKED_FLOAT16?l=this.gpgpu.createFloat16MatrixTexture(t[0],t[1]):s===Wr.PACKED_4X1_UNSIGNED_BYTE&&(l=this.gpgpu.createUnsignedBytesMatrixTexture(t[0],t[1])),this.usedTextures[o].push(l),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),l}releaseTexture(t,e,n,s){if(this.freeTextures==null)return;let o=tA(n,s),a=eA(e,o,s);a in this.freeTextures||(this.freeTextures[a]=[]);let l=QE(e,o,this.gpgpu.gl,this.gpgpu.textureConfig,s),u=vt().get("WEBGL_DELETE_TEXTURE_THRESHOLD");u!==-1&&this._numBytesAllocated>u?(this.gpgpu.deleteMatrixTexture(t),this._numBytesAllocated-=l):(this.freeTextures[a].push(t),this.numFreeTextures++,this._numBytesFree+=l),this.numUsedTextures--;let p=this.usedTextures[a],f=p.indexOf(t);if(f<0)throw new Error("Cannot release a texture that was never provided by this texture manager");p.splice(f,1),this.log()}log(){if(!this.logEnabled)return;let t=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${t})`);let e=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*e)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(let t in this.freeTextures)this.freeTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});for(let t in this.usedTextures)this.usedTextures[t].forEach(e=>{this.gpgpu.deleteMatrixTexture(e)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}};function ZW(r,t){let e=r;if(t===e.R32F)return 4;if(t===e.R16F)return 2;if(t===e.RGBA32F)return 16;if(t===r.RGBA)return 16;if(t===e.RGBA16F)return 8;throw new Error(`Unknown internal format ${t}`)}function QE(r,t,e,n,s){let o=JW(t,n),a;if(s){let[u,p]=ro(r[0],r[1]);a=u*p}else{let[u,p]=Ol(r[0],r[1]);a=u*p}let l=ZW(e,o);return a*l}function JW(r,t){switch(r){case Wr.PACKED_2X2_FLOAT32:return L_(t);case Wr.PACKED_2X2_FLOAT16:return z_(t);case Wr.UNPACKED_FLOAT32:return F_(t);case Wr.UNPACKED_FLOAT16:return O_(t);case Wr.PACKED_4X1_UNSIGNED_BYTE:return P_(t);default:throw new Error(`Unknown physical texture type ${r}`)}}function QW(r){return vt().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?r?Wr.PACKED_2X2_FLOAT32:Wr.UNPACKED_FLOAT32:r?Wr.PACKED_2X2_FLOAT16:Wr.UNPACKED_FLOAT16}function tA(r,t){if(r===tn.UPLOAD)return Wr.PACKED_2X2_FLOAT32;if(r===tn.RENDER||r==null)return QW(t);if(r===tn.DOWNLOAD||r===tn.PIXELS)return Wr.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${r}`)}function eA(r,t,e){return`${r[0]}_${r[1]}_${t}_${e}`}var In=class{constructor(t,e){this.variableNames=["A"],this.outputShape=t,this.userCode=`
      float unaryOperation(float x) {
        ${e}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}},Pr="if (isnan(x)) return x;",rA="return x;",W_="return abs(x);";var nA="return (x >= 0.0) ? x : (exp(x) - 1.0);",sA=Pr+`
  return (x < 0.0) ? 0.0 : x;
`,oA=Pr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,gf="return x;";var iA="return x;",aA=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,lA=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,uA=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Os=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${e}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}};var U_=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=t;let e=t.length,n=br("rc",e),s=be(e),o=JE(e,n),a=n.slice(-2),l=e<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${s} rc = getOutputCoords();
        vec4 packedInput = getA(${o});

        setOutput(getChannel(packedInput, ${l}));
      }
    `}};var t5=sn.whereImpl,e5=1e-7,r5=1e-4,Qd={};function n5(r){return r in Qd||(Qd[r]={}),Qd[r]}var s5=128,o5=600;function i5(){return vt().global.screen==null?1024:vt().global.screen.height*vt().global.screen.width*window.devicePixelRatio*o5/1024/1024}var j_=class extends Ka{constructor(t){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.warnedAboutMemory=!1,this.warnedAboutCPUBackend=!1,this.pendingDeletes=0,this.disposed=!1,!vt().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(t==null){let e=qn(vt().getNumber("WEBGL_VERSION"));this.binaryCache=n5(vt().getNumber("WEBGL_VERSION")),this.gpgpu=new M_(e),this.canvas=e.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=t,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=t.gl.canvas;this.textureManager=new G_(this.gpgpu),this.numMBBeforeWarning=i5(),this.texData=new Kc(this,_a())}numDataIds(){return this.texData.numDataIds()+(this.cpuBackend?this.cpuBackend.numDataIds():0)-this.pendingDeletes}write(t,e,n){if((vt().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||vt().getBool("DEBUG"))&&this.checkNumericalProblems(t),n==="complex64"&&t!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");let s={};return this.texData.set(s,{shape:e,dtype:n,values:t,usage:tn.UPLOAD,refCount:1,complexParentRefCount:0}),s}incRef(t){let e=this.texData.get(t);e.refCount++}decRef(t){if(this.texData.has(t)){let e=this.texData.get(t);e.refCount--}}decComplexRef(t){if(this.texData.has(t)){let e=this.texData.get(t);e.complexParentRefCount>0&&e.refCount--}}move(t,e,n,s){if(vt().getBool("DEBUG")&&this.checkNumericalProblems(e),s==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(t,{shape:n,dtype:s,values:e,usage:tn.UPLOAD,refCount:1,complexParentRefCount:0})}disposeIntermediateTensorInfo(t){let e=t.dataId;if(this.texData.has(e)){let n=this.texData.get(e);n.refCount--,n.refCount<1&&this.disposeData(e)}}readSync(t){let e=this.texData.get(t),{values:n,dtype:s,complexTensorInfos:o,slice:a,shape:l,isPacked:u}=e;if(a!=null){let d;u?d=new Os(l,gf):d=new In(l,gf);let y=this.runWebGLProgram(d,[{dataId:t,shape:l,dtype:s}],s),_=this.readSync(y.dataId);return this.disposeIntermediateTensorInfo(y),_}if(n!=null)return this.convertAndCacheOnCPU(t);if(s==="string")return n;let p=this.activeTimers!=null,f;p&&(f=E.now());let m;if(s==="complex64"){let d=this.readSync(o.real.dataId),y=this.readSync(o.imag.dataId);m=H.mergeRealAndImagArrays(d,y)}else m=this.getValuesFromTexture(t);return p&&(this.downloadWaitMs+=E.now()-f),this.convertAndCacheOnCPU(t,m)}async read(t){if(this.pendingRead.has(t)){let _=this.pendingRead.get(t);return new Promise(v=>_.push(v))}let e=this.texData.get(t),{values:n,shape:s,slice:o,dtype:a,complexTensorInfos:l,isPacked:u}=e;if(o!=null){let _;u?_=new Os(s,gf):_=new In(s,gf);let v=this.runWebGLProgram(_,[{dataId:t,shape:s,dtype:a}],a),C=this.read(v.dataId);return this.disposeIntermediateTensorInfo(v),C}if(n!=null)return this.convertAndCacheOnCPU(t);if(!vt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&vt().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let p=null,f;if(a!=="complex64"&&vt().get("WEBGL_BUFFER_SUPPORTED")){f=this.decode(t);let _=this.texData.get(f.dataId);p=this.gpgpu.createBufferFromTexture(_.texture,...Oa(s))}this.pendingRead.set(t,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let m;if(a==="complex64"){let _=await Promise.all([this.read(l.real.dataId),this.read(l.imag.dataId)]),v=_[0],C=_[1];m=H.mergeRealAndImagArrays(v,C)}else if(p==null)m=this.getValuesFromTexture(t);else{let _=E.sizeFromShape(s);m=this.gpgpu.downloadFloat32MatrixFromBuffer(p,_)}f!=null&&this.disposeIntermediateTensorInfo(f);let d=this.convertAndCacheOnCPU(t,m),y=this.pendingRead.get(t);return this.pendingRead.delete(t),y.forEach(_=>_(d)),this.pendingDisposal.has(t)&&(this.pendingDisposal.delete(t),this.disposeData(t),this.pendingDeletes--),d}bufferSync(t){let e=this.readSync(t.dataId),n=e;if(t.dtype==="string")try{n=e.map(s=>E.decodeString(s))}catch(s){throw new Error("Failed to decode encoded string bytes into utf-8")}return ae(t.shape,t.dtype,n)}checkNumericalProblems(t){if(t!=null)for(let e=0;e<t.length;e++){let n=t[e];if(!P2(n))throw vt().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${n} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${n} cannot be represented on this device.`)}}getValuesFromTexture(t){let{shape:e,dtype:n,isPacked:s}=this.texData.get(t),o=E.sizeFromShape(e);if(vt().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){let d=this.decode(t),y=this.texData.get(d.dataId),_=this.gpgpu.downloadMatrixFromPackedTexture(y.texture,...Oa(e)).subarray(0,o);return this.disposeIntermediateTensorInfo(d),_}let a=vt().getBool("WEBGL_PACK")&&s===!0,l=a?Kd(e):e,u=a?new $_(l):new A_(l),p=this.runWebGLProgram(u,[{shape:l,dtype:n,dataId:t}],"float32"),f=this.texData.get(p.dataId),m=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(f.texture,f.texShape[0],f.texShape[1]).subarray(0,o);return this.disposeIntermediateTensorInfo(p),m}async time(t){let e=this.activeTimers,n=[],s=!1;this.programTimersStack==null?(this.programTimersStack=n,s=!0):this.activeTimers.push(n),this.activeTimers=n,t();let o=E.flatten(this.activeTimers.map(u=>u.query)).filter(u=>u!=null),a=E.flatten(this.activeTimers.map(u=>u.name)).filter(u=>u!=null);this.activeTimers=e,s&&(this.programTimersStack=null);let l={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){let u=await Promise.all(o);l.kernelMs=E.sum(u),l.getExtraProfileInfo=()=>u.map((p,f)=>({name:a[f],ms:p})).map(p=>`${p.name}: ${p.ms}`).join(", ")}else l.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,l}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:E.now(),endMs:null}}endTimer(t){return vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),t):(t.endMs=E.now(),t)}async getQueryTime(t){if(vt().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(t);let e=t;return e.endMs-e.startMs}disposeData(t){if(this.pendingDisposal.has(t))return;if(this.pendingRead.has(t)){this.pendingDisposal.add(t),this.pendingDeletes++;return}if(!this.texData.has(t))return;if(this.texData.get(t).complexParentRefCount>0){this.texData.get(t).refCount--;return}this.releaseGPUData(t);let{complexTensorInfos:e}=this.texData.get(t);e!=null&&(this.texData.get(e.real.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(e.real),this.texData.get(e.imag.dataId).complexParentRefCount--,this.disposeIntermediateTensorInfo(e.imag)),this.texData.delete(t)}releaseGPUData(t){let{texture:e,dtype:n,texShape:s,usage:o,isPacked:a,slice:l}=this.texData.get(t),u=l&&l.origDataId||t,p=this.dataRefCount.get(u);p>1?this.dataRefCount.set(u,p-1):(this.dataRefCount.delete(u),e!=null&&(this.numBytesInGPU-=this.computeBytes(s,n),this.textureManager.releaseTexture(e,s,o,a)));let f=this.texData.get(t);f.texture=null,f.texShape=null,f.isPacked=!1,f.slice=null}getTexture(t){return this.uploadToGPU(t),this.texData.get(t).texture}getDataInfo(t){return this.texData.get(t)}getCPUBackend(){return vt().getBool("WEBGL_CPU_FORWARD")?(this.cpuBackend==null&&(this.cpuBackend=_a().findBackend("cpu")),this.cpuBackend):null}shouldExecuteOnCPU(t,e=s5){let n=this.getCPUBackend();return!vt().getBool("IS_TEST")&&!this.warnedAboutCPUBackend&&n==null&&(console.warn("Your application contains ops that are small enough to be executed on the CPU backend, however the CPU backend cannot be found. Consider importing the CPU backend (@tensorflow/tfjs-backend-cpu) for better performance."),this.warnedAboutCPUBackend=!0),n!=null&&t.every(s=>this.texData.get(s.dataId).texture==null&&E.sizeFromShape(s.shape)<e)}getGPGPUContext(){return this.gpgpu}where(t){H.warn("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");let e=t.dataSync();return t5(t.shape,e)}packedUnaryOp(t,e,n){let s=new Os(t.shape,e);return this.compileAndRun(s,[t],n)}abs(t){if(this.shouldExecuteOnCPU([t])&&t.dtype!=="complex64"){let n=Jd(this.texData.get(t.dataId).values);return this.makeOutput(t.shape,t.dtype,n)}if(vt().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(t,W_,t.dtype);let e=new In(t.shape,W_);return this.compileAndRun(e,[t])}makeTensorInfo(t,e,n){let s;if(e==="string"&&n!=null&&n.length>0&&E.isString(n[0])){let o=n.map(a=>E.encodeString(a));s=this.write(o,t,e)}else s=this.write(n,t,e);return this.texData.get(s).usage=null,{dataId:s,shape:t,dtype:e}}makeOutput(t,e,n){let{dataId:s}=this.makeTensorInfo(t,e,n);return _a().makeTensorFromDataId(s,t,e,this)}unpackTensor(t){let e=new U_(t.shape);return this.runWebGLProgram(e,[t],t.dtype)}packTensor(t){let e=new V_(t.shape),n=!0;return this.runWebGLProgram(e,[t],t.dtype,null,n)}packedReshape(t,e){let n=[Pa(t.shape),...La(t.shape)],s={dtype:t.dtype,shape:n,dataId:t.dataId},o=[Pa(e),...La(e)],a=new df(o,n),l=!0,u=this.runWebGLProgram(a,[s],t.dtype,null,l);return{dataId:u.dataId,shape:e,dtype:u.dtype}}decode(t){let e=this.texData.get(t),{isPacked:n,shape:s,dtype:o}=e,a=Kd(s),l;n?l=new E_(a):l=new T_(a);let u=!0,p=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:t}],o,null,u);return{dtype:o,shape:s,dataId:p.dataId}}runWebGLProgram(t,e,n,s,o=!1){let a=this.makeTensorInfo(t.outputShape,n),l=this.texData.get(a.dataId);if(t.packedOutput&&(l.isPacked=!0),t.outPackingScheme===Fa.DENSE){let v=Oa(t.outputShape);l.texShape=v.map(C=>C*2)}if(t.outTexUsage!=null&&(l.usage=t.outTexUsage),E.sizeFromShape(a.shape)===0)return l.values=E.getTypedArrayFromDType(a.dtype,0),a;let u=[],p=e.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let C=this.texData.get(v.dataId);if(C.texture==null){if(!t.packedInputs&&E.sizeFromShape(v.shape)<=vt().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:C.values};t.packedInputs&&(C.isPacked=!0,C.shape=v.shape)}else if(!!C.isPacked!=!!t.packedInputs)v=C.isPacked?this.unpackTensor(v):this.packTensor(v),u.push(v),C=this.texData.get(v.dataId);else if(C.isPacked&&!Pl(C.shape,v.shape)){let N=v,A=v.shape;v.shape=C.shape,v=this.packedReshape(v,A),u.push(v),C=this.texData.get(v.dataId),N.shape=A}return this.uploadToGPU(v.dataId),{shape:v.shape,texData:C,isUniform:!1}});this.uploadToGPU(a.dataId);let f={shape:a.shape,texData:l,isUniform:!1},m=SE(t,p,f),d=this.getAndSaveBinary(m,()=>wE(this.gpgpu,t,p,f)),y=this.activeTimers!=null,_;if(y&&(_=this.startTimer()),kE(this.gpgpu,d,p,f,s),u.forEach(v=>this.disposeIntermediateTensorInfo(v)),y&&(_=this.endTimer(_),this.activeTimers.push({name:t.constructor.name,query:this.getQueryTime(_)})),!vt().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&o===!1){let v=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),v}return a}compileAndRun(t,e,n,s,o=!1){n=n||e[0].dtype;let a=this.runWebGLProgram(t,e,n,s,o);return _a().makeTensorFromDataId(a.dataId,a.shape,a.dtype)}getAndSaveBinary(t,e){return t in this.binaryCache||(this.binaryCache[t]=e()),this.binaryCache[t]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(vt().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=_t(()=>{if(!vt().get("WEBGL_RENDER_FLOAT32_ENABLED")){let t=vt().getBool("DEBUG");vt().set("DEBUG",!1);let e=this.abs(fe(1e-8)).dataSync()[0];if(vt().set("DEBUG",t),e>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?e5:r5}uploadToGPU(t){let e=this.texData.get(t),{shape:n,dtype:s,values:o,texture:a,usage:l,isPacked:u}=e;if(a!=null)return;let p=this.activeTimers!=null,f;p&&(f=E.now());let m=e.texShape;if(m==null&&(m=X2(n,u),e.texShape=m),o!=null){let d=Kd(n),y,_=m[1],v=m[0],C=o instanceof Uint8Array;u?([_,v]=ro(m[0],m[1]),y=new R_(d,[v,_],C)):y=new D_(d,[v,_],C);let N=this.makeTensorInfo([v,_],s);C?this.texData.get(N.dataId).usage=tn.PIXELS:this.texData.get(N.dataId).usage=tn.UPLOAD,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(N.dataId),_,v,o);let A=!0,B=this.runWebGLProgram(y,[N],s,null,A),P=this.texData.get(B.dataId);e.texture=P.texture,e.texShape=P.texShape,e.isPacked=P.isPacked,e.usage=P.usage,this.disposeIntermediateTensorInfo(N),this.texData.delete(B.dataId),e.values=null,p&&(this.uploadWaitMs+=E.now()-f)}else{let d=this.acquireTexture(m,l,s,u);e.texture=d}}convertAndCacheOnCPU(t,e){let n=this.texData.get(t),{dtype:s}=n;return this.releaseGPUData(t),e!=null&&(n.values=a5(e,s)),n.values}acquireTexture(t,e,n,s){if(this.numBytesInGPU+=this.computeBytes(t,n),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){let o=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${o} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(t,e,s)}computeBytes(t,e){return t[0]*t[1]*E.bytesPerElement(e)}};function a5(r,t){if(t==="float32"||t==="complex64")return r;if(t==="int32"||t==="bool"){let e=t==="int32"?new Int32Array(r.length):new Uint8Array(r.length);for(let n=0;n<e.length;++n)e[n]=Math.round(r[n]);return e}else throw new Error(`Unknown dtype ${t}`)}ap.isBrowser()&&Sh("webgl",()=>new j_,2);var tg=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;var fs=class{constructor(t,e,n){this.variableNames=["A","B"],this.outputShape=H.assertAndGetBroadcastShape(e,n),this.userCode=`
      float binaryOperation(float a, float b) {
        ${t}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}};var za=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;var Ps=class{constructor(t,e,n,s=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=H.assertAndGetBroadcastShape(e,n);let o=this.outputShape.length,a="";if(s)if(o===0||E.sizeFromShape(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${be(o)} coords = getOutputCoords();
        `,o===1)a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{let u=br("coords",o);a+=`
            bool nextRowOutOfBounds =
              (${u[o-2]} + 1) >= ${this.outputShape[o-2]};
            bool nextColOutOfBounds =
              (${u[o-1]} + 1) >= ${this.outputShape[o-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${t}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}};function vr(r){let{inputs:t,backend:e}=r,{x:n}=t;return e.incRef(n.dataId),{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}var cA={kernelName:Gi,backendName:"webgl",kernelFunc:vr};function Nn(r){let{inputs:t,backend:e}=r,{real:n,imag:s}=t,o=e.makeTensorInfo(n.shape,"complex64"),a=e.texData.get(o.dataId),l=vr({inputs:{x:n},backend:e}),u=e.texData.get(l.dataId);u.complexParentRefCount++;let p=vr({inputs:{x:s},backend:e}),f=e.texData.get(p.dataId);return f.complexParentRefCount++,a.complexTensorInfos={real:l,imag:p},o}var pA={kernelName:uu,backendName:"webgl",kernelFunc:Nn};var q_="return (a < 0.) ? b * a : a;",H_=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function l5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{alpha:o}=n,a=e.makeTensorInfo([],"float32",E.createScalarValue(o,"float32")),l=vt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ps(H_,s.shape,a.shape):new fs(q_,s.shape,a.shape),u=e.runWebGLProgram(l,[s,a],s.dtype);return e.disposeIntermediateTensorInfo(a),u}var fA={kernelName:Wi,backendName:"webgl",kernelFunc:l5};var K_="return (a < 0.) ? b * a : a;",X_=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function u5(r){let{inputs:t,backend:e}=r,{x:n,alpha:s}=t,o=vt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ps(X_,n.shape,s.shape):new fs(K_,n.shape,s.shape);return e.runWebGLProgram(o,[n,s],n.dtype)}var hA={kernelName:ra,backendName:"webgl",kernelFunc:u5};var eg="if (isnan(x)) return x;",mA=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,dA=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function re({opSnippet:r,packedOpSnippet:t,cpuKernelImpl:e,dtype:n}){return({inputs:s,backend:o})=>{let{x:a}=s,l=o,u=n||a.dtype;if(l.shouldExecuteOnCPU([a])&&e!=null){let m=l.texData.get(a.dataId),d=e(m.values,u);return l.makeTensorInfo(a.shape,u,d)}let p=vt().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&t!=null,f;return p?f=new Os(a.shape,t):f=new In(a.shape,r),l.runWebGLProgram(f,[a],u)}}function Ge({opSnippet:r,packedOpSnippet:t,checkOutOfBounds:e=!1,supportsComplex:n=!1,cpuKernelImpl:s,dtype:o}){return({inputs:a,backend:l})=>{let{a:u,b:p}=a,f=l;if(n&&u.dtype==="complex64"){let _=f.texData.get(u.dataId),v=f.texData.get(p.dataId),[C,N]=[[_.complexTensorInfos.real,v.complexTensorInfos.real],[_.complexTensorInfos.imag,v.complexTensorInfos.imag]].map(B=>{let[P,L]=B,Z={dataId:P.dataId,dtype:P.dtype,shape:u.shape},K={dataId:L.dataId,dtype:L.dtype,shape:p.shape},et=new fs(r,u.shape,p.shape);return f.runWebGLProgram(et,[Z,K],Br(P.dtype,L.dtype))}),A=Nn({inputs:{real:C,imag:N},backend:f});return f.disposeIntermediateTensorInfo(C),f.disposeIntermediateTensorInfo(N),A}let m=o||Br(u.dtype,p.dtype);if(f.shouldExecuteOnCPU([u,p])&&s!=null){let _=f.texData.get(u.dataId),v=f.texData.get(p.dataId),[C,N]=s(u.shape,p.shape,_.values,v.values,m),A=f.makeTensorInfo(N,m),B=f.texData.get(A.dataId);return B.values=C,A}let d=vt().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&t!=null,y;return d?y=new Ps(t,u.shape,p.shape,e):y=new fs(r,u.shape,p.shape),f.runWebGLProgram(y,[u,p],m)}}function Ma(r,t=!1){if(r==="linear")return t?iA:rA;if(r==="relu")return t?lA:sA;if(r==="elu")return t?aA:nA;if(r==="relu6")return t?uA:oA;if(r==="prelu")return t?X_:K_;if(r==="leakyrelu")return t?H_:q_;throw new Error(`Activation ${r} has not been implemented for the WebGL backend.`)}var xf=class{constructor(t,e,n,s=!1,o=!1,a=!1,l=null,u=!1,p=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n;let f=s?t[1]:t[2],m=Math.ceil(f/2),d=s?"i * 2, rc.y":"rc.y, i * 2",y=o?"rc.z, i * 2":"i * 2, rc.z",_=s?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],v=o?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"],C="",N="";l&&(u?C=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${l}
        }`:p?C=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${l}
        }`:C=`vec4 activation(vec4 x) {
          ${l}
        }`,N="result = activation(result);");let A=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),u&&this.variableNames.push("preluActivationWeights"),p&&this.variableNames.push("leakyreluAlpha");let B="rc.x",P="rc.x";t[0]<e[0]?B=`int(min(float(rc.x), ${t[0]-1}.))`:e[0]<t[0]&&(P=`int(min(float(rc.x), ${e[0]-1}.))`),this.userCode=`
      ${C}

      const float sharedDimension = ${m}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${m}; i++) {
          int batchA = ${B};
          int batchB = ${P};
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${y});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${_[0]} * ${v[0]});
          result += (${_[1]} * ${v[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${A}

        ${N}

        setOutput(result);
      }
    `}};var Y_={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"},rg=class{constructor(t,e,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=H.assertAndGetBroadcastShape(e,n),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${t}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};var gA="return a * b;";function Z_(r){let{inputs:t,backend:e}=r,{a:n,b:s}=t,o=H.upcastType(n.dtype,s.dtype);if(n.dtype==="complex64"){let l=e.texData.get(n.dataId),u=e.texData.get(s.dataId),p=new rg(Y_.REAL,n.shape,s.shape),f=new rg(Y_.IMAG,n.shape,s.shape),m=[{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:n.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:n.shape},{dataId:u.complexTensorInfos.real.dataId,dtype:u.complexTensorInfos.real.dtype,shape:s.shape},{dataId:u.complexTensorInfos.imag.dataId,dtype:u.complexTensorInfos.imag.dtype,shape:s.shape}],d=e.runWebGLProgram(p,m,"float32"),y=e.runWebGLProgram(f,m,"float32"),_=Nn({inputs:{real:d,imag:y},backend:e});return e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(y),_}if(e.shouldExecuteOnCPU([n,s])){let l=e.texData.get(n.dataId),u=e.texData.get(s.dataId),[p,f]=VE(n.shape,s.shape,l.values,u.values,o),m=e.makeTensorInfo(f,o),d=e.texData.get(m.dataId);return d.values=p,m}let a;return vt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Ps(gA,n.shape,s.shape):a=new fs(gA,n.shape,s.shape),e.runWebGLProgram(a,[n,s],o)}var xA={kernelName:Oo,backendName:"webgl",kernelFunc:Z_};function yA(r,t,e){let n=[Pa(r.shape),...La(r.shape)],s={dtype:r.dtype,shape:n,dataId:r.dataId},o=[Pa(t),...La(t)],a=new df(o,n),l=!0,u=e.runWebGLProgram(a,[s],r.dtype,null,l);return{dataId:u.dataId,shape:t,dtype:u.dtype}}function Gt(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{shape:o}=n,a=e,l=E.sizeFromShape(s.shape),u=E.inferFromImplicitShape(o,l),p=E.sizeFromShape(u);E.assert(l===p,()=>`The new shape (${u}) has ${p} elements and the old shape (${s.shape}) has ${l} elements. The new shape and old shape must have the same number of elements.`);let f=a.texData.get(s.dataId);return f.isPacked&&!Pl(s.shape,u)&&!(f.texture!==null&&Pl(f.shape,u))?yA(s,u,a):(a.incRef(s.dataId),{dataId:s.dataId,shape:u,dtype:s.dtype})}var _A={kernelName:na,backendName:"webgl",kernelFunc:Gt};var ng=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:s,inSize:o,outSize:a}=t;this.outputShape=[s,a];let l=Math.floor(n/4)*4,u=n%4,p="sumValue += dot(values, ones);";if(e!=null){let m=1/e;p=`sumValue += dot(values * ${E.isInt(m)?m.toPrecision(2):m}, ones);`}let f="";o%n>0&&(f=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        float sumValue = 0.0;

        for (int i = 0; i < ${l}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${p}
        }

        int inIdx = inOffset + ${l};
        if (${u===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${p}
        } else if (${u===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${p}
        } else if (${u===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${p}
        }
        setOutput(sumValue);
      }
    `}};var J_=class{constructor(t,e){this.variableNames=["x"];let{windowSize:n,batchSize:s,inSize:o,outSize:a}=t;this.outputShape=[s,a];let l="0.0",u="";e==="prod"?l="1.0":e==="min"?(l="1.0 / 1e-20",u="min"):e==="max"&&(l="-1.0 / 1e-20",u="max");let p=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="sum"?p="sumValue":e==="prod"?p="prodValue":e==="all"?p="allValue":e==="any"&&(p="anyValue");let f=Math.floor(n/4)*4,m=n%4,d=`
      if (${e==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${e==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${u}(values, minMaxValue);
      }
    `,y="vec4";e==="all"?(l="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,y="bvec4"):e==="any"&&(l="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,y="bvec4");let _="";o%n>0&&(_=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${l};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${_}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${n};

        vec4 minMaxValue = vec4(${l});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${f}; i += 4) {
          int inIdx = inOffset + i;
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${f};
        if (${m===1}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${m===2}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${m===3}) {
          ${y} values = ${y}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${p});
      }
    `}};function c5(r){let t=[];for(;t.length===0||t[t.length-1].outSize!==1;){let e=t.length?t[t.length-1].outSize:r[1],n=H.computeOptimalWindowSize(e);t.push({inSize:e,windowSize:n,outSize:Math.ceil(e/n)})}return t}function Pn(r,t,e,n){let s=c5(r.shape),o=r;for(let a=0;a<s.length;a++){let{inSize:l,windowSize:u,outSize:p}=s[a],f,m;e==="mean"?f=a===0?new ng({windowSize:u,inSize:l,batchSize:r.shape[0],outSize:p},l):new ng({windowSize:u,inSize:l,batchSize:r.shape[0],outSize:p}):f=new J_({windowSize:u,inSize:l,batchSize:r.shape[0],outSize:p},e),m=o,o=n.runWebGLProgram(f,[o],t),m.dataId!==r.dataId&&n.disposeIntermediateTensorInfo(m)}return o}var Q_=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let a=0;a<n.length;a++)n[a]=t[e[a]];this.outputShape=n,this.rank=n.length;let s=be(this.rank),o=p5(e);this.userCode=`
    void main() {
      ${s} resRC = getOutputCoords();
      setOutput(getA(${o}));
    }
    `}};function p5(r){let t=r.length;if(t>6)throw Error(`Transpose for rank ${t} is not yet supported`);let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],n=new Array(t);for(let s=0;s<r.length;s++)n[r[s]]=e[s];return n.join()}var tb=class{constructor(t,e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;let n=new Array(t.length);for(let f=0;f<n.length;f++)n[f]=t[e[f]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);let s=be(this.rank),o=B_("rc",this.rank),a=new Array(this.rank);for(let f=0;f<e.length;f++)a[e[f]]=o[f];let l=`vec2(${a.slice(-2).join()})`,u=`++${o[this.rank-1]} < ${n[this.rank-1]}`,p=`getChannel(getA(${a.join()}), ${l})`;this.userCode=`
    void main() {
      ${s} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${p};
      if(${u}) {
        result[1] = ${p};
      }
      --${o[this.rank-1]};
      if(++${o[this.rank-2]} < ${n[this.rank-2]}) {
        result[2] = ${p};
        if(${u}) {
          result[3] = ${p};
        }
      }
      setOutput(result);
    }
    `}};function Ba(r,t,e){let n=vt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tb(r.shape,t):new Q_(r.shape,t);return e.runWebGLProgram(n,[r],r.dtype)}function bA(r,t,e,n){let s=t,o=r.shape.length,a=E.parseAxisParam(s,r.shape),l=a,u=H.getAxesPermutation(l,o),p=u!=null,f=r;p&&(f=Ba(r,u,n),l=H.getInnerMostAxes(l.length,o)),H.assertAxesAreInnerMostDims("sum",l,o);let[m,d]=H.computeOutAndReduceShapes(f.shape,l),y=m;e&&(y=H.expandShapeToKeepDim(m,a));let _=E.sizeFromShape(d),C=E.sizeFromShape(r.shape)/_,N=Gt({inputs:{x:f},attrs:{shape:[C,_]},backend:n}),A=Lu(r.dtype),B=Pn(N,A,"sum",n),P=Gt({inputs:{x:B},attrs:{shape:y},backend:n});return n.disposeIntermediateTensorInfo(N),n.disposeIntermediateTensorInfo(B),p&&n.disposeIntermediateTensorInfo(f),P}function yf(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n;return bA(s,o,a,e)}var vA={kernelName:ua,backendName:"webgl",kernelFunc:yf};function yr(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{perm:o}=n,a=e,l=s.shape.length,u=new Array(l);for(let f=0;f<u.length;f++)u[f]=s.shape[o[f]];let p;if(a.shouldExecuteOnCPU([s])){let m=a.texData.get(s.dataId).values,d=Pc(m,s.shape,s.dtype,o,u);p=a.makeTensorInfo(u,s.dtype);let y=a.texData.get(p.dataId);y.values=d}else p=Ba(s,o,a);return p}var wA={kernelName:ha,backendName:"webgl",kernelFunc:yr};var eb=1e3;function zl({a:r,b:t,transposeA:e,transposeB:n,backend:s,bias:o=null,preluActivationWeights:a=null,leakyreluAlpha:l=0,activation:u=null}){let p=r.shape.length,f=t.shape.length,m=e?r.shape[p-2]:r.shape[p-1],d=n?t.shape[f-1]:t.shape[f-2],y=e?r.shape[p-1]:r.shape[p-2],_=n?t.shape[f-2]:t.shape[f-1],v=r.shape.slice(0,-2),C=t.shape.slice(0,-2),N=E.sizeFromShape(v),A=E.sizeFromShape(C),B=N===A||N===1||A===1;E.assert(p>=2&&f>=2&&B,()=>`Error in matMul: the input batch dimensions must either be the same or at least one input batch dimension must be 1. Got input batch dimensions of (${v}) and (${C}).`);let L=(N>A?r.shape.slice(0,-2):t.shape.slice(0,-2)).concat([y,_]);E.assert(m===d,()=>`Error in matMul: inner shapes (${m}) and (${d}) of Tensors with shapes ${r.shape} and ${t.shape} and transposeA=${e} and transposeB=${n} must match.`);let Z=e?[N,m,y]:[N,y,m],K=n?[A,_,d]:[A,d,_],et=Gt({inputs:{x:r},backend:s,attrs:{shape:Z}}),it=Gt({inputs:{x:t},backend:s,attrs:{shape:K}}),xt=[et,it],wt=Math.max(N,A),St=e?et.shape[1]:et.shape[2],yt=o!=null,Nt=a!=null,ht=u==="leakyrelu",It=u!=null?Ma(u,!0):null,Ft=yt||Nt||ht||It!=null,Ct;if((y===1||_===1)&&St>eb&&Ft===!1){let zt=et,Mt=it;e&&(zt=yr({inputs:{x:et},backend:s,attrs:{perm:[0,2,1]}}),xt.push(zt)),n&&(Mt=yr({inputs:{x:it},backend:s,attrs:{perm:[0,2,1]}}),xt.push(Mt));let jt=_!==1,qt=_===1,Bt=zt;jt&&(Bt=Gt({inputs:{x:zt},backend:s,attrs:{shape:[wt,St,1]}}),xt.push(Bt));let Ht=_===1?2:1,Zt=Mt;qt&&(Zt=Gt({inputs:{x:Mt},backend:s,attrs:{shape:[wt,1,St]}}),xt.push(Zt));let ne=Z_({inputs:{a:Bt,b:Zt},backend:s});Ct=yf({inputs:{x:ne},backend:s,attrs:{axis:Ht,keepDims:!0}}),xt.push(ne)}else{let zt=Br(r.dtype,t.dtype),Mt=new xf(Z,K,[wt,y,_],e,n,yt,It,Nt,ht),jt=[et,it];if(o!=null&&jt.push(o),Nt&&jt.push(a),ht){let qt=s.makeTensorInfo([],"float32",E.createScalarValue(l,"float32"));jt.push(qt),xt.push(qt)}Ct=s.runWebGLProgram(Mt,jt,zt)}let Dt=Gt({inputs:{x:Ct},backend:s,attrs:{shape:L}});xt.push(Ct);for(let zt of xt)s.disposeIntermediateTensorInfo(zt);return Dt}function f5(r){let{inputs:t,backend:e,attrs:n}=r,{a:s,b:o,bias:a,preluActivationWeights:l}=t,{transposeA:u,transposeB:p,activation:f,leakyreluAlpha:m}=n;return zl({a:s,b:o,transposeA:u,transposeB:p,backend:e,bias:a,preluActivationWeights:l,leakyreluAlpha:m,activation:f})}var CA={kernelName:il,backendName:"webgl",kernelFunc:f5};var kA="return abs(x);";function h5(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])&&n.dtype!=="complex64"){let o=e.texData.get(n.dataId),a=Jd(o.values);return e.makeTensorInfo(n.shape,n.dtype,a)}let s;return vt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Os(n.shape,kA):s=new In(n.shape,kA),e.runWebGLProgram(s,[n],n.dtype)}var SA={kernelName:ki,backendName:"webgl",kernelFunc:h5};var m5=Pr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,d5=re({opSnippet:m5}),IA={kernelName:ao,backendName:"webgl",kernelFunc:d5};var g5=Pr+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,x5=re({opSnippet:g5}),NA={kernelName:lo,backendName:"webgl",kernelFunc:x5};var TA="return a + b;",y5=Ge({opSnippet:TA,packedOpSnippet:TA,supportsComplex:!0,cpuKernelImpl:IE}),EA={kernelName:_s,backendName:"webgl",kernelFunc:y5};var rb=class{constructor(t,e){this.outputShape=[],this.outputShape=t,this.variableNames=e.map((o,a)=>`T${a}`);let n=[];this.variableNames.forEach(o=>{n.push(`float v${o} = get${o}AtOutCoords();`)});let s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        float result = ${s};
        setOutput(result);
      }
    `}};var nb=class{constructor(t,e){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.variableNames=e.map((o,a)=>`T${a}`);let n=[];this.variableNames.forEach(o=>{n.push(`vec4 v${o} = get${o}AtOutCoords();`)});let s=this.variableNames.map(o=>`v${o}`).join(" + ");this.userCode=`
      void main() {
        ${n.join(`
        `)}

        vec4 result = ${s};
        setOutput(result);
      }
    `}};function sg(r){let{inputs:t,backend:e}=r,n=t;if(n.length===1)return vr({inputs:{x:n[0]},backend:e});if(n.length>vt().get("WEBGL_MAX_TEXTURES_IN_SHADER")){let u=Math.floor(n.length/2),p=sg({inputs:n.slice(0,u),backend:e}),f=sg({inputs:n.slice(u),backend:e});return sg({inputs:[p,f],backend:e})}let s=n.map(u=>u.dtype).reduce((u,p)=>Br(u,p)),o=n.map(u=>u.shape),l=vt().getBool("WEBGL_PACK")?new nb(n[0].shape,o):new rb(n[0].shape,o);return e.runWebGLProgram(l,n,s)}var AA={kernelName:su,backendName:"webgl",kernelFunc:sg};function _5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n,l=s.shape.length,u=E.parseAxisParam(o,s.shape),p=u,f=H.getAxesPermutation(p,l),m=s;f!=null&&(m=yr({inputs:{x:s},backend:e,attrs:{perm:f}}),p=H.getInnerMostAxes(p.length,l)),H.assertAxesAreInnerMostDims("all",p,l);let[d,y]=H.computeOutAndReduceShapes(m.shape,p),_=E.sizeFromShape(y),v=Gt({inputs:{x:m},backend:e,attrs:{shape:[-1,_]}}),C=Pn(v,v.dtype,"all",e),N;if(a){let A=H.expandShapeToKeepDim(d,u);N=Gt({inputs:{x:C},backend:e,attrs:{shape:A}})}else N=Gt({inputs:{x:C},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(C),f!=null&&e.disposeIntermediateTensorInfo(m),N}var $A={kernelName:ou,backendName:"webgl",kernelFunc:_5};function b5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n,l=s.shape.length,u=E.parseAxisParam(o,s.shape),p=u,f=H.getAxesPermutation(p,l),m=s;f!=null&&(m=yr({inputs:{x:s},backend:e,attrs:{perm:f}}),p=H.getInnerMostAxes(p.length,l)),H.assertAxesAreInnerMostDims("any",p,l);let[d,y]=H.computeOutAndReduceShapes(m.shape,p),_=E.sizeFromShape(y),v=Gt({inputs:{x:m},backend:e,attrs:{shape:[-1,_]}}),C=Pn(v,v.dtype,"any",e),N;if(a){let A=H.expandShapeToKeepDim(d,u);N=Gt({inputs:{x:C},backend:e,attrs:{shape:A}})}else N=Gt({inputs:{x:C},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(C),f!=null&&e.disposeIntermediateTensorInfo(m),N}var DA={kernelName:iu,backendName:"webgl",kernelFunc:b5};var sb=class{constructor(t,e,n){this.variableNames=["A"];let{windowSize:s,batchSize:o,outSize:a}=t;n||this.variableNames.push("bestIndicesA"),this.outputShape=[o,a];let l=e==="max"?">":"<",u=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${s}; i++) {
          int inIdx = ${u};
          float candidate = getA(batch, inIdx);
          if (candidate ${l} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}};var ob=class{constructor(t,e,n,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,E.assert(t.length>2,()=>`Packed arg${n.charAt(0).toUpperCase()+n.slice(1)} supports only inputs with rank above 2.`);let o=t[t.length-1],a=Math.ceil(o/e);this.outputShape=t.slice(0,-1),a>1&&this.outputShape.push(a),s||this.variableNames.push("bestIndicesA");let l=this.outputShape,u=l.length,p=be(u),f=br("coords",u),m,d;if(a===1){d=u+1;let et=be(d);m=`
        ${et} sourceLocR = ${et}(${f.join()}, 0);
        ++${f[u-1]};
        ${et} sourceLocG = ${et}(${f.join()}, 0);
        ++${f[u-2]};
        ${et} sourceLocA = ${et}(${f.join()}, 0);
        --${f[u-1]};
        ${et} sourceLocB = ${et}(${f.join()}, 0);
        --${f[u-2]};`}else d=u,m=`
        ${p} sourceLocR = coords;
        ++${f[u-1]};
        ${p} sourceLocG = coords;
        ++${f[u-2]};
        ${p} sourceLocA = coords;
        --${f[u-1]};
        ${p} sourceLocB = coords;
        --${f[u-2]};`;let y=["x","y","z","w","u","v"].slice(0,d),_="."+y[d-1],v=y.map(et=>"int "+et),C=br("sourceLocR",d-1).concat("inIdx.r"),N=br("sourceLocG",d-1).concat("inIdx.g"),A=br("sourceLocB",d-1).concat("inIdx.b"),B=br("sourceLocA",d-1).concat("inIdx.a"),P=n==="max"?"greaterThan":"lessThan",L=s?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${C.join()}),
                             getBestIndicesAChannel(${N.join()}),
                             getBestIndicesAChannel(${A.join()}),
                             getBestIndicesAChannel(${B.join()})));`,Z=`vec4(
            getAChannel(${C.join()}),
            hasNextCol ? getAChannel(${N.join()}) : 0.,
            hasNextRow ? getAChannel(${A.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${B.join()}) : 0.)`,K=s?"":`
      float getBestIndicesAChannel(${v.join()}) {
        return getChannel(getBestIndicesA(${y.join()}),
                                          vec2(${y.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${v.join()}) {
        return getChannel(getA(${y.join()}),
                               vec2(${y.slice(-2).join()}));
      }
      ${K}
      void main() {
        ${p} coords = getOutputCoords();
        bool hasNextCol = ${f[u-1]} < ${l[u-1]-1};
        bool hasNextRow = ${f[u-2]} < ${l[u-2]-1};
        ${m}
        ivec4 srcIdx = ivec4(sourceLocR${_}, sourceLocG${_},
          sourceLocB${_}, sourceLocA${_}) * ${e};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${Z};

        for (int i = 0; i < ${e}; i++) {
          inIdx = srcIdx;
          ${L}
          vec4 candidate = ${Z};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${P}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}};function RA(r,t,e,n=null){let s=t.shape[0],o=t.shape[1];n!=null&&(s=n.shape[0],o=n.shape[1]);let a=H.computeOptimalWindowSize(o),l={windowSize:a,inSize:o,batchSize:s,outSize:Math.ceil(o/a)},u=new sb(l,e,n==null),p=[t];n!=null&&p.push(n);let f=r.runWebGLProgram(u,p,"int32");if(f.shape[1]===1)return f;let m=RA(r,t,e,f);return r.disposeIntermediateTensorInfo(f),m}function FA(r,t,e,n=null){let s=n!=null?n.shape:t.shape,o=s[s.length-1],a=H.computeOptimalWindowSize(o),l=new ob(s,a,e,n==null),u=n==null?[t]:[t,n],p=r.runWebGLProgram(l,u,"int32");if(p.shape.length===t.shape.length){let f=FA(r,t,e,p);return r.disposeIntermediateTensorInfo(p),f}return p}function og(r,t,e,n){let s=[e];if(H.assertAxesAreInnerMostDims("arg"+n.charAt(0).toUpperCase()+n.slice(1),s,t.shape.length),!vt().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){let o=[],[a,l]=H.computeOutAndReduceShapes(t.shape,s),u=E.sizeFromShape(l),p=Gt({inputs:{x:t},backend:r,attrs:{shape:[-1,u]}});o.push(p);let f=RA(r,p,n);o.push(f);let m=Gt({inputs:{x:f},backend:r,attrs:{shape:a}});return o.forEach(d=>r.disposeIntermediateTensorInfo(d)),m}return FA(r,t,n)}function v5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o}=n,a=E.parseAxisParam(o,s.shape),l=H.getAxesPermutation(a,s.shape.length),u=s,p=[];l!=null&&(u=yr({inputs:{x:s},backend:e,attrs:{perm:l}}),p.push(u),a=H.getInnerMostAxes(a.length,u.shape.length)),H.assertAxesAreInnerMostDims("argMax",[a[0]],u.shape.length);let f=og(e,u,a[0],"max");return p.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}var OA={kernelName:Si,backendName:"webgl",kernelFunc:v5};function w5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o}=n,a=E.parseAxisParam(o,s.shape),l=H.getAxesPermutation(a,s.shape.length),u=s,p=[];l!=null&&(u=yr({inputs:{x:s},backend:e,attrs:{perm:l}}),p.push(u),a=H.getInnerMostAxes(a.length,u.shape.length)),H.assertAxesAreInnerMostDims("argMin",[a[0]],u.shape.length);let f=og(e,u,a[0],"min");return p.forEach(m=>e.disposeIntermediateTensorInfo(m)),f}var PA={kernelName:Ii,backendName:"webgl",kernelFunc:w5};var C5=Pr+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,k5=re({opSnippet:C5}),LA={kernelName:uo,backendName:"webgl",kernelFunc:k5};var S5=Pr+"return log(x + sqrt(x * x + 1.0));",I5=re({opSnippet:S5}),zA={kernelName:co,backendName:"webgl",kernelFunc:I5};var N5=Pr+`
  return atan(x);
`,T5=re({opSnippet:N5}),MA={kernelName:po,backendName:"webgl",kernelFunc:T5};var E5=mA+`
  return atan(a, b);
`,A5=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+dA+`
  return result;
`,$5=Ge({opSnippet:E5,packedOpSnippet:A5}),BA={kernelName:ho,backendName:"webgl",kernelFunc:$5};var D5=Pr+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,R5=re({opSnippet:D5}),VA={kernelName:fo,backendName:"webgl",kernelFunc:R5};var so=class{constructor(t,e,n,s=!1,o=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=t.filterWidth,l=t.strideHeight,u=t.strideWidth,p=t.dilationHeight,f=t.dilationWidth,m=t.effectiveFilterHeight,d=t.effectiveFilterWidth,y=t.padInfo.top,_=t.padInfo.left;this.outputShape=t.outShape;let v=e==="avg",C=`((batch  * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + d`,N=`(xR * ${t.inWidth} + xC) * ${t.inChannels} + d`,A="0.0";if(v||(A="-1.0 / 1e-20"),n){let et=">=";this.userCode=`
        const ivec2 strides = ivec2(${l}, ${u});
        const ivec2 pads = ivec2(${y}, ${_});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${m};
              wR += ${p}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${f}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${et} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${s?o?C:N:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let B="max",P=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(P="avgValue / count");let L=Math.floor(a/4)*4,Z=a%4,K=`
      if (${v}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${B}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${l}, ${u});
      const ivec2 pads = ivec2(${y}, ${_});
      const float initializationValue = ${A};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${A});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${m};
            wR += ${p}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${L}; wC += 4) {
            int xC = xCCorner + wC * ${f};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              getValue(batch, xR, xC + 2 * ${f}, d),
              getValue(batch, xR, xC + 3 * ${f}, d)
            );

            ${K}
          }

          int xC = xCCorner + ${L};
          if (${Z===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${K}
          } else if (${Z===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              initializationValue,
              initializationValue
            );

            ${K}
          } else if (${Z===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${f}, d),
              getValue(batch, xR, xC + 2 * ${f}, d),
              initializationValue
            );

            ${K}
          }
        }
        setOutput(${P});
      }
    `}},Ml=class{constructor(t,e,n,s=!1,o=!1){if(this.variableNames=["x"],e==="avg"&&n)throw new Error("Cannot compute positions for average pool.");let a=t.filterWidth,l=t.strideDepth,u=t.strideHeight,p=t.strideWidth,f=t.dilationDepth,m=t.dilationHeight,d=t.dilationWidth,y=t.effectiveFilterDepth,_=t.effectiveFilterHeight,v=t.effectiveFilterWidth,C=t.padInfo.front,N=t.padInfo.top,A=t.padInfo.left;this.outputShape=t.outShape;let B=e==="avg",P="0.0";if(B||(P="-1.0 / 1e-20"),n){let xt=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${l}, ${u}, ${p});
        const ivec3 pads = ivec3(${C}, ${N}, ${A});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${y};
              wD += ${f}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${t.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${_};
                wR += ${m}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${v};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${xt} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${s?o?`(((batch * ${t.inDepth} + xD) * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`((xD * ${t.inHeight} + xR) * ${t.inWidth} + xC) * ${t.inChannels} + ch`:`wD * ${_} * ${v} +
                      wR * ${v} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}let L="max",Z=`${e}(${e}(${e}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;e==="avg"&&(Z="avgValue / count");let K=Math.floor(a/4)*4,et=a%4,it=`
      if (${B}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${L}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${l}, ${u}, ${p});
      const ivec3 pads = ivec3(${C}, ${N}, ${A});
      const float initializationValue = ${P};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${t.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${P});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${y};
            wD += ${f}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${_};
            wR += ${m}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${K}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${it}
            }

            int xC = xCCorner + ${K};
            if (${et===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${it}
            } else if (${et===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${it}
            } else if (${et===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${it}
            }
          }
          setOutput(${Z});
        }
      }
    `}};function F5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t;no(s,"avgPool");let{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=n,p=1;E.assert(H.eitherStridesOrDilationsAreOne(a,p),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let f=H.computePool2DInfo(s.shape,o,a,p,l,u);if(f.filterWidth===1&&f.filterHeight===1&&E.arraysEqual(f.inShape,f.outShape))return vr({inputs:{x:s},backend:e});let m=new so(f,"avg",!1);return e.runWebGLProgram(m,[s],"float32")}var GA={kernelName:Ni,backendName:"webgl",kernelFunc:F5};function O5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{filterSize:o,strides:a,pad:l,dimRoundingMode:u,dataFormat:p}=n,f=[1,1,1],m=H.computePool3DInfo(s.shape,o,a,f,l,u,p),d=new Ml(m,"avg",!1);return e.runWebGLProgram(d,[s],"float32")}var WA={kernelName:Ti,backendName:"webgl",kernelFunc:O5};var ib=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,s=t.strideHeight,o=t.strideWidth,a=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterHeight,p=t.effectiveFilterWidth,f=u-1-t.padInfo.top,m=p-1-t.padInfo.left,d=1/(e*n);this.userCode=`
      const ivec2 pads = ivec2(${f}, ${m});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${u};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${p};
            wC+= ${l}) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}},ab=class{constructor(t){this.variableNames=["dy"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,s=t.filterWidth,o=t.strideDepth,a=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,p=t.dilationHeight,f=t.dilationWidth,m=t.effectiveFilterDepth,d=t.effectiveFilterHeight,y=t.effectiveFilterWidth,_=m-1-t.padInfo.front,v=d-1-t.padInfo.top,C=y-1-t.padInfo.left,N=1/(e*n*s);this.userCode=`
      const ivec3 pads = ivec3(${_}, ${v}, ${C});
      const float avgMultiplier = float(${N});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${m};
            wD += ${u}) {
          float dyD = float(dyDCorner + wD) / ${o}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${p}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${y};
                wC += ${f}) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function P5(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,input:o}=t,a=o,{filterSize:l,strides:u,pad:p,dimRoundingMode:f}=n,m=[1,1,1],d=H.computePool3DInfo(a.shape,l,u,m,p,f),y=new ab(d);return e.runWebGLProgram(y,[s],a.dtype)}var UA={kernelName:lu,backendName:"webgl",kernelFunc:P5};function L5(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,input:o}=t,a=o;no([s,o],"avgPoolGrad");let{filterSize:l,strides:u,pad:p}=n,f=H.computePool2DInfo(a.shape,l,u,1,p),m=new ib(f);return e.runWebGLProgram(m,[s],a.dtype)}var jA={kernelName:au,backendName:"webgl",kernelFunc:L5};function z5(r){let{inputs:t,backend:e,attrs:n}=r,{a:s,b:o}=t,{transposeA:a,transposeB:l}=n;return zl({a:s,b:o,transposeA:a,transposeB:l,backend:e})}var qA={kernelName:Ei,backendName:"webgl",kernelFunc:z5};var lb=class{constructor(t,e,n,s,o,a){this.outputShape=[],this.variableNames=["x","mean","variance"],H.assertAndGetBroadcastShape(t,e),H.assertAndGetBroadcastShape(t,n);let l="0.0";s!=null&&(H.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let u="1.0";o!=null&&(H.assertAndGetBroadcastShape(t,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${l};
        float scale = ${u};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}};var ub=class{constructor(t,e,n,s,o,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],H.assertAndGetBroadcastShape(t,e),H.assertAndGetBroadcastShape(t,n);let l="vec4(0.0)";s!=null&&(H.assertAndGetBroadcastShape(t,s),this.variableNames.push("offset"),l="getOffsetAtOutCoords()");let u="vec4(1.0)";o!=null&&(H.assertAndGetBroadcastShape(t,o),this.variableNames.push("scale"),u="getScaleAtOutCoords()"),this.outputShape=t,this.userCode=`
      void main() {
        vec4 offset = ${l};
        vec4 scale = ${u};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}};var M5=({inputs:r,backend:t,attrs:e})=>{let{x:n,mean:s,variance:o,offset:a,scale:l}=r;E.assert(s.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E.assert(a==null||s.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E.assert(l==null||s.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:u}=e;u==null&&(u=.001);let p=[n,s,o],f=null;a!=null&&(f=a.shape,p.push(a));let m=null;l!=null&&(m=l.shape,p.push(l));let d=vt().getBool("WEBGL_PACK_NORMALIZATION")?new ub(n.shape,s.shape,o.shape,f,m,u):new lb(n.shape,s.shape,o.shape,f,m,u);return t.runWebGLProgram(d,p,p[0].dtype)},HA={kernelName:Bi,backendName:"webgl",kernelFunc:M5};var cb=class{constructor(t){this.variableNames=["source"],this.outputShape=t,this.rank=t.length;let e=be(this.rank),n=`uniform int start[${this.rank}];`,s=B5(this.rank),o,a=t.map((l,u)=>`sourceLoc.${pb[u]} = start[${u}] + coords.${pb[u]};`);o=`
        ${e} sourceLoc;
        ${e} coords = getOutputCoords();
        ${a.join(`
`)}
      `,this.userCode=`
      ${n}
      void main() {
        ${o}
        setOutput(getSource(${s}));
      }
    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{this.startLoc==null&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),this.startLoc==null)||e.gl.uniform1iv(this.startLoc,t)}}},pb=["x","y","z","w","u","v"];function B5(r){if(r===1)return"sourceLoc";if(r<=6)return pb.slice(0,r).map(t=>"sourceLoc."+t).join(",");throw Error(`Slicing for rank ${r} is not yet supported`)}var fb=class{constructor(t){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.rank=t.length;let e=be(this.rank),n=br("coords",this.rank),s=br("sourceLoc",this.rank),o=this.rank===1?"sourceLoc":`vec2(${s.slice(-2).join()})`,a=`getChannel(getSource(${s.join()}), ${o})`,l=`
      result.x = ${a};
      if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
        ++${s[this.rank-1]};
        result.y = ${a};
        --${s[this.rank-1]};
      }
    `,u=this.rank===1?"":`
      --${n[this.rank-1]};
      if (++${n[this.rank-2]} < ${t[this.rank-2]}) {
        ++${s[this.rank-2]};
        result.z = ${a};
        if (++${n[this.rank-1]} < ${t[this.rank-1]}) {
          ++${s[this.rank-1]};
          result.w = ${a};
        }
      }
    `,p=this.rank<=4?`sourceLoc = coords +
            ${e}(${t.map((f,m)=>`start[${m}]`).join()});`:t.map((f,m)=>`${s[m]} = ${n[m]} + start[${m}];`).join(`
`);this.userCode=`
      uniform int start[${this.rank}];
      void main() {
        ${e} coords = getOutputCoords();
        ${e} sourceLoc;
        ${p}
        vec4 result = vec4(0.);
        ${l}
        ${u}
        setOutput(result);
      }
    `}getCustomSetupFunc(t){if(t.length!==this.rank)throw Error(`The rank (${this.rank}) of the program must match the length of start (${t.length})`);return(e,n)=>{this.startLoc==null&&(this.startLoc=e.getUniformLocationNoThrow(n,"start"),this.startLoc==null)||e.gl.uniform1iv(this.startLoc,t)}}};function V5(r,t,e,n){let s=n.texData.get(r.dataId),o=n.makeTensorInfo(e,r.dtype),a=n.texData.get(o.dataId);Object.assign(a,s),a.complexParentRefCount=0,a.refCount=1,a.shape=e,a.dtype=r.dtype;let l=pn.computeFlatOffset(t,E.computeStrides(r.shape));s.slice&&(l+=s.slice.flatOffset),a.slice={flatOffset:l,origDataId:s.slice&&s.slice.origDataId||r.dataId};let u=n.dataRefCount.get(a.slice.origDataId)||1;return n.dataRefCount.set(a.slice.origDataId,u+1),o}function xi(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{begin:o,size:a}=n,[l,u]=pn.parseSliceParams(s,o,a);if(pn.assertParamsValid(s,l,u),E.sizeFromShape(u)===0)return e.makeTensorInfo(u,s.dtype,[]);if(e.shouldExecuteOnCPU([s])||s.dtype==="string"){let m=e.texData.get(s.dataId),d=qE(m.values,l,u,s.shape,s.dtype);return e.makeTensorInfo(u,s.dtype,d)}let{isPacked:p}=e.texData.get(s.dataId),f=pn.isSliceContinous(s.shape,l,u);if(p||!f){let m=vt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new fb(u):new cb(u),d=m.getCustomSetupFunc(l);return e.runWebGLProgram(m,[s],s.dtype,d)}return e.uploadToGPU(s.dataId),V5(s,l,u,e)}var KA={kernelName:la,backendName:"webgl",kernelFunc:xi};var G5=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{blockShape:o,crops:a}=n;E.assert(s.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");let l=o.reduce((A,B)=>A*B),u=H.getReshaped(s.shape,o,l),p=H.getPermuted(u.length,o.length),f=H.getReshapedPermuted(s.shape,o,l),m=H.getSliceBeginCoords(a,o.length),d=H.getSliceSize(f,a,o.length),y=[],_=Gt({inputs:{x:s},backend:e,attrs:{shape:u}}),v=yr({inputs:{x:_},backend:e,attrs:{perm:p}}),C=Gt({inputs:{x:v},backend:e,attrs:{shape:f}}),N=xi({inputs:{x:C},backend:e,attrs:{begin:m,size:d}});return y.push(_),y.push(v),y.push(C),y.forEach(A=>e.disposeIntermediateTensorInfo(A)),N},XA={kernelName:Ai,backendName:"webgl",kernelFunc:G5};function W5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,weights:o}=t,{size:a}=n,l=e.readSync(s.dataId),u=e.readSync(o.dataId),p=Zd(l,u,o.dtype,o.shape,a);return e.makeTensorInfo([a],o.dtype,p)}var YA={kernelName:Xf,backendName:"webgl",kernelFunc:W5};var U5="return float(a != b);",hb=Ge({opSnippet:U5,dtype:"bool"}),ZA={kernelName:ol,backendName:"webgl",kernelFunc:hb};function yi(r){let{inputs:t,backend:e}=r,{input:n}=t,s=e.texData.get(n.dataId);return vr({inputs:{x:s.complexTensorInfos.real},backend:e})}var JA={kernelName:Iu,backendName:"webgl",kernelFunc:yi};var j5="return float(int(x));";function QA(r,t){let e=new In(r.shape,j5),n=t.runWebGLProgram(e,[r],"int32");return{dataId:n.dataId,shape:n.shape,dtype:n.dtype}}function mb(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{dtype:o}=n;if(o==="complex64"){if(s.dtype==="complex64")return vr({inputs:{x:s},backend:e});let a=lr(s.shape),l=mb({inputs:{x:s},backend:e,attrs:{dtype:"float32"}}),u=Nn({inputs:{real:l,imag:a},backend:e});return a.dispose(),e.disposeIntermediateTensorInfo(l),u}if(s.dtype==="complex64"){let a=yi({inputs:{input:s},backend:e}),l=mb({inputs:{x:a},backend:e,attrs:{dtype:o}});return e.disposeIntermediateTensorInfo(a),l}if(!E.hasEncodingLoss(s.dtype,o)){let a=vr({inputs:{x:s},backend:e});return{dataId:a.dataId,shape:a.shape,dtype:o}}if(o==="int32")return QA(s,e);if(o==="bool"){let a=e.makeTensorInfo([],"bool",E.getTypedArrayFromDType("bool",1)),u=hb({inputs:{a:s,b:a},backend:e});return e.disposeIntermediateTensorInfo(a),u}throw new Error(`Error in Cast: failed to cast ${s.dtype} to ${o}`)}var t$={kernelName:Ws,backendName:"webgl",kernelFunc:mb};var e$="return ceil(x);",q5=re({opSnippet:e$,packedOpSnippet:e$,cpuKernelImpl:TE}),r$={kernelName:mo,backendName:"webgl",kernelFunc:q5};var db=class{constructor(t){this.variableNames=["A"],this.outputShape=t,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}getCustomSetupFunc(t,e){return(n,s)=>{this.minLoc==null&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}};var gb=class{constructor(t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t,this.userCode=`
      uniform float minVal;
      uniform float maxVal;

      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}getCustomSetupFunc(t,e){return(n,s)=>{this.minLoc==null&&(this.minLoc=n.getUniformLocationNoThrow(s,"minVal"),this.maxLoc=n.getUniformLocationNoThrow(s,"maxVal")),n.gl.uniform1f(this.minLoc,t),n.gl.uniform1f(this.maxLoc,e)}}};function H5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{clipValueMin:o,clipValueMax:a}=n,l;vt().getBool("WEBGL_PACK_CLIP")?l=new gb(s.shape):l=new db(s.shape);let u=l.getCustomSetupFunc(o,a);return e.runWebGLProgram(l,[s],s.dtype,u)}var n$={kernelName:go,backendName:"webgl",kernelFunc:H5};var xb=class{constructor(t){this.variableNames=["real","imag"],this.outputShape=t,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}};function s$(r,t){return{dataId:t.dataId,dtype:t.dtype,shape:r.shape}}function K5(r){let{inputs:t,backend:e}=r,{x:n}=t,s=e.texData.get(n.dataId),o=new xb(n.shape),a=[s$(n,s.complexTensorInfos.real),s$(n,s.complexTensorInfos.imag)];return e.runWebGLProgram(o,a,a[0].dtype)}var o$={kernelName:$i,backendName:"webgl",kernelFunc:K5};var yb=class{constructor(t){this.outputShape=[],this.outputShape=H.computeOutShape(t,1),this.variableNames=t.map((a,l)=>`T${l}`);let e=new Array(t.length-1);e[0]=t[0][1];for(let a=1;a<e.length;a++)e[a]=e[a-1]+t[a][1];let n=[`if (yC < ${e[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<e.length;a++){let l=e[a-1];n.push(`else if (yC < ${e[a]}) setOutput(getT${a}(yR, yC-${l}));`)}let s=e.length,o=e[e.length-1];n.push(`else setOutput(getT${s}(yR, yC-${o}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${n.join(`
        `)}
      }
    `}};var _b=class{constructor(t,e){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=H.computeOutShape(t,e);let n=this.outputShape,s=n.length,o=be(s),a=br("coords",s),l=["x","y","z","w","u","v"].slice(0,s);this.variableNames=t.map((v,C)=>`T${C}`);let u=new Array(t.length-1);u[0]=t[0][e];for(let v=1;v<u.length;v++)u[v]=u[v-1]+t[v][e];let p=l[e],f=l.slice(-2),m=l.join(),d=`if (${p} < ${u[0]}) {
        return getChannel(
            getT0(${m}), vec2(${f.join()}));
        }`;for(let v=1;v<u.length;v++){let C=u[v-1];d+=`
        if (${p} < ${u[v]}  && ${p} >= ${u[v-1]}) {
          return getChannel(
            getT${v}(${ig(l,p,C)}),
            vec2(${ig(f,p,C)}));
        }`}let y=u.length,_=u[u.length-1];d+=`
        return getChannel(
          getT${y}(${ig(l,p,_)}),
          vec2(${ig(f,p,_)}));`,this.userCode=`
      float getValue(${l.map(v=>"int "+v)}) {
        ${d}
      }

      void main() {
        ${o} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[s-1]} = ${a[s-1]} + 1;
        if (${a[s-1]} < ${n[s-1]}) {
          result.g = getValue(${a});
        }

        ${a[s-2]} = ${a[s-2]} + 1;
        if (${a[s-2]} < ${n[s-2]}) {
          result.a = getValue(${a});
        }

        ${a[s-1]} = ${a[s-1]} - 1;
        if (${a[s-2]} < ${n[s-2]} &&
            ${a[s-1]} < ${n[s-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}};function ig(r,t,e){let n=r.indexOf(t);return r.map((o,a)=>a===n?`${o} - ${e}`:o).join()}function Bl(r){let{inputs:t,backend:e}=r,{input:n}=t,s=e.texData.get(n.dataId);return vr({inputs:{x:s.complexTensorInfos.imag},backend:e})}var i$={kernelName:bu,backendName:"webgl",kernelFunc:Bl};function Vl(r,t,e){let n=r[0].dtype;if(n==="complex64"){let p=r.map(_=>yi({inputs:{input:_},backend:e})),f=r.map(_=>Bl({inputs:{input:_},backend:e})),m=Vl(p,t,e),d=Vl(f,t,e),y=Nn({inputs:{real:m,imag:d},backend:e});return p.forEach(_=>e.disposeIntermediateTensorInfo(_)),f.forEach(_=>e.disposeIntermediateTensorInfo(_)),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(d),y}if(n==="string"){let{tensors2D:p,outShape:f}=a$(r,t,e),m=p.map(C=>({vals:e.readSync(C.dataId),shape:C.shape})),d=p[0].shape[0]===1,y=EE(m,f,n,d),_=H.computeOutShape(r.map(C=>C.shape),t),v=e.makeTensorInfo(_,n,y);return p.forEach(C=>e.disposeIntermediateTensorInfo(C)),v}if(r.length>vt().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){let p=Math.floor(r.length/2),f=Vl(r.slice(0,p),t,e),m=Vl(r.slice(p),t,e),d=Vl([f,m],t,e);return e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),d}if(vt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1){let p=new _b(r.map(f=>f.shape),t);return e.runWebGLProgram(p,r,n)}let{tensors2D:s,outShape:o}=a$(r,t,e),a=new yb(s.map(p=>p.shape)),l=e.runWebGLProgram(a,s,n);s.forEach(p=>e.disposeIntermediateTensorInfo(p));let u=Gt({inputs:{x:l},attrs:{shape:o},backend:e});return e.disposeIntermediateTensorInfo(l),u}function a$(r,t,e){let n=H.computeOutShape(r.map(o=>o.shape),t);return{tensors2D:r.map(o=>Gt({inputs:{x:o},attrs:{shape:[-1,E.sizeFromShape(o.shape.slice(t))]},backend:e})),outShape:n}}function bb(r){let{inputs:t,backend:e,attrs:n}=r,{axis:s}=n,o=E.parseAxisParam(s,t[0].shape)[0],a=H.computeOutShape(t.map(p=>p.shape),o);if(E.sizeFromShape(a)===0)return e.makeTensorInfo(a,t[0].dtype,[]);let l=t.filter(p=>E.sizeFromShape(p.shape)>0);if(l.length===1)return vr({inputs:{x:l[0]},backend:e});let u=l.map(p=>p.shape);return H.assertParamsConsistent(u,o),Vl(l,o,e)}var l$={kernelName:Di,backendName:"webgl",kernelFunc:bb};var _f=class{constructor(t,e=!1,n=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let a=t.padInfo.top,l=t.padInfo.left,u=t.strideHeight,p=t.strideWidth,f=t.dilationHeight,m=t.dilationWidth,d=t.filterHeight,y=t.filterWidth,_=Math.floor(t.inChannels/4)*4,v=t.inChannels%4,C=t.dataFormat==="channelsLast",N=C?1:2,A=C?2:3,B=C?3:1,P="",L="";n&&(s?P=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:o?P=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:P=`
          float activation(float x) {
            ${n}
          }
        `,L="result = activation(result);");let Z=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${P}

      const ivec2 strides = ivec2(${u}, ${p});
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${B}];

        ivec2 xRCCorner =
            ivec2(coords[${N}], coords[${A}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${f};

          if (xR < 0 || xR >= ${t.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${y}; wC++) {
            int xC = xCCorner + wC * ${m};

            if (xC < 0 || xC >= ${t.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${_}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${C}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${v===1}) {

              if (${C}) {
                dotProd +=
                    getX(batch, xR, xC, ${_}) *
                    getW(wR, wC, ${_}, d2);
              } else {
                dotProd +=
                    getX(batch, ${_}, xR, xC) *
                    getW(wR, wC, ${_}, d2);
              }

            } else if (${v===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${_}, d2),
                getW(wR, wC, ${_} + 1, d2)
              );

              if (${C}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${_}),
                  getX(batch, xR, xC, ${_} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${_}, xR, xC),
                  getX(batch, ${_} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${v===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${_}, d2),
                getW(wR, wC, ${_} + 1, d2),
                getW(wR, wC, ${_} + 2, d2)
              );

              if (${C}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${_}),
                  getX(batch, xR, xC, ${_} + 1),
                  getX(batch, xR, xC, ${_} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${_}, xR, xC),
                  getX(batch, ${_} + 1, xR, xC),
                  getX(batch, ${_} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${Z}
        ${L}
        setOutput(result);
      }
    `}},vb=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let e=t.padInfo.front,n=t.padInfo.top,s=t.padInfo.left,o=t.strideDepth,a=t.strideHeight,l=t.strideWidth,u=t.dilationDepth,p=t.dilationHeight,f=t.dilationWidth,m=t.filterDepth,d=t.filterHeight,y=t.filterWidth,_=Math.floor(t.inChannels/4)*4,v=t.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${o}, ${a}, ${l});
      const ivec3 pads = ivec3(${e}, ${n}, ${s});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${m}; wF++) {
          int xF = xFCorner + wF * ${u};

          if (xF < 0 || xF >= ${t.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${p};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${y}; wC++) {
              int xC = xCCorner + wC * ${f};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${_}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${v===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${_}) *
                  getW(wF, wR, wC, ${_}, d2);
              } else if (${v===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${_}),
                  getX(batch, xF, xR, xC, ${_} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${_}, d2),
                  getW(wF, wR, wC, ${_} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${v===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${_}),
                  getX(batch, xF, xR, xC, ${_} + 1),
                  getX(batch, xF, xR, xC, ${_} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${_}, d2),
                  getW(wF, wR, wC, ${_} + 1, d2),
                  getW(wF, wR, wC, ${_} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};var wb=class{constructor(t,e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t;let{filterWidth:s,inChannels:o,strideWidth:a,strideHeight:l,padInfo:u,outWidth:p,dilationWidth:f,dilationHeight:m,dataFormat:d}=n,{left:y,top:_}=u,v=o*s,C=gr(),N=d==="channelsLast",A=N?0:1,B=N?1:2,P="";for(let L=0;L<=1;L++)for(let Z=0;Z<=1;Z++)P+=`
          blockIndex = rc.y + ${Z};
          pos = rc.x + ${L};

          if(blockIndex < ${t[1]} && pos < ${t[0]}) {
            offsetY = int(blockIndex / (${p})) * ${l} - ${_};
            d0 = offsetY + ${m} * (pos / ${v});

            if(d0 < ${e[A]} && d0 >= 0) {

              offsetX = int(mod(float(blockIndex), ${p}.) * ${a}. - ${y}.);
              d1 = offsetX + ${f} * (int(mod(float(pos), ${v}.) / ${o}.));

              if(d1 < ${e[B]} && d1 >= 0) {

                ch = int(mod(float(pos), ${o}.));

                if (${N}) {
                  innerDims = vec2(d1, ch);
                  result[${L*2+Z}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${L*2+Z}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${P}

        ${C.output} = result;
      }
    `}};function ag({x:r,filter:t,convInfo:e,backend:n,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){let u=r.shape,p=n.texData.get(r.dataId),f=e.inChannels,m=u[0]*u[1]*u[2],d=e.outChannels,y=e.dataFormat==="channelsLast",_=!1,v=!1,C,N=[],A=(m===1||d===1)&&f>eb,B=u[2]%2!=0&&!!p.isPacked;if(A||!vt().getBool("WEBGL_LAZILY_UNPACK")||!vt().getBool("WEBGL_PACK_BINARY_OPERATIONS")||!B){let P=y?u[0]*u[1]*u[2]:u[0]*u[2]*u[3],L=Gt({inputs:{x:r},backend:n,attrs:{shape:[1,P,e.inChannels]}}),Z=Gt({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}}),K=zl({a:L,b:Z,transposeA:_,transposeB:v,backend:n,bias:s,activation:l,preluActivationWeights:o,leakyreluAlpha:a});C=Gt({inputs:{x:K},backend:n,attrs:{shape:e.outShape}}),N.push(L),N.push(Z),N.push(K)}else{let P=y?u[0]*u[1]*(u[2]+1):u[0]*u[2]*(u[3]+1),L={dataId:r.dataId,shape:[1,P,e.inChannels],dtype:r.dtype},Z=p.shape;p.shape=p.shape.slice(),p.shape[p.shape.length-2]++,E.assert(Pl(p.shape,L.shape),()=>`packed reshape ${p.shape} to ${L.shape} isn't free`);let K=Gt({inputs:{x:t},backend:n,attrs:{shape:[1,e.inChannels,e.outChannels]}});N.push(K);let et=zl({a:L,b:K,backend:n,transposeA:_,transposeB:v,bias:s,activation:l,preluActivationWeights:o,leakyreluAlpha:a}),it=n.texData.get(et.dataId);E.assert(it.isPacked,()=>"batchMatMul result is expected to be packed"),p.shape=Z,it.shape=e.outShape,C=vr({inputs:{x:et},backend:n}),C.shape=e.outShape,N.push(et)}for(let P of N)n.disposeIntermediateTensorInfo(P);return C}function lg({x:r,filter:t,convInfo:e,backend:n,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){let{filterWidth:u,filterHeight:p,inChannels:f,outWidth:m,outHeight:d,dataFormat:y}=e,_=y==="channelsLast",v=u*p*f,C=d*m,N=[v,C],A=!0,B=!1,P=[],L=Gt({inputs:{x:r},backend:n,attrs:{shape:r.shape.slice(1)}}),Z=Gt({inputs:{x:t},backend:n,attrs:{shape:[1,v,E.sizeFromShape(t.shape)/v]}});P.push(L),P.push(Z);let K=new wb(N,L.shape,e),et=n.runWebGLProgram(K,[L],"float32"),it=Gt({inputs:{x:et},backend:n,attrs:{shape:[1,N[0],N[1]]}});P.push(et),P.push(it);let xt=s!=null,wt=o!=null,St=l==="leakyrelu",yt=l?Ma(l,!0):null,Nt=new xf(it.shape,Z.shape,[1,C,e.outChannels],A,B,xt,yt,wt,St),ht=[it,Z];if(s&&ht.push(s),wt&&ht.push(o),St){let Dt=n.makeTensorInfo([],"float32",E.createScalarValue(a,"float32"));ht.push(Dt),P.push(Dt)}let It=n.runWebGLProgram(Nt,ht,"float32"),Ft=_?[1,d,m,e.outChannels]:[1,e.outChannels,d,m],Ct=Gt({inputs:{x:It},backend:n,attrs:{shape:Ft}});P.push(It);for(let Dt of P)n.disposeIntermediateTensorInfo(Dt);return Ct}function X5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o}=t,{strides:a,pad:l,dataFormat:u,dilations:p,dimRoundingMode:f}=n,m=H.convertConv2DDataFormat(u),d=H.computeConv2DInfo(s.shape,o.shape,a,p,l,f,!1,m),y;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))y=ag({x:s,filter:o,convInfo:d,backend:e});else if(vt().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)y=lg({x:s,filter:o,convInfo:d,backend:e});else{let v=new _f(d);y=e.runWebGLProgram(v,[s,o],"float32")}let _=Gt({inputs:{x:y},backend:e,attrs:{shape:d.outShape}});return e.disposeIntermediateTensorInfo(y),_}var u$={kernelName:Ri,backendName:"webgl",kernelFunc:X5};var Cb=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,s=t.padInfo.top,o=t.padInfo.left,a=t.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${o};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},kb=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,s=t.strideHeight,o=t.strideWidth,a=t.dataFormat==="channelsLast",l=e-1-t.padInfo.top,u=n-1-t.padInfo.left,p=a?1:2,f=a?2:3,m=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${m}];

        ivec2 dyCorner = ivec2(coords[${p}], coords[${f}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            for (int d2 = 0; d2 < ${t.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}},Sb=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideDepth,n=t.strideHeight,s=t.strideWidth,o=t.padInfo.front,a=t.padInfo.top,l=t.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yF = 0; yF < ${t.outDepth}; yF++) {
            int xF = wF + yF * ${e} - ${o};

            if (xF < 0 || xF >= ${t.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${t.outHeight}; yR++) {
              int xR = wR + yR * ${n} - ${a};

              if (xR < 0 || xR >= ${t.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${t.outWidth}; yC++) {
                int xC = wC + yC * ${s} - ${l};

                if (xC < 0 || xC >= ${t.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Ib=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterDepth,n=t.filterHeight,s=t.filterWidth,o=t.strideDepth,a=t.strideHeight,l=t.strideWidth,u=e-1-t.padInfo.front,p=n-1-t.padInfo.top,f=s-1-t.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${u}, ${p}, ${f});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${e}; wF++) {
          float dyF = float(dyFCorner + wF) / ${o}.0;

          if (dyF < 0.0 || dyF >= ${t.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${e} - 1 - wF;

          for (int wR = 0; wR < ${n}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${n} - 1 - wR;

            for (int wC = 0; wC < ${s}; wC++) {
              float dyC = float(dyCCorner + wC) / ${l}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${s} - 1 - wC;

              for (int d2 = 0; d2 < ${t.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Y5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,dy:o}=t,{strides:a,pad:l,dataFormat:u,dimRoundingMode:p,filterShape:f}=n,m=H.convertConv2DDataFormat(u),d=H.computeConv2DInfo(s.shape,f,a,1,l,p,!1,m),y=new Cb(d);return e.runWebGLProgram(y,[s,o],"float32")}var c$={kernelName:cu,backendName:"webgl",kernelFunc:Y5};function Z5(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,filter:o}=t,{inputShape:a,strides:l,pad:u,dataFormat:p,dimRoundingMode:f}=n,m=H.convertConv2DDataFormat(p),d=H.computeConv2DInfo(a,o.shape,l,1,u,f,!1,m),y=new kb(d);return e.runWebGLProgram(y,[s,o],"float32")}var p$={kernelName:Fi,backendName:"webgl",kernelFunc:Z5};function J5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o}=t,{strides:a,pad:l,dilations:u}=n,p=H.computeConv3DInfo(s.shape,o.shape,a,u,l),f=new vb(p);return e.runWebGLProgram(f,[s,o],"float32")}var f$={kernelName:Oi,backendName:"webgl",kernelFunc:J5};function Q5(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,dy:o}=t,{strides:a,pad:l,filterShape:u}=n,p=H.computeConv3DInfo(s.shape,u,a,1,l),f=new Sb(p);return e.runWebGLProgram(f,[s,o],"float32")}var h$={kernelName:pu,backendName:"webgl",kernelFunc:Q5};function tU(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,filter:o}=t,{pad:a,strides:l,inputShape:u}=n,p=H.computeConv3DInfo(u,o.shape,l,1,a),f=new Ib(p);return e.runWebGLProgram(f,[s,o],"float32")}var m$={kernelName:fu,backendName:"webgl",kernelFunc:tU};var eU=eg+`
  return cos(x);
`,rU=re({opSnippet:eU}),d$={kernelName:xo,backendName:"webgl",kernelFunc:rU};var nU=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,sU=re({opSnippet:nU}),g$={kernelName:yo,backendName:"webgl",kernelFunc:sU};var Nb=class{constructor(t,e,n,s,o){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];let[a,l,u,p]=t,[f]=e,[m,d]=n;this.outputShape=[f,m,d,p];let y=s==="bilinear"?1:0,[_,v]=[`${l-1}.0`,`${u-1}.0`],[C,N,A]=m>1?[`${(l-1)/(m-1)}`,"(y2-y1) * height_ratio",`y1*${_} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${_}`],[B,P,L]=d>1?[`${(u-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${v} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${v}`];this.userCode=`
      const float height_ratio = float(${C});
      const float width_ratio = float(${B});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${N};
        float width_scale = ${P};

        float in_y = ${A};
        if( in_y < 0.0 || in_y > ${_} ) {
          setOutput(float(${o}));
          return;
        }
        float in_x = ${L};
        if( in_x < 0.0 || in_x > ${v} ) {
          setOutput(float(${o}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${y} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}};var oU=r=>{let{inputs:t,backend:e,attrs:n}=r,{image:s,boxes:o,boxInd:a}=t,{cropSize:l,method:u,extrapolationValue:p}=n,f=new Nb(s.shape,o.shape,l,u,p);return e.runWebGLProgram(f,[s,o,a],"float32")},x$={kernelName:Yf,backendName:"webgl",kernelFunc:oU};var ug=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=t;let s=t.length,o=e?"0.0":`getX(${y$(s,"coords")})`,a=t[t.length-1],l="",u="";e?(l=n?`end != ${a-1}`:"end != 0",u=n?"end + 1":"end - 1"):(l=n?`end + pow2 < ${a}`:"end >= pow2",u=n?"end + pow2":"end - pow2"),this.userCode=`
      uniform float index;
      void main() {
        ${be(s)} coords = getOutputCoords();
        int end = ${_$(s,"coords")};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${_$(s,"coords")} = idx;
          val += getX(${y$(s,"coords")});
        }
        setOutput(val);
      }
    `}getCustomSetupFunc(t){return(e,n)=>{this.index==null&&(this.index=e.getUniformLocation(n,"index")),e.gl.uniform1f(this.index,t)}}};function y$(r,t){if(r===1)return`${t}`;if(r===2)return`${t}.x, ${t}.y`;if(r===3)return`${t}.x, ${t}.y, ${t}.z`;if(r===4)return`${t}.x, ${t}.y, ${t}.z, ${t}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function _$(r,t){if(r===1)return`${t}`;if(r===2)return`${t}.y`;if(r===3)return`${t}.z`;if(r===4)return`${t}.w`;throw Error(`Cumulative sum for rank ${r} is not yet supported`)}function iU(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,exclusive:a,reverse:l}=n,u=s.shape.length,p=H.getAxesPermutation([o],u),f=s;p!=null&&(f=yr({inputs:{x:s},backend:e,attrs:{perm:p}}));let m=H.getInnerMostAxes(1,u)[0];if(m!==u-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${s.shape.length-1} but got axis=${o}`);let d=s.shape[m],y=vr({inputs:{x:f},backend:e});for(let _=0;_<=Math.ceil(Math.log2(d))-1;_++){let v=new ug(f.shape,!1,l),C=v.getCustomSetupFunc(_),N=y;y=e.runWebGLProgram(v,[y],y.dtype,C),e.disposeIntermediateTensorInfo(N)}if(a){let _=new ug(f.shape,a,l),v=y;y=e.runWebGLProgram(_,[y],y.dtype),e.disposeIntermediateTensorInfo(v)}if(p!=null){let _=H.getUndoAxesPermutation(p),v=yr({inputs:{x:y},backend:e,attrs:{perm:_}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(f),v}return y}var b$={kernelName:Pi,backendName:"webgl",kernelFunc:iU};function aU(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,weights:o}=t,{size:a,binaryOutput:l}=n;if(s.shape.length===1){let u=e.readSync(s.dataId),p=e.readSync(o.dataId),f=Zd(u,p,o.dtype,o.shape,a);return e.makeTensorInfo([a],o.dtype,f)}else if(s.shape.length===2){let u=e.bufferSync(s),p=e.bufferSync(o),f=NE(u,p,a,l);return e.makeTensorInfo(f.shape,o.dtype,f.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${s.shape.length}.`)}var v$={kernelName:Zf,backendName:"webgl",kernelFunc:aU};var Tb=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=t,this.blockSize=e,this.dataFormat=n,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${e};
      int offset_h = imod(h, ${e});
      int in_w = w / ${e};
      int offset_w = imod(w, ${e});
      int offset_d = (offset_h * ${e} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}};function lU(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{blockSize:o,dataFormat:a}=n;E.assert(o>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${o}`);let l=s.shape[0],u=a==="NHWC"?s.shape[1]:s.shape[2],p=a==="NHWC"?s.shape[2]:s.shape[3],f=a==="NHWC"?s.shape[3]:s.shape[1],m=u*o,d=p*o,y=f/(o*o),_=a==="NHWC"?[l,m,d,y]:[l,y,m,d],v=new Tb(_,o,a);return e.runWebGLProgram(v,[s],s.dtype)}var w$={kernelName:hu,backendName:"webgl",kernelFunc:lU};var bf=class{constructor(t,e=!1,n=null,s=!1,o=!1){this.variableNames=["x","W"],this.outputShape=t.outShape;let a=t.inHeight,l=t.inWidth,u=t.padInfo.top,p=t.padInfo.left,f=t.strideHeight,m=t.strideWidth,d=t.dilationHeight,y=t.dilationWidth,_=t.filterHeight,v=t.filterWidth,C=t.outChannels/t.inChannels,N="",A="";n&&(s?N=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:o?N=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:N=`
          float activation(float x) {
            ${n}
          }
        `,A="result = activation(result);");let B=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${N}

      const ivec2 strides = ivec2(${f}, ${m});
      const ivec2 pads = ivec2(${u}, ${p});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${C};
        int q = d2 - d1 * ${C};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${_}; wR++) {
          int xR = xRCorner + wR * ${d};

          if (xR < 0 || xR >= ${a}) {
            continue;
          }

          for (int wC = 0; wC < ${v}; wC++) {
            int xC = xCCorner + wC * ${y};

            if (xC < 0 || xC >= ${l}) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${B}
        ${A}
        setOutput(result);
      }
    `}};var vf=class{constructor(t,e=!1,n=null,s=!1,o=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.outShape;let a=t.inHeight,l=t.inWidth,u=t.padInfo.top,p=t.padInfo.left,f=t.strideHeight,m=t.strideWidth,d=t.dilationHeight,y=t.dilationWidth,_=t.filterHeight,v=t.filterWidth,C=v,N="int xR; int xC; int xCOffset;";for(let L=0;L<_;L++)for(let Z=0;Z<v;Z++)N+=`
          vec4 xTexelR${L}C${Z*2} = vec4(0.);
          vec4 wR${L}C${Z} = vec4(0.);
          vec4 xR${L}C${Z} = vec4(0.);`;for(let L=0;L<_;L++)for(let Z=0;Z<C;Z++){let K=Z*2;if(N+=`
          xR = xRCorner + ${L*d};
          xC = xCCorner + ${K*y};
        `,m===1){if(K<v&&(p%2==1?N+=`
                xCOffset = xC + 1;
                if(xR >= 0 && xR < ${a} && xCOffset >= 0 && xCOffset < ${l}) {
                  xTexelR${L}C${K} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${l}) {
                    xTexelR${L}C${K}.zw = vec2(0.);
                  }
                } else {
                  xTexelR${L}C${K} = vec4(0.);
                }

                xCOffset = xC + 1 - 2;
                if(xR >= 0 && xR < ${a} && xCOffset >= 0 && xCOffset < ${l}) {
                  vec4 previous = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if(xCOffset + 1 >= ${l}) {
                    previous.zw = vec2(0.);
                  }

                  xR${L}C${K} = vec4(previous.zw, xTexelR${L}C${K}.xy);
                } else {
                  xR${L}C${K} = vec4(0, 0, xTexelR${L}C${K}.xy);
                }
              `:N+=`
                if(xR >= 0 && xR < ${a} && xC >= 0 && xC < ${l}) {
                  xTexelR${L}C${K} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${L}C${K} = vec4(0.);
                }

                xR${L}C${K} = xTexelR${L}C${K};
              `,K+1<v)){let et=p%2==0?E.nearestLargerEven(y):y;y%2==0&&p%2==1||y%2!=0&&p%2!=1?(N+=`
                  xCOffset = xC + ${p%2} + ${et};

                  if(xR >= 0 && xR < ${a} &&
                    xCOffset >= 0 && xCOffset < ${l}) {
                    xTexelR${L}C${K+2} = getX(batch, xR, xCOffset, d1);
                  }
                `,y>1&&(N+=`
                    xCOffset -= 2;
                    if(xR >= 0 && xR < ${a} &&
                      xCOffset >= 0 && xCOffset < ${l}) {
                      xTexelR${L}C${K} = getX(batch, xR, xCOffset, d1);
                    } else {
                      xTexelR${L}C${K} = vec4(0.);
                    }
                  `),N+=`
                  xR${L}C${K+1} = vec4(
                    xTexelR${L}C${K}.zw, xTexelR${L}C${K+2}.xy);
                `):N+=`
                  xCOffset = xC + ${et};

                  if(xR >= 0 && xR < ${a} &&
                    xCOffset >= 0 && xCOffset < ${l}) {
                    xTexelR${L}C${K+2} = getX(batch, xR, xCOffset, d1);
                  }

                  xR${L}C${K+1} = xTexelR${L}C${K+2};
                `}}else K<v&&(N+=`
              if(xR >= 0 && xR < ${a}) {
            `,p%2==1?(N+=`
                xCOffset = xC + 1 - ${m};
                if(xCOffset >= 0 && xCOffset < ${l}) {
                  xTexelR${L}C${K} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${L}C${K} = vec4(0.);
                }

                if(xC + 1 >= 0 && xC + 1 < ${l}) {
                  xTexelR${L}C${K+2} = getX(batch, xR, xC + 1, d1);
                } else {
                  xTexelR${L}C${K+2} = vec4(0.);
                }

                xR${L}C${K} = vec4(
                  xTexelR${L}C${K}.zw, xTexelR${L}C${K+2}.zw);
              `,K+1<v&&(N+=`
                  vec4 final = vec4(0.);
                  xCOffset = xC + 1 + ${m};
                  if(xCOffset >= 0 && xCOffset < ${l}) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xR${L}C${K+1} = vec4(xTexelR${L}C${K+2}.xy, final.xy);
                `)):(N+=`
                if(xC >= 0 && xC < ${l}) {
                  xTexelR${L}C${K} = getX(batch, xR, xC, d1);
                } else {
                  xTexelR${L}C${K} = vec4(0.);
                }

                xCOffset = xC + ${m};
                if(xCOffset >= 0 && xCOffset < ${l}) {
                  xTexelR${L}C${K+2} = getX(batch, xR, xCOffset, d1);
                } else {
                  xTexelR${L}C${K+2} = vec4(0.);
                }

                xR${L}C${K} = vec4(
                  xTexelR${L}C${K}.xy, xTexelR${L}C${K+2}.xy);
              `,K+1<v&&(N+=`
                  xR${L}C${K+1} = vec4(
                    xTexelR${L}C${K}.zw, xTexelR${L}C${K+2}.zw);
                `)),N+="}");K<v&&(N+=`
            vec4 wTexelR${L}C${K} = getW(${L}, ${K}, d1, q);
            wR${L}C${K} = vec4(wTexelR${L}C${K}.xz, wTexelR${L}C${K}.xz);
          `,K+1<v&&(N+=`
              vec4 wTexelR${L}C${K+1} = getW(${L}, ${K+1}, d1, q);
              wR${L}C${K+1} =
                vec4(wTexelR${L}C${K+1}.xz, wTexelR${L}C${K+1}.xz);`))}for(let L=0;L<_;L++)for(let Z=0;Z<v;Z++)N+=`dotProd += xR${L}C${Z} * wR${L}C${Z};`;let A="",B="";n&&(s?A=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${n}
        }`:o?A=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${n}
        }`:A=`vec4 activation(vec4 x) {
          ${n}
        }`,B="result = activation(result);");let P=e?"result += getBiasAtOutCoords();":"";e&&this.variableNames.push("bias"),s&&this.variableNames.push("preluActivationWeights"),o&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${A}

      const ivec2 strides = ivec2(${f}, ${m});
      const ivec2 pads = ivec2(${u}, ${p});

      void main() {

        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2;
        int q = 0;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        vec4 dotProd = vec4(0.);

        ${N}

        vec4 result = dotProd;
        ${P}
        ${B}
        setOutput(result);
      }
    `}};function uU(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o}=t,{strides:a,pad:l,dilations:u,dimRoundingMode:p}=n,f=u;f==null&&(f=[1,1]),E.assert(H.eitherStridesOrDilationsAreOne(a,f),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${f}'`);let m=H.computeConv2DInfo(s.shape,o.shape,a,f,l,p,!0),d;return vt().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels==1?d=new vf(m):d=new bf(m),e.runWebGLProgram(d,[s,o],"float32")}var C$={kernelName:Li,backendName:"webgl",kernelFunc:uU};var Eb=class{constructor(t){this.variableNames=["x","dy"],this.outputShape=t.filterShape;let e=t.strideHeight,n=t.strideWidth,s=t.padInfo.top,o=t.padInfo.left,a=t.outChannels/t.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${t.batchSize}; b++) {
          for (int yR = 0; yR < ${t.outHeight}; yR++) {
            int xR = wR + yR * ${e} - ${s};

            if (xR < 0 || xR >= ${t.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${t.outWidth}; yC++) {
              int xC = wC + yC * ${n} - ${o};

              if (xC < 0 || xC >= ${t.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}},Ab=class{constructor(t){this.variableNames=["dy","W"],this.outputShape=t.inShape;let e=t.filterHeight,n=t.filterWidth,s=t.strideHeight,o=t.strideWidth,a=e-1-t.padInfo.top,l=n-1-t.padInfo.left,u=t.outChannels/t.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${e}; wR++) {
          float dyR = float(dyRCorner + wR) / ${s}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${e} - 1 - wR;

          for (int wC = 0; wC < ${n}; wC++) {
            float dyC = float(dyCCorner + wC) / ${o}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${n} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${u}; dm++) {
              int d2 = d1 * ${u} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function cU(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,dy:o}=t,{strides:a,dilations:l,pad:u,dimRoundingMode:p,filterShape:f}=n,m=H.computeConv2DInfo(s.shape,f,a,l,u,p,!0),d=new Eb(m);return e.runWebGLProgram(d,[s,o],"float32")}var k$={kernelName:mu,backendName:"webgl",kernelFunc:cU};function pU(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,filter:o}=t,{strides:a,dilations:l,pad:u,dimRoundingMode:p,inputShape:f}=n,m=H.computeConv2DInfo(f,o.shape,a,l,u,p,!0),d=new Ab(m);return e.runWebGLProgram(d,[s,o],"float32")}var S$={kernelName:du,backendName:"webgl",kernelFunc:pU};var $b=class{constructor(t){this.variableNames=["X"],this.outputShape=[t,t],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}};function fU(r){let{inputs:t,backend:e}=r,{x:n}=t,s=[...n.shape,...n.shape],o=E.sizeFromShape(n.shape),a=Gt({inputs:{x:n},backend:e,attrs:{shape:[o]}}),l=new $b(o),u=e.runWebGLProgram(l,[a],a.dtype),p=Gt({inputs:{x:u},backend:e,attrs:{shape:s}});return e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(u),p}var I$={kernelName:Jf,backendName:"webgl",kernelFunc:fU};var Db=class{constructor(t){this.variableNames=["x","W"],this.outputShape=t.outShape;let{inHeight:e,inWidth:n,padInfo:s,strideHeight:o,strideWidth:a,filterHeight:l,filterWidth:u,dilationHeight:p,dilationWidth:f}=t,{top:m,left:d}=s;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${a});
      const ivec2 pads = ivec2(${m}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${l}; h++) {
          int hIn = hBeg + h * ${p};

          if (hIn >= 0 && hIn < ${e}) {
            for (int w = 0; w < ${u}; w++) {
              int wIn = wBeg + w * ${f};

              if (wIn >= 0 && wIn < ${n}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}};function hU(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o}=t,{strides:a,pad:l,dilations:u}=n,p=H.computeDilation2DInfo(s.shape,o.shape,a,l,"NHWC",u),f,m=new Db(p);f=e.runWebGLProgram(m,[s,o],"float32");let d=Gt({inputs:{x:f},backend:e,attrs:{shape:p.outShape}});return e.disposeIntermediateTensorInfo(f),d}var N$={kernelName:zi,backendName:"webgl",kernelFunc:hU};var mU="return (x >= 0.0) ? x : (exp(x) - 1.0);",dU=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,gU=re({opSnippet:mU,packedOpSnippet:dU}),T$={kernelName:bo,backendName:"webgl",kernelFunc:gU};var xU="return (b >= 1.0) ? a : a * (b + 1.0);",yU=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,_U=r=>{let{inputs:t,backend:e}=r,{dy:n,y:s}=t,o=vt().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ps(yU,n.shape,s.shape):new fs(xU,n.shape,s.shape);return e.runWebGLProgram(o,[n,s],n.dtype)},E$={kernelName:gu,backendName:"webgl",kernelFunc:_U};var bU=`
  return vec4(equal(a, b));
`,vU="return float(a == b);",wU=Ge({opSnippet:vU,packedOpSnippet:bU,dtype:"bool"}),A$={kernelName:Ja,backendName:"webgl",kernelFunc:wU};var CU=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${H.ERF_P};
  float a1 = ${H.ERF_A1};
  float a2 = ${H.ERF_A2};
  float a3 = ${H.ERF_A3};
  float a4 = ${H.ERF_A4};
  float a5 = ${H.ERF_A5};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,kU=re({opSnippet:CU}),$$={kernelName:vo,backendName:"webgl",kernelFunc:kU};var D$="return exp(x);",Rb=re({opSnippet:D$,packedOpSnippet:D$,cpuKernelImpl:AE}),R$={kernelName:wo,backendName:"webgl",kernelFunc:Rb};function cg(r){let{inputs:t,attrs:e,backend:n}=r,{dim:s}=e,{input:o}=t,a=o.shape.length,l=o.shape.slice(),u=s;return s<0&&(E.assert(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),u=a+s+1),l.splice(u,0,1),Gt({inputs:{x:o},backend:n,attrs:{shape:l}})}var F$={kernelName:Mi,backendName:"webgl",kernelFunc:cg};var O$="return exp(x) - 1.0;",SU=re({opSnippet:O$,packedOpSnippet:O$,cpuKernelImpl:$E}),P$={kernelName:Co,backendName:"webgl",kernelFunc:SU};var pg=class{constructor(t,e,n){this.variableNames=["real","imag"];let s=e[1];this.outputShape=e;let o=n?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=n?`${s}.0`:"1.0",l;if(t==="real")l="return real * expR - imag * expI;";else if(t==="imag")l="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${t}.`);this.userCode=`
      const float exponentMultiplier = ${o};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${l}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${s});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${s}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};function fg(r,t,e){let n=e.texData.get(r.dataId),s=E.sizeFromShape(r.shape),o=r.shape[r.shape.length-1],a=s/o,l=Gt({inputs:{x:r},backend:e,attrs:{shape:[a,o]}}),u=l.shape,p=new pg("real",u,t),f=new pg("imag",u,t),m=[{dataId:n.complexTensorInfos.real.dataId,dtype:n.complexTensorInfos.real.dtype,shape:u},{dataId:n.complexTensorInfos.imag.dataId,dtype:n.complexTensorInfos.imag.dtype,shape:u}],d=e.runWebGLProgram(p,m,"float32"),y=e.runWebGLProgram(f,m,"float32"),_=Nn({inputs:{real:d,imag:y},backend:e});e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(y);let v=Gt({inputs:{x:_},backend:e,attrs:{shape:r.shape}});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(_),v}function IU(r){let{inputs:t,backend:e}=r,{input:n}=t;return fg(n,!1,e)}var L$={kernelName:xu,backendName:"webgl",kernelFunc:IU};var Fb=class{constructor(t,e){this.outputShape=[],this.variableNames=["x"],this.outputShape=t,this.userCode=`
      uniform float value;
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}getCustomSetupFunc(t){return(e,n)=>{this.valueLoc==null&&(this.valueLoc=e.getUniformLocationNoThrow(n,"value")),e.gl.uniform1f(this.valueLoc,t)}}};function wf(r){let{backend:t,attrs:e}=r,{shape:n,value:s}=e,{dtype:o}=e;if(o=o||E.inferDtype(s),o==="string"){let a=E.getArrayFromDType(o,E.sizeFromShape(n));return a.fill(s),t.makeTensorInfo(n,o,a)}else{let a=new Fb(n,s),l=a.getCustomSetupFunc(s);return t.runWebGLProgram(a,[],o,l)}}var z$={kernelName:yu,backendName:"webgl",kernelFunc:wf};var Ob=class{constructor(t){this.variableNames=["Image"],this.outputShape=[];let e=t[2];this.outputShape=t,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${e} - x;
          float outputValue;
          if(coordX >= 0 && coordX < ${e}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var M$={kernelName:Qf,backendName:"webgl",kernelFunc:({inputs:r,backend:t})=>{let{image:e}=r,n=t,s=new Ob(e.shape);return n.runWebGLProgram(s,[e],e.dtype)}};var B$="return floor(x);",NU=re({opSnippet:B$,packedOpSnippet:B$,cpuKernelImpl:DE}),V$={kernelName:ko,backendName:"webgl",kernelFunc:NU};var TU=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,EU=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,AU=Ge({opSnippet:TU,packedOpSnippet:EU,dtype:"int32"}),G$={kernelName:So,backendName:"webgl",kernelFunc:AU};var Pb=class{constructor(t){this.variableNames=["A"];let e=gr(),[n,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}.0, ${n}.0);

        vec4 values = ${e.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}};var Lb=class{constructor(t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;let e=gr(),[n,s]=t;this.outputShape=t,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${s}.0, ${n}.0);
            vec4 values = ${e.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${e.output} = result;
      }
    `}};var W$={kernelName:ep,backendName:"webgl",kernelFunc:$U},Lc;function $U(r){let{inputs:t,backend:e,attrs:n}=r,{pixels:s}=t,{numChannels:o}=n,a=typeof HTMLVideoElement!="undefined"&&s instanceof HTMLVideoElement,l=typeof HTMLImageElement!="undefined"&&s instanceof HTMLImageElement,u=typeof ImageBitmap!="undefined"&&s instanceof ImageBitmap,[p,f]=a?[s.videoWidth,s.videoHeight]:[s.width,s.height],m=[f,p],d=[f,p,o];(l||a||u)&&(Lc==null&&(Lc=document.createElement("canvas").getContext("2d")),Lc.canvas.width=p,Lc.canvas.height=f,Lc.drawImage(s,0,0,p,f),s=Lc.canvas);let y=e.makeTensorInfo(m,"int32");e.texData.get(y.dataId).usage=tn.PIXELS,e.gpgpu.uploadPixelDataToTexture(e.getTexture(y.dataId),s);let _=vt().getBool("WEBGL_PACK")?new Lb(d):new Pb(d),v=e.runWebGLProgram(_,[y],"int32");return e.disposeData(y.dataId),v}function DU(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o,bias:a,preluActivationWeights:l}=t,{strides:u,pad:p,dataFormat:f,dilations:m,dimRoundingMode:d,activation:y,leakyreluAlpha:_}=n,v=H.convertConv2DDataFormat(f),C=H.computeConv2DInfo(s.shape,o.shape,u,m,p,d,!1,v),N,A=[];if(C.filterHeight===1&&C.filterWidth===1&&C.dilationHeight===1&&C.dilationWidth===1&&C.strideHeight===1&&C.strideWidth===1&&(C.padInfo.type==="SAME"||C.padInfo.type==="VALID"))N=ag({x:s,filter:o,convInfo:C,backend:e,bias:a,activation:y,preluActivationWeights:l,leakyreluAlpha:_});else if(vt().getBool("WEBGL_CONV_IM2COL")&&s.shape[0]===1)N=lg({x:s,filter:o,convInfo:C,backend:e,bias:a,activation:y,preluActivationWeights:l,leakyreluAlpha:_});else{let P=a!=null,L=l!=null,Z=y==="leakyrelu",K=y?Ma(y,!1):null,et=new _f(C,P,K,L,Z),it=[s,o];if(a&&it.push(a),l&&it.push(l),Z){let xt=e.makeTensorInfo([],"float32",E.createScalarValue(_,"float32"));it.push(xt),A.push(xt)}N=e.runWebGLProgram(et,it,"float32")}let B=Gt({inputs:{x:N},backend:e,attrs:{shape:C.outShape}});return A.push(N),A.forEach(P=>e.disposeIntermediateTensorInfo(P)),B}var U$={kernelName:al,backendName:"webgl",kernelFunc:DU};function RU(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,filter:o,bias:a,preluActivationWeights:l}=t,{strides:u,pad:p,dilations:f,dimRoundingMode:m,activation:d,leakyreluAlpha:y}=n,_=[],v=f;v==null&&(v=[1,1]),E.assert(H.eitherStridesOrDilationsAreOne(u,v),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${u} and dilations '${v}'`);let C=H.computeConv2DInfo(s.shape,o.shape,u,v,p,m,!0),N=vt().getBool("WEBGL_PACK_DEPTHWISECONV")&&C.strideWidth<=2&&C.outChannels/C.inChannels==1,A=d?Ma(d,N):null,B=[s,o],P=a!=null,L=l!=null,Z=d==="leakyrelu";if(P&&B.push(a),L&&B.push(l),Z){let it=e.makeTensorInfo([],"float32",E.createScalarValue(y,"float32"));B.push(it),_.push(it)}let K;N?K=new vf(C,P,A,L,Z):K=new bf(C,P,A,L,Z);let et=e.runWebGLProgram(K,B,"float32");return _.forEach(it=>e.disposeIntermediateTensorInfo(it)),et}var j$={kernelName:ll,backendName:"webgl",kernelFunc:RU};var zb=class{constructor(t,e,n){this.sliceDim=t,this.strides=e,this.variableNames=["x","indices"],this.outputShape=n;let s=be(e.length),o=be(n.length),a=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${s} strides = ${s}(${this.strides});
         void main() {
          ${o} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${a};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}};function FU(r){let{inputs:t,backend:e}=r,{params:n,indices:s}=t,o=s.shape,a=o[o.length-1],[l,u,p,f]=H.prepareAndValidate(n,s),m=Gt({inputs:{x:s},backend:e,attrs:{shape:[u,a]}}),d=Gt({inputs:{x:n},backend:e,attrs:{shape:[E.sizeFromShape(n.shape)/p,p]}}),y=new zb(a,f,[u,p]),_=e.runWebGLProgram(y,[d,m],d.dtype),v=Gt({inputs:{x:_},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(_),v}var q$={kernelName:th,backendName:"webgl",kernelFunc:FU};var Mb=class{constructor(t,e){this.variableNames=["A","indices"],this.outputShape=e,this.rank=e.length;let n=be(this.rank),s=OU(t,2);this.userCode=`
      void main() {
        ${n} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}};function OU(r,t){let e=["resRC.x","resRC.y","resRC.z","resRC.w"],n=[];for(let s=0;s<r.length;s++)s===2?n.push("int(getIndices(resRC.x, resRC.z))"):n.push(`${e[s]}`);return n.join()}function PU(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,indices:o}=t,{axis:a,batchDims:l}=n,u=E.parseAxisParam(a,s.shape)[0],p=H.segment_util.collectGatherOpShapeInfo(s,o,u,l),f=E.sizeFromShape(o.shape),m=[],d=Gt({inputs:{x:s},backend:e,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),y=Gt({inputs:{x:o},backend:e,attrs:{shape:[p.batchSize,f/p.batchSize]}});m.push(d),m.push(y);let _=[p.batchSize,p.outerSize,f/p.batchSize,p.sliceSize];if(e.shouldExecuteOnCPU([s,o])||s.dtype==="string"){let A=e.bufferSync(y),B=e.bufferSync(d),P=RE(B,A,_);return m.forEach(L=>e.disposeIntermediateTensorInfo(L)),e.makeTensorInfo(p.outputShape,P.dtype,P.values)}let v=new Mb(d.shape,_),C=e.runWebGLProgram(v,[d,y],d.dtype);m.push(C);let N=Gt({inputs:{x:C},backend:e,attrs:{shape:p.outputShape}});return m.forEach(A=>e.disposeIntermediateTensorInfo(A)),N}var H$={kernelName:Vi,backendName:"webgl",kernelFunc:PU};var LU="return float(a > b);",zU=`
  return vec4(greaterThan(a, b));
`,MU=Ge({opSnippet:LU,packedOpSnippet:zU,cpuKernelImpl:FE,dtype:"bool"}),K$={kernelName:Qa,backendName:"webgl",kernelFunc:MU};var BU="return float(a >= b);",VU=`
  return vec4(greaterThanEqual(a, b));
`,GU=Ge({opSnippet:BU,packedOpSnippet:VU,dtype:"bool"}),X$={kernelName:Io,backendName:"webgl",kernelFunc:GU};function WU(r){let{inputs:t,backend:e}=r,{input:n}=t;return fg(n,!0,e)}var Y$={kernelName:_u,backendName:"webgl",kernelFunc:WU};var UU="return float(!isnan(x) && !isinf(x));",jU=re({opSnippet:UU,dtype:"bool"}),Z$={kernelName:No,backendName:"webgl",kernelFunc:jU};var qU="return float(isinf(x));",HU=re({opSnippet:qU,dtype:"bool"}),J$={kernelName:To,backendName:"webgl",kernelFunc:HU};var KU="return float(isnan(x));",XU=re({opSnippet:KU,dtype:"bool"}),Q$={kernelName:Eo,backendName:"webgl",kernelFunc:XU};var YU="return float(a < b);",ZU=`
  return vec4(lessThan(a, b));
`,JU=Ge({opSnippet:YU,packedOpSnippet:ZU,cpuKernelImpl:OE,dtype:"bool"}),tD={kernelName:tl,backendName:"webgl",kernelFunc:JU};var QU="return float(a <= b);",tj=`
  return vec4(lessThanEqual(a, b));
`,ej=Ge({opSnippet:QU,packedOpSnippet:tj,dtype:"bool"}),eD={kernelName:el,backendName:"webgl",kernelFunc:ej};function rj(r){let{backend:t,attrs:e}=r,{start:n,stop:s,num:o}=e,a=PE(n,s,o);return t.makeTensorInfo([a.length],"float32",a)}var rD={kernelName:eh,backendName:"webgl",kernelFunc:rj};var nj=`if (x < 0.0) return NAN;
  return log(x);`,sj=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,oj=re({opSnippet:nj,packedOpSnippet:sj,cpuKernelImpl:LE}),nD={kernelName:Ao,backendName:"webgl",kernelFunc:oj};var ij="return log(1.0 + x);",aj=re({opSnippet:ij}),sD={kernelName:$o,backendName:"webgl",kernelFunc:aj};var lj="return float(a >= 1.0 && b >= 1.0);",uj=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,cj=Ge({opSnippet:lj,packedOpSnippet:uj,dtype:"bool"}),oD={kernelName:rl,backendName:"webgl",kernelFunc:cj};var pj="return float(!(x >= 1.0));",fj=re({opSnippet:pj}),iD={kernelName:nl,backendName:"webgl",kernelFunc:fj};var hj="return float(a >= 1.0 || b >= 1.0);",mj=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,dj=Ge({opSnippet:hj,packedOpSnippet:mj,dtype:"bool"}),aD={kernelName:sl,backendName:"webgl",kernelFunc:dj};var Bb=class{constructor(t,e,n,s,o){this.variableNames=["x"],this.outputShape=[];let a=e,l=t[3]-1;this.outputShape=t;let u,p=`float(${n}) + float(${s}) * sum`;o===.5?u=`inversesqrt(${p})`:o===1?u=`1.0/(${p})`:u=`exp(log(${p}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${l}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${u};
        setOutput(val);
      }
    `}};var Vb=class{constructor(t,e,n,s,o){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;let a=e,l=t[3]-1;this.outputShape=t;let u,p=`float(${n}) + float(${s}) * sum`;o===.5?u=`inversesqrt(${p})`:o===1?u=`1.0/(${p})`:u=`exp(log(${p}) * float(-${o}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${l}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${u};
        setOutput(result);
      }
    `}};var gj=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{depthRadius:o,bias:a,alpha:l,beta:u}=n,p=vt().getBool("WEBGL_PACK_NORMALIZATION")?new Vb(s.shape,o,a,l,u):new Bb(s.shape,o,a,l,u);return e.runWebGLProgram(p,[s],s.dtype)},lD={kernelName:Ui,backendName:"webgl",kernelFunc:gj};var Gb=class{constructor(t,e,n,s,o){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=t,this.depth=t[3],this.depthRadius=e,this.bias=n,this.alpha=s,this.beta=o,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${e})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${e} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${s}) * norm + float(${n});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${s})
                * float(${o})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${o});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}};var xj=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:s,y:o,dy:a}=t,{depthRadius:l,bias:u,alpha:p,beta:f}=n,m=new Gb(s.shape,l,u,p,f);return e.runWebGLProgram(m,[s,o,a],s.dtype)},uD={kernelName:vu,backendName:"webgl",kernelFunc:xj};function cD(r,t,e,n){let s=E.sizeFromShape(t),a=E.sizeFromShape(r.shape)/s,l=Gt({inputs:{x:r},attrs:{shape:[a,s]},backend:n}),u=Pn(l,r.dtype,"max",n),p=Gt({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),p}function Wb(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{reductionIndices:o,keepDims:a}=n,l=s.shape.length,u=E.parseAxisParam(o,s.shape),p=u,f=H.getAxesPermutation(p,l),m=f!=null,d=e.shouldExecuteOnCPU([s]),y=s;if(m){if(d){let B=e.texData.get(y.dataId).values,P=new Array(l);for(let K=0;K<P.length;K++)P[K]=s.shape[f[K]];let L=Pc(B,s.shape,s.dtype,f,P);y=e.makeTensorInfo(P,s.dtype);let Z=e.texData.get(y.dataId);Z.values=L}else y=Ba(s,f,e);p=H.getInnerMostAxes(p.length,l)}H.assertAxesAreInnerMostDims("max",p,l);let[_,v]=H.computeOutAndReduceShapes(y.shape,p),C=_;a&&(C=H.expandShapeToKeepDim(_,u));let N;if(d){let B=e.texData.get(y.dataId).values,P=zE(B,E.sizeFromShape(v),C,s.dtype);N=e.makeTensorInfo(C,s.dtype);let L=e.texData.get(N.dataId);L.values=P}else N=cD(y,v,C,e);return m&&e.disposeIntermediateTensorInfo(y),N}var pD={kernelName:ji,backendName:"webgl",kernelFunc:Wb};var yj=tg+`
  return max(a, b);
`,_j=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+za+`
  return result;
`,bj=Ge({opSnippet:yj,packedOpSnippet:_j,cpuKernelImpl:ME}),fD={kernelName:Do,backendName:"webgl",kernelFunc:bj};function vj(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t;no(s,"maxPool");let{filterSize:o,strides:a,pad:l,dimRoundingMode:u}=n,p=1;E.assert(H.eitherStridesOrDilationsAreOne(a,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${p}'`);let f=H.computePool2DInfo(s.shape,o,a,p,l,u);if(f.filterWidth===1&&f.filterHeight===1&&E.arraysEqual(f.inShape,f.outShape))return vr({inputs:{x:s},backend:e});let m=new so(f,"max",!1);return e.runWebGLProgram(m,[s],s.dtype)}var hD={kernelName:qi,backendName:"webgl",kernelFunc:vj};function wj(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{filterSize:o,strides:a,pad:l,dataFormat:u,dimRoundingMode:p}=n,f=[1,1,1],m=H.computePool3DInfo(s.shape,o,a,f,l,p,u),d=new Ml(m,"max",!1);return e.runWebGLProgram(d,[s],s.dtype)}var mD={kernelName:Hi,backendName:"webgl",kernelFunc:wj};var Ub=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideHeight,n=t.strideWidth,s=t.dilationHeight,o=t.effectiveFilterHeight,a=t.effectiveFilterWidth,l=o-1-t.padInfo.top,u=a-1-t.padInfo.left,p=o*a-1;this.userCode=`
      const ivec2 pads = ivec2(${l}, ${u});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${o};
          wR += ${s}) {
          float dyR = float(dyRCorner + wR) / ${e}.0;

          if (dyR < 0.0 || dyR >= ${t.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${n}.0;

            if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${p} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}},jb=class{constructor(t){this.variableNames=["dy","maxPos"],this.outputShape=t.inShape;let e=t.strideDepth,n=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,a=t.dilationHeight,l=t.dilationWidth,u=t.effectiveFilterDepth,p=t.effectiveFilterHeight,f=t.effectiveFilterWidth,m=u-1-t.padInfo.front,d=p-1-t.padInfo.top,y=f-1-t.padInfo.left,_=u*p*f-1;this.userCode=`
      const ivec3 pads = ivec3(${m}, ${d}, ${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${u};
           wD += ${o}) {
          float dyD = float(dyDCorner + wD) / ${e}.0;

          if (dyD < 0.0 || dyD >= ${t.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${p};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${n}.0;

            if (dyR < 0.0 || dyR >= ${t.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${f};
                wC += ${l}) {
              float dyC = float(dyCCorner + wC) / ${s}.0;

              if (dyC < 0.0 || dyC >= ${t.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${_} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${p} * ${f} +
                  wR * ${f} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}};function Cj(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,input:o}=t,a=o,{filterSize:l,strides:u,pad:p,dimRoundingMode:f}=n,m=[1,1,1],d=H.computePool3DInfo(a.shape,l,u,m,p,f),y=new Ml(d,"max",!0),_=e.runWebGLProgram(y,[a],a.dtype),v=new jb(d),C=e.runWebGLProgram(v,[s,_],a.dtype);return e.disposeIntermediateTensorInfo(_),C}var dD={kernelName:Cu,backendName:"webgl",kernelFunc:Cj};function kj(r){let{inputs:t,backend:e,attrs:n}=r,{dy:s,input:o,output:a}=t,l=o;no([o,a],"maxPoolGrad");let{filterSize:u,strides:p,pad:f,dimRoundingMode:m}=n,d=H.computePool2DInfo(l.shape,u,p,1,f,m),y=!0,_=new so(d,"max",y),v=e.runWebGLProgram(_,[l],l.dtype),C=new Ub(d),N=e.runWebGLProgram(C,[s,v],l.dtype);return e.disposeIntermediateTensorInfo(v),N}var gD={kernelName:wu,backendName:"webgl",kernelFunc:kj};function xD(r,t,e,n){let s=new so(e,"max",!1),o=n.runWebGLProgram(s,[r],"float32");s=new so(e,"max",!0,!0,t);let a=n.runWebGLProgram(s,[r],"float32");return[o,a]}var yD={kernelName:rh,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{filterSize:s,strides:o,pad:a,includeBatchInIndex:l}=t,u=e;E.assert(n.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${n.shape.length}.`);let p=[1,1];E.assert(H.eitherStridesOrDilationsAreOne(o,p),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${p}'`);let f=H.computePool2DInfo(n.shape,s,o,p,a),[m,d]=xD(n,l,f,u);return[m,d]}};function _D(r,t,e,n){let s=E.sizeFromShape(t),a=E.sizeFromShape(r.shape)/s,l=Gt({inputs:{x:r},attrs:{shape:[a,s]},backend:n}),u=Pn(l,"float32","mean",n),p=Gt({inputs:{x:u},attrs:{shape:e},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),p}var bD={kernelName:Ki,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{x:n}=r,{keepDims:s,axis:o}=t,a=e,l=n.shape.length,u=E.parseAxisParam(o,n.shape),p=u,f=H.getAxesPermutation(p,l),m=f!=null,d=a.shouldExecuteOnCPU([n]),y=[],_=n;if(m){if(d){let P=a.texData.get(_.dataId).values,L=new Array(l);for(let et=0;et<L.length;et++)L[et]=n.shape[f[et]];let Z=Pc(P,n.shape,n.dtype,f,L);_=a.makeTensorInfo(L,n.dtype);let K=a.texData.get(_.dataId);K.values=Z}else _=Ba(n,f,a);y.push(_),p=H.getInnerMostAxes(p.length,l)}H.assertAxesAreInnerMostDims("sum",p,l);let[v,C]=H.computeOutAndReduceShapes(_.shape,p),N=v;s&&(N=H.expandShapeToKeepDim(v,u));let A=_D(_,C,N,a);for(let B of y)a.disposeIntermediateTensorInfo(B);return A}};function Sj(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n,l=s.shape.length,u=E.parseAxisParam(o,s.shape),p=u,f=H.getAxesPermutation(p,l),m=s;f!=null&&(m=yr({inputs:{x:s},backend:e,attrs:{perm:f}}),p=H.getInnerMostAxes(p.length,s.shape.length)),H.assertAxesAreInnerMostDims("min",p,l);let[d,y]=H.computeOutAndReduceShapes(m.shape,p),_=E.sizeFromShape(y),v=Gt({inputs:{x:m},backend:e,attrs:{shape:[-1,_]}}),C=Pn(v,v.dtype,"min",e),N;if(a){let A=H.expandShapeToKeepDim(d,u);N=Gt({inputs:{x:C},backend:e,attrs:{shape:A}})}else N=Gt({inputs:{x:C},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(v),e.disposeIntermediateTensorInfo(C),f!=null&&e.disposeIntermediateTensorInfo(m),N}var vD={kernelName:Xi,backendName:"webgl",kernelFunc:Sj};var Ij=tg+`
  return min(a, b);
`,Nj=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+za+`
  return result;
`,Tj=Ge({opSnippet:Ij,packedOpSnippet:Nj,cpuKernelImpl:BE}),wD={kernelName:Ro,backendName:"webgl",kernelFunc:Tj};var qb=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((f,m)=>f[0]+t[m]+f[1]);let s=t.length,o=be(s),a=e.map(f=>f[0]).join(","),l=e.map((f,m)=>f[0]+t[m]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s),p=n==="reflect"?0:1;if(s===1){this.userCode=`
        int start = ${a};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${p};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${p};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${l});

      void main() {
        ${o} outC = getOutputCoords();
        for (int i = 0; i < ${s}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${p};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${p};
          }
        }
        ${o} coords = outC - start;
        setOutput(getX(${u}));
      }
    `}};var Hb=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((_,v)=>_[0]+t[v]+_[1]);let s=t.length,o=be(s),a=e.map(_=>_[0]).join(","),l=e.map((_,v)=>_[0]+t[v]).join(","),u=br("rc",s),p=br("source",s),f=`${u[s-1]} < ${this.outputShape[s-1]}`,m=s===1?"source":`vec2(${p.slice(-2).join()})`,d=n==="reflect"?0:1,y="";if(s===1){let _=`
        ${o} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;y=`
        ${o} rc = outputLoc;
        ${_}
        result[0] = getChannel(getX(${p.join()}), ${m});
        ${u[s-1]} += 1;
        if(${f}) {
          ${_}
          result[1] = getChannel(getX(${p.join()}), ${m});
        }
      `}else{let _=`
        ${o} source = rc;
        ${o} lt = ${o}(lessThan(source, start));
        ${o} gte = ${o}(greaterThanEqual(source, end));
        ${o} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;y=`
        ${o} rc = outputLoc;
        ${_}
        result[0] = getChannel(getX(${p.join()}), ${m});
        ${u[s-1]} += 1;
        if(${f}) {
          ${_}
          result[1] = getChannel(getX(${p.join()}), ${m});
        }
        rc = outputLoc;
        ${u[s-2]} += 1;
        if(${u[s-2]} < ${this.outputShape[s-2]}) {
          ${_}
          result[2] = getChannel(getX(${p.join()}), ${m});
          ${u[s-1]} += 1;
          if(${f}) {
            ${_}
            result[3] = getChannel(getX(${p.join()}), ${m});
          }
        }
      `}this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${l});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${y}
        setOutput(result);
      }
    `}};var Ej=({inputs:r,backend:t,attrs:e})=>{let{x:n}=r,{paddings:s,mode:o}=e,a=vt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Hb(n.shape,s,o):new qb(n.shape,s,o);return t.runWebGLProgram(a,[n],n.dtype)},CD={kernelName:Yi,backendName:"webgl",kernelFunc:Ej};var Aj=`if (b == 0.0) return NAN;
  return mod(a, b);`,$j=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+za+`
  return result;
`,Dj=Ge({opSnippet:Aj,packedOpSnippet:$j}),kD={kernelName:Fo,backendName:"webgl",kernelFunc:Dj};var Kb=class{constructor(t,e,n){this.variableNames=["probs"],this.outputShape=[t,n],this.userCode=`
      uniform float seed;

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${e-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${e-1}));
      }
    `}getCustomSetupFunc(t){return(e,n)=>{this.seedLoc==null&&(this.seedLoc=e.getUniformLocation(n,"seed")),e.gl.uniform1f(this.seedLoc,t)}}};var Rj=`
if (a == b) {
  return 1.0;
};
return a / b;`,Fj=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,Xb=Ge({opSnippet:Rj,packedOpSnippet:Fj,checkOutOfBounds:!0}),SD={kernelName:_o,backendName:"webgl",kernelFunc:Xb};var ID="return a - b;",Yb=Ge({opSnippet:ID,packedOpSnippet:ID,supportsComplex:!0,cpuKernelImpl:KE}),ND={kernelName:Yo,backendName:"webgl",kernelFunc:Yb};function Zb(r){let{inputs:t,backend:e,attrs:n}=r,{logits:s}=t,{dim:o}=n,a=E.parseAxisParam([o],s.shape),l=Wb({inputs:{x:s},backend:e,attrs:{reductionIndices:a,keepDims:!1}}),u=H.expandShapeToKeepDim(l.shape,a),p=Gt({inputs:{x:l},backend:e,attrs:{shape:u}}),f=Yb({inputs:{a:s,b:p},backend:e}),m=Rb({inputs:{x:f},backend:e}),d=yf({inputs:{x:m},backend:e,attrs:{axis:a,keepDims:!1}}),y=Gt({inputs:{x:d},backend:e,attrs:{shape:u}}),_=Xb({inputs:{a:m,b:y},backend:e});return e.disposeIntermediateTensorInfo(l),e.disposeIntermediateTensorInfo(p),e.disposeIntermediateTensorInfo(f),e.disposeIntermediateTensorInfo(m),e.disposeIntermediateTensorInfo(d),e.disposeIntermediateTensorInfo(y),_}var TD={kernelName:fa,backendName:"webgl",kernelFunc:Zb};function Oj(r){let{inputs:t,backend:e,attrs:n}=r,{logits:s}=t,{numSamples:o,seed:a,normalized:l}=n,u=l?s:Zb({inputs:{logits:s},backend:e,attrs:{dim:s.shape.length-1}}),p=u.shape[0],f=u.shape[1],m=new Kb(p,f,o),d=m.getCustomSetupFunc(a),y=e.runWebGLProgram(m,[u],"int32",d);return l||e.disposeIntermediateTensorInfo(u),y}var ED={kernelName:nh,backendName:"webgl",kernelFunc:Oj};var AD="return -x;";function Pj(r){let{inputs:t,backend:e}=r,{x:n}=t;if(e.shouldExecuteOnCPU([n])){let o=e.texData.get(n.dataId),[a,l]=GE(o.values,n.shape,n.dtype);return e.makeTensorInfo(l,n.dtype,a)}let s;return vt().getBool("WEBGL_PACK_UNARY_OPERATIONS")?s=new Os(n.shape,AD):s=new In(n.shape,AD),e.runWebGLProgram(s,[n],n.dtype)}var $D={kernelName:Zi,backendName:"webgl",kernelFunc:Pj};var Lj=sn.nonMaxSuppressionV3Impl;function zj(r){H.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u}=n,p=e.readSync(s.dataId),f=e.readSync(o.dataId),{selectedIndices:m}=Lj(p,f,a,l,u);return e.makeTensorInfo([m.length],"int32",new Int32Array(m))}var DD={kernelName:sh,backendName:"webgl",kernelFunc:zj};var Mj=sn.nonMaxSuppressionV4Impl;function Bj(r){H.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u,padToMaxOutputSize:p}=n,f=e.readSync(s.dataId),m=e.readSync(o.dataId),{selectedIndices:d,validOutputs:y}=Mj(f,m,a,l,u,p);return[e.makeTensorInfo([d.length],"int32",new Int32Array(d)),e.makeTensorInfo([],"int32",new Int32Array([y]))]}var RD={kernelName:oh,backendName:"webgl",kernelFunc:Bj};var Vj=sn.nonMaxSuppressionV5Impl;function Gj(r){H.warn("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");let{inputs:t,backend:e,attrs:n}=r,{boxes:s,scores:o}=t,{maxOutputSize:a,iouThreshold:l,scoreThreshold:u,softNmsSigma:p}=n,f=e.readSync(s.dataId),m=e.readSync(o.dataId),d=a,y=l,_=u,v=p,{selectedIndices:C,selectedScores:N}=Vj(f,m,d,y,_,v);return[e.makeTensorInfo([C.length],"int32",new Int32Array(C)),e.makeTensorInfo([N.length],"float32",new Float32Array(N))]}var FD={kernelName:ih,backendName:"webgl",kernelFunc:Gj};var Jb=class{constructor(t,e,n,s){this.variableNames=["indices"],this.outputShape=[t,e],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${s}), float(${n}),
                      float(index == coords.y)));
      }
    `}};var Wj=r=>{let{inputs:t,backend:e,attrs:n}=r,{indices:s}=t,{depth:o,onValue:a,offValue:l}=n,u=E.sizeFromShape(s.shape),p=new Jb(u,o,a,l),f=Gt({inputs:{x:s},backend:e,attrs:{shape:[u]}}),m=e.runWebGLProgram(p,[f],s.dtype);e.disposeIntermediateTensorInfo(f);let d=[...s.shape,o],y=Gt({inputs:{x:m},backend:e,attrs:{shape:d}});return e.disposeIntermediateTensorInfo(m),y},OD={kernelName:Qi,backendName:"webgl",kernelFunc:Wj};function Cf(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="complex64"){let s=yi({inputs:{input:n},backend:e}),o=Cf({inputs:{x:s},backend:e}),a=Bl({inputs:{input:n},backend:e}),l=Cf({inputs:{x:a},backend:e}),u=Nn({inputs:{real:o,imag:l},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}else return wf({attrs:{shape:n.shape,dtype:n.dtype,value:n.dtype==="string"?"":0},backend:e})}var PD={kernelName:ga,backendName:"webgl",kernelFunc:Cf};function LD(r){let{inputs:t,backend:e}=r,{x:n}=t;if(n.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(n.dtype==="complex64"){let s=yi({inputs:{input:n},backend:e}),o=LD({inputs:{x:s},backend:e}),a=Bl({inputs:{input:n},backend:e}),l=Cf({inputs:{x:a},backend:e}),u=Nn({inputs:{real:o,imag:l},backend:e});return e.disposeIntermediateTensorInfo(s),e.disposeIntermediateTensorInfo(o),e.disposeIntermediateTensorInfo(a),e.disposeIntermediateTensorInfo(l),u}else return wf({attrs:{shape:n.shape,dtype:n.dtype,value:1},backend:e})}var zD={kernelName:Ji,backendName:"webgl",kernelFunc:LD};function Uj(r){let{inputs:t,backend:e,attrs:n}=r,{axis:s}=n;if(t.length===1)return cg({inputs:{input:t[0]},backend:e,attrs:{dim:s}});let o=t[0].shape,a=t[0].dtype;t.forEach(f=>{E.assertShapesMatch(o,f.shape,"All tensors passed to stack must have matching shapes"),E.assert(a===f.dtype,()=>"All tensors passed to stack must have matching dtypes")});let l=[],u=t.map(f=>{let m=cg({inputs:{input:f},backend:e,attrs:{dim:s}});return l.push(m),m}),p=bb({inputs:u,backend:e,attrs:{axis:s}});return l.forEach(f=>e.disposeIntermediateTensorInfo(f)),p}var MD={kernelName:ta,backendName:"webgl",kernelFunc:Uj};var Qb=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=e.map((p,f)=>p[0]+t[f]+p[1]);let s=t.length,o=be(s),a=e.map(p=>p[0]).join(","),l=e.map((p,f)=>p[0]+t[f]).join(","),u=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,s);if(s===1){this.userCode=`
        int start = ${a};
        int end = ${l};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(float(${n}));
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${o} start = ${o}(${a});
      ${o} end = ${o}(${l});

      void main() {
        ${o} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(float(${n}));
        } else {
          ${o} coords = outC - start;
          setOutput(getX(${u}));
        }
      }
    `}};var t0=class{constructor(t,e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e.map((v,C)=>v[0]+t[C]+v[1]);let s=t.length,o=be(s),a=e.map(v=>v[0]).join(","),l=e.map((v,C)=>v[0]+t[C]).join(","),u=br("rc",s),p=br("source",s),f=`${u[s-1]} < ${this.outputShape[s-1]}`,m=s===1?"source":`vec2(${p.slice(-2).join()})`,d=[`${o} rc = outputLoc;`,`${u[s-1]} += 1;
       if(${f}) {
      `,s===1?"":`}
       rc = outputLoc;
       ${u[s-2]} += 1;
       if(${u[s-2]} < ${this.outputShape[s-2]}) {`,s===1?"":`  ${u[s-1]} += 1;
         if(${f}) {`],y=s===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))",_="";for(let v=0,C=s===1?2:4;v<C;v++)_+=`
        ${d[v]}
        if (${y}) {
          result[${v}] = float(${n});
        } else {
          ${o} source = rc - start;
          result[${v}] = getChannel(getX(${p.join()}), ${m});
        }
      `;_+=s===1?"} ":"}}",this.userCode=`
      const ${o} start = ${o}(${a});
      const ${o} end = ${o}(${l});

      void main() {
        ${o} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${_}
        setOutput(result);
      }
    `}};var e0=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{paddings:o,constantValue:a}=n,l=vt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new t0(s.shape,o,a):new Qb(s.shape,o,a);return e.runWebGLProgram(l,[s],s.dtype)},BD={kernelName:ea,backendName:"webgl",kernelFunc:e0};var jj=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,qj=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+za+`
  return result;
`,Hj=Ge({opSnippet:jj,packedOpSnippet:qj}),VD={kernelName:Po,backendName:"webgl",kernelFunc:Hj};function Kj(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{axis:o,keepDims:a}=n,l=s.shape.length,u=[],p=E.parseAxisParam(o,s.shape),f=p,m=H.getAxesPermutation(f,l),d=s;m!=null&&(d=yr({inputs:{x:s},backend:e,attrs:{perm:m}}),f=H.getInnerMostAxes(f.length,l),u.push(d)),H.assertAxesAreInnerMostDims("prod",f,l);let y;if(e.shouldExecuteOnCPU([d])){let _=e.texData.get(d.dataId).values,{outVals:v,outShape:C,outDtype:N}=WE(d.shape,d.dtype,_,f);y=e.makeTensorInfo(C,N,v)}else{let[_,v]=H.computeOutAndReduceShapes(d.shape,f),C=E.sizeFromShape(v),N=Gt({inputs:{x:d},backend:e,attrs:{shape:[-1,C]}}),A=Lu(s.dtype),B=Pn(N,A,"prod",e);y=Gt({inputs:{x:B},backend:e,attrs:{shape:_}}),u.push(N),u.push(B)}if(a){u.push(y);let _=H.expandShapeToKeepDim(y.shape,p);y=Gt({inputs:{x:y},backend:e,attrs:{shape:_}})}return u.forEach(_=>e.disposeIntermediateTensorInfo(_)),y}var GD={kernelName:ku,backendName:"webgl",kernelFunc:Kj};var r0=r=>{let{backend:t,attrs:e}=r,{start:n,stop:s,step:o,dtype:a}=e,l=UE(n,s,o,a);return t.makeTensorInfo([l.length],a,l)},WD={kernelName:Su,backendName:"webgl",kernelFunc:r0};var Xj="return 1.0 / x;",Yj=re({opSnippet:Xj}),UD={kernelName:Lo,backendName:"webgl",kernelFunc:Yj};var Zj=Pr+`
  return (x < 0.0) ? 0.0 : x;
`,Jj=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Qj=re({opSnippet:Zj,packedOpSnippet:Jj}),jD={kernelName:zo,backendName:"webgl",kernelFunc:Qj};var t6=Pr+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,e6=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,r6=re({opSnippet:t6,packedOpSnippet:e6}),qD={kernelName:Mo,backendName:"webgl",kernelFunc:r6};var n0=class{constructor(t,e,n,s,o){this.variableNames=["A"],this.outputShape=[];let[a,l,u,p]=t;this.outputShape=[a,e,n,p];let f=[s&&e>1?l-1:l,s&&n>1?u-1:u],m=[s&&e>1?e-1:e,s&&n>1?n-1:n],d;o?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${f[0]/m[0]},
          ${f[1]/m[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}};var s0=class{constructor(t,e,n,s,o){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];let[a,l,u,p]=t;this.outputShape=[a,e,n,p];let f=[s&&e>1?l-1:l,s&&n>1?u-1:u],m=[s&&e>1?e-1:e,s&&n>1?n-1:n],d;o?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${f[0]/m[0]},
          ${f[1]/m[1]},
          ${f[1]/m[1]});
      const vec3 inputShapeRC = vec3(${l}.0, ${u}.0,
                                     ${u}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${p-1};
        bool hasNextRow = coords.z < ${n-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}};function n6(r){let{inputs:t,backend:e,attrs:n}=r,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:l}=n,[u,p]=l,f=vt().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new s0(s.shape,u,p,o,a):new n0(s.shape,u,p,o,a);return e.runWebGLProgram(f,[s],"float32")}var HD={kernelName:oa,backendName:"webgl",kernelFunc:n6};var o0=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,s,o]=e,[,a,l]=t,u=[n&&a>1?s-1:s,n&&l>1?o-1:o],p=[n&&a>1?a-1:a,n&&l>1?l-1:l],f=u[0]/p[0],m=u[1]/p[1],d=1/f,y=1/m,_=Math.ceil(d)*2+2,v=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${f});
        const float widthScale = float(${m});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${y});

        const int winHeight = int(${_});
        const int winWidth = int(${v});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${s-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${o-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function s6(r){let{inputs:t,backend:e,attrs:n}=r,{images:s,dy:o}=t,{alignCorners:a}=n,l=new o0(o.shape,s.shape,a);return e.runWebGLProgram(l,[o],o.dtype)}var KD={kernelName:Tu,backendName:"webgl",kernelFunc:s6};var i0=class{constructor(t,e,n,s,o){this.variableNames=["A"],this.outputShape=[];let[a,l,u,p]=t;this.outputShape=[a,e,n,p];let f=[s&&e>1?l-1:l,s&&n>1?u-1:u],m=[s&&e>1?e-1:e,s&&n>1?n-1:n],d=s?"0.5":"0.0",y;o?y="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":y="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${f[0]/m[0]},
          ${f[1]/m[1]});
      const vec2 inputShapeRC = vec2(${l}.0, ${u}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${y};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}};function o6(r){let{inputs:t,backend:e,attrs:n}=r,{images:s}=t,{alignCorners:o,halfPixelCenters:a,size:l}=n,[u,p]=l,f=new i0(s.shape,u,p,o,a);return e.runWebGLProgram(f,[s],s.dtype)}var XD={kernelName:sa,backendName:"webgl",kernelFunc:o6};var a0=class{constructor(t,e,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=e;let[,s,o]=e,[,a,l]=t,u=[n&&a>1?s-1:s,n&&l>1?o-1:o],p=[n&&a>1?a-1:a,n&&l>1?l-1:l],f=u[0]/p[0],m=u[1]/p[1],d=1/f,y=1/m,_=Math.ceil(d)*2+2,v=Math.ceil(y)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${f});
        const float widthScale = float(${m});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${y});

        const int winHeight = int(${_});
        const int winWidth = int(${v});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${l}) {
              continue;
            }

            float sourceFracRow =
              float(${u[0]}) *
                (float(dyR) / float(${p[0]}));

            float sourceFracCol =
                float(${u[1]}) *
                  (float(dyC) / float(${p[1]}));

            int sourceNearestRow = int(min(
                float(int(${s}) - 1),
                ${n} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${o}) - 1),
                ${n} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}};function i6(r){let{inputs:t,backend:e,attrs:n}=r,{images:s,dy:o}=t,{alignCorners:a}=n,l=new a0(o.shape,s.shape,a);return e.runWebGLProgram(l,[o],o.dtype)}var YD={kernelName:Nu,backendName:"webgl",kernelFunc:i6};var l0=class{constructor(t,e){this.variableNames=["x"];let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);if(this.outputShape=t,n===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${t[0]} - coord - 1));
        }
      `;return}let s=l=>e.indexOf(l)!==-1&&t[l]!==1?`${t[l]} - coords[${l}] - 1`:`coords[${l}]`,o=t.map((l,u)=>s(u)).join(","),a=be(n);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}};var u0=class{constructor(t,e){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;let n=t.length;if(n>4)throw new Error(`WebGL backend: Reverse of rank-${n} tensor is not yet supported`);this.outputShape=t;let s=br("rc",n),o=`${s[n-1]} + 1 < ${this.outputShape[n-1]}`,a=`${s[n-2]} + 1 < ${this.outputShape[n-2]}`,l=be(n);n===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${t[0]} - rc - 1),
            ${t[0]} - rc - 1);
          if(${o}){
              result.g = getChannel(getX(${t[0]} - (rc  + 1) - 1),
                ${t[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${l} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${u(s.slice())};
          if(${o}){
            result.g = ${p(s.slice())};
          }
          if(${a}) {
            result.b = ${f(s.slice())};
            if(${o}) {
              result.a = ${m(s.slice())};
            }
          }
          setOutput(result);
        }
    `;function u(_){return d(_)}function p(_){return _[n-1]="("+_[n-1]+" + 1)",d(_)}function f(_){return _[n-2]="("+_[n-2]+" + 1)",d(_)}function m(_){return _[n-1]="("+_[n-1]+" + 1)",_[n-2]="("+_[n-2]+" + 1)",d(_)}function d(_){let v=t.map((A,B)=>y(B,_)),C=v.join(","),N=v.slice(-2).join(",");return`getChannel(getX(${C}), vec2(${N}))`}function y(_,v){return e.indexOf(_)!==-1&&t[_]!==1?`${t[_]} - ${v[_]} - 1`:`${v[_]}`}}};function a6(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{dims:o}=n,a=s.shape.length,l=E.parseAxisParam(o,s.shape);if(a===0)return vr({inputs:{x:s},backend:e});let u=vt().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new u0(s.shape,l):new l0(s.shape,l);return e.runWebGLProgram(u,[s],s.dtype)}var ZD={kernelName:ia,backendName:"webgl",kernelFunc:a6};var c0=class{constructor(t,e,n,s){this.variableNames=["Image"],this.outputShape=[];let o=t[1],a=t[2],l=Math.sin(e).toFixed(3),u=Math.cos(e).toFixed(3);this.outputShape=t;let[p,f]=H.getImageCenter(s,o,a),m=p.toFixed(3),d=f.toFixed(3),y="";typeof n=="number"?y=`float outputValue = ${n.toFixed(2)};`:y=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - ${m}) * ${u} - (float(y) - ${d}) * ${l};
          float coordYFloat = (float(x) - ${m}) * ${l} + (float(y) - ${d}) * ${u};
          int coordX = int(round(coordXFloat + ${m}));
          int coordY = int(round(coordYFloat + ${d}));
          ${y}
          if(coordX >= 0 && coordX < ${a} && coordY >= 0 && coordY < ${o}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}};var JD={kernelName:uh,backendName:"webgl",kernelFunc:({inputs:r,attrs:t,backend:e})=>{let{image:n}=r,{radians:s,fillValue:o,center:a}=t,l=e,u=new c0(n.shape,s,o,a);return l.runWebGLProgram(u,[n],n.dtype)}};var l6=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,u6=re({opSnippet:l6}),QD={kernelName:Bo,backendName:"webgl",kernelFunc:u6};var c6="return inversesqrt(x);",p6=re({opSnippet:c6,cpuKernelImpl:jE}),tR={kernelName:Vo,backendName:"webgl",kernelFunc:p6};var kf=class{constructor(t,e,n,s,o,a,l=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;let u=be(o.length),p=be(a.length),f="";n===1?f="i":n===2&&(f="i, j");let m=`getIndices(${f})`,d="";s===1?d="i":s===2&&(d="i, coords[1]");let y=`getUpdates(${d})`,_=e>1?"strides[j]":"strides";this.userCode=`
        ${u} strides = ${u}(${o});

        void main() {
          ${p} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${t}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${e}; j++) {
              int index = round(${m});
              flattenedIndex += index * ${_};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${y};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}};function f6(r){let{inputs:t,backend:e,attrs:n}=r,{indices:s,updates:o}=t,{shape:a}=n,{sliceRank:l,numUpdates:u,sliceSize:p,strides:f,outputSize:m}=H.calculateShapes(o,s,a),d=[m/p,p];if(m===0)return e.makeTensorInfo(a,s.dtype);let y=Gt({inputs:{x:s},backend:e,attrs:{shape:[u,l]}}),_=Gt({inputs:{x:o},backend:e,attrs:{shape:[u,p]}}),v=e.makeTensorInfo([],"float32",new Float32Array([0])),C=new kf(u,l,y.shape.length,_.shape.length,f,d),N=e.runWebGLProgram(C,[_,y,v],_.dtype),A=Gt({inputs:{x:N},backend:e,attrs:{shape:a}});return e.disposeIntermediateTensorInfo(y),e.disposeIntermediateTensorInfo(_),e.disposeIntermediateTensorInfo(N),e.disposeIntermediateTensorInfo(v),A}var eR={kernelName:ah,backendName:"webgl",kernelFunc:f6};var p0=class{constructor(t,e,n){this.variableNames=["c","a","b"],this.outputShape=e;let s,o;if(n>4)throw Error(`Where for rank ${n} is not yet supported`);if(n===1)o="resRC",s="resRC";else{let l=["resRC.x","resRC.y","resRC.z","resRC.w"],u=[],p=[];for(let f=0;f<e.length;f++)p.push(`${l[f]}`),f<t&&u.push(`${l[f]}`);s=u.join(),o=p.join()}let a=be(n);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${s});
        if (cVal >= 1.0) {
          setOutput(getA(${o}));
        } else {
          setOutput(getB(${o}));
        }
      }
    `}};function h6(r){let{inputs:t,backend:e}=r,{condition:n,t:s,e:o}=t,a=new p0(n.shape.length,s.shape,s.shape.length);return e.runWebGLProgram(a,[n,s,o],Br(s.dtype,o.dtype))}var rR={kernelName:aa,backendName:"webgl",kernelFunc:h6};var m6=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${H.SELU_SCALEALPHA};
  float scale = ${H.SELU_SCALE};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,d6=re({opSnippet:m6}),nR={kernelName:Go,backendName:"webgl",kernelFunc:d6};var g6="return 1.0 / (1.0 + exp(-1.0 * x));",x6=re({opSnippet:g6}),sR={kernelName:qo,backendName:"webgl",kernelFunc:x6};var y6=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,_6=re({opSnippet:y6}),oR={kernelName:jo,backendName:"webgl",kernelFunc:_6};var b6=eg+`
  return sin(x);
`,v6=re({opSnippet:b6}),iR={kernelName:Wo,backendName:"webgl",kernelFunc:v6};var w6=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,C6=re({opSnippet:w6}),aR={kernelName:Uo,backendName:"webgl",kernelFunc:C6};var k6=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,S6=re({opSnippet:k6}),lR={kernelName:Ho,backendName:"webgl",kernelFunc:S6};var I6=r=>{let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{blockShape:o,paddings:a}=n;E.assert(s.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");let l=o.reduce((N,A)=>N*A),u=[[0,0]];u.push(...a);for(let N=1+o.length;N<s.shape.length;++N)u.push([0,0]);let p=[],f=e0({inputs:{x:s},backend:e,attrs:{paddings:u,constantValue:0}}),m=H.getReshaped(f.shape,o,l,!1),d=H.getPermuted(m.length,o.length,!1),y=H.getReshapedPermuted(f.shape,o,l,!1),_=Gt({inputs:{x:f},backend:e,attrs:{shape:m}}),v=yr({inputs:{x:_},backend:e,attrs:{perm:d}}),C=Gt({inputs:{x:v},backend:e,attrs:{shape:y}});return p.push(f),p.push(_),p.push(v),p.forEach(N=>e.disposeIntermediateTensorInfo(N)),C},uR={kernelName:ca,backendName:"webgl",kernelFunc:I6};function N6(r){let{inputs:t,backend:e,attrs:n}=r,{sparseIndices:s,sparseValues:o,defaultValue:a}=t,{outputShape:l}=n,{sliceRank:u,numUpdates:p,strides:f,outputSize:m}=H.calculateShapes(o,s,l),d=!1,y=new kf(p,u,s.shape.length,o.shape.length,f,[m,1],d),_=e.runWebGLProgram(y,[o,s,a],o.dtype),v=Gt({inputs:{x:_},backend:e,attrs:{shape:l}});return e.disposeIntermediateTensorInfo(_),v}var cR={kernelName:lh,backendName:"webgl",kernelFunc:N6};function T6(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{numOrSizeSplits:o,axis:a}=n,l=E.parseAxisParam(a,s.shape)[0],u=H.prepareSplitSize(s,o,l),p=s.shape.length,f=new Array(p).fill(0),m=s.shape.slice();return u.map(d=>{let y=[...m];y[l]=d;let _=xi({inputs:{x:s},backend:e,attrs:{begin:f,size:y}});return f[l]+=d,_})}var pR={kernelName:pa,backendName:"webgl",kernelFunc:T6};var E6="return sqrt(x);",A6=re({opSnippet:E6}),fR={kernelName:Ko,backendName:"webgl",kernelFunc:A6};var $6="return x * x;",D6=re({opSnippet:$6}),hR={kernelName:Eu,backendName:"webgl",kernelFunc:D6};var mR="return (a - b) * (a - b);",R6=Ge({opSnippet:mR,packedOpSnippet:mR}),dR={kernelName:Xo,backendName:"webgl",kernelFunc:R6};function F6({inputs:r,attrs:t,backend:e}){let{x:n}=r,s=Pr+`
    return x > 0.0 ? 1.0 : float(${t.alpha});
  `,o=new In(n.shape,s);return e.runWebGLProgram(o,[n],n.dtype)}var gR={kernelName:Qo,backendName:"webgl",kernelFunc:F6};var f0=class{constructor(t,e,n){this.variableNames=["x"],this.outputShape=n;let s=n.length,o=be(n.length),a=be(n.length),l="";if(s===1)l="coords * strides + begin";else{let u=0;l=n.map((p,f)=>(u++,n.length===1?`coords * strides[${f}] + begin[${f}]`:`coords[${u-1}] * strides[${f}] + begin[${f}]`)).join(",")}this.userCode=`
      ${o} begin = ${o}(${t});
      ${o} strides = ${o}(${e});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${l}));
      }
    `}};function O6(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{begin:o,end:a,strides:l,beginMask:u,endMask:p,ellipsisMask:f,newAxisMask:m,shrinkAxisMask:d}=n,{nonStrided:y,$begin:_,$strides:v,size:C,newShape:N,outShape:A}=pn.sliceInfo(s.shape,o,a,l,u,p,f,m,d),B=Gt({inputs:{x:s},backend:e,attrs:{shape:N}}),P;if(y){let Z=xi({inputs:{x:B},backend:e,attrs:{begin:_,size:C}});P=Gt({inputs:{x:Z},backend:e,attrs:{shape:A}}),e.disposeIntermediateTensorInfo(Z)}else if(A.some(Z=>Z===0))P=e.makeTensorInfo(A,s.dtype,[]);else if(e.shouldExecuteOnCPU([B])){let et=e.texData.get(B.dataId).values,it=ae(B.shape,B.dtype,et),xt=HE(A,it,v,_);P=e.makeTensorInfo(A,B.dtype,xt.values)}else{let K=new f0(_,v,A);P=e.runWebGLProgram(K,[B],B.dtype)}let L=Gt({inputs:{x:P},backend:e,attrs:{shape:A}});return e.disposeIntermediateTensorInfo(B),e.disposeIntermediateTensorInfo(P),L}var xR={kernelName:Au,backendName:"webgl",kernelFunc:O6};var P6="return tan(x);",L6=re({opSnippet:P6}),yR={kernelName:Zo,backendName:"webgl",kernelFunc:L6};var z6=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,M6=re({opSnippet:z6}),_R={kernelName:Jo,backendName:"webgl",kernelFunc:M6};var h0=class{constructor(t,e){this.variableNames=["A"];let n=new Array(t.length);for(let a=0;a<n.length;a++)n[a]=t[a]*e[a];this.outputShape=n,this.rank=n.length;let s=be(this.rank),o=B6(t);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${o}));
      }
    `}};function B6(r){let t=r.length;if(t>5)throw Error(`Tile for rank ${t} is not yet supported`);if(t===1)return`imod(resRC, ${r[0]})`;let e=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],n=[];for(let s=0;s<r.length;s++)n.push(`imod(${e[s]}, ${r[s]})`);return n.join()}function m0(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{reps:o}=n;if(s.dtype==="string"){let p=e.readSync(s.dataId).map(d=>E.decodeString(d)),f=ae(s.shape,s.dtype,p),m=XE(f,o);return e.makeTensorInfo(m.shape,m.dtype,m.values)}let a=new h0(s.shape,o);return e.runWebGLProgram(a,[s],s.dtype)}var bR={kernelName:Us,backendName:"webgl",kernelFunc:m0};function V6(r){let{inputs:t,backend:e,attrs:n}=r,{x:s}=t,{k:o,sorted:a}=n,l=e.readSync(s.dataId),[u,p]=YE(l,s.shape,s.dtype,o,a);return[e.makeTensorInfo(u.shape,u.dtype,u.values),e.makeTensorInfo(p.shape,p.dtype,p.values)]}var vR={kernelName:$u,backendName:"webgl",kernelFunc:V6};function G6(r){let{inputs:t,attrs:e,backend:n}=r,{axis:s}=e,{x:o}=t;no(o,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");let a=n.readSync(o.dataId),{outputValues:l,outputShape:u,indices:p}=ZE(a,s,o.shape,o.dtype);return[n.makeTensorInfo(u,o.dtype,l),n.makeTensorInfo([p.length],"int32",p)]}var wR={kernelName:Du,backendName:"webgl",kernelFunc:G6};function W6(r){let{inputs:t,backend:e,attrs:n}=r,{value:s}=t,{axis:o}=n;o<0&&(o+=s.shape.length);let a=s,l=a.shape.length,u=s.shape[o],p=new Array(l-1),f=0;for(let v=0;v<l;v++)v!==o&&(p[f++]=a.shape[v]);let m=[],d=new Array(l).fill(0),y=a.shape.slice();y[o]=1;let _=new Array(u);for(let v=0;v<_.length;v++){d[o]=v;let C=xi({inputs:{x:a},backend:e,attrs:{begin:d,size:y}}),N=Gt({inputs:{x:C},backend:e,attrs:{shape:p}});_[v]=N,m.push(C)}return m.forEach(v=>e.disposeIntermediateTensorInfo(v)),_}var CR={kernelName:ma,backendName:"webgl",kernelFunc:W6};var d0=class{constructor(t,e){this.variableNames=["x","segmentIds"];let n=t.windowSize,s=t.batchSize,o=t.inSize,a=t.numSegments,l=a*Math.ceil(o/n);this.outputShape=[s,l];let u="0.0",p="sumValue",f=Math.floor(n/4)*4,m=n%4,d=`
        sumValue += dot(values, segFilter);
    `,y="";o%n>0&&(y=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return initializationValue;
        }
      `);let _="";o%n>0&&(_=`
        if (inIdx < 0 || inIdx >= ${o}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${u};

      float getValue(int batch, int inIdx) {
        ${y}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${_}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${n}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${f}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${f};
        if (${m===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${m===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${m===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${p});
      }
    `}};function U6(r){let{inputs:t,backend:e,attrs:n}=r,{x:s,segmentIds:o}=t,{numSegments:a}=n,l=s.shape.length,u=[],p=0,f=H.getAxesPermutation([p],l),m=s;f!=null&&(m=yr({inputs:{x:s},backend:e,attrs:{perm:f}}),u.push(m),p=H.getInnerMostAxes(1,l)[0]);let d=H.segment_util.computeOutShape(m.shape,p,a),y=E.sizeFromShape([m.shape[p]]),_=Gt({inputs:{x:m},backend:e,attrs:{shape:[-1,y]}});u.push(_);let v=Lu(s.dtype),C=(P,L,Z,K,et)=>{let it=P.shape[0],xt=P.shape[1],wt=H.segment_util.segOpComputeOptimalWindowSize(xt,et),St={windowSize:wt,inSize:xt,batchSize:it,numSegments:et},yt=new d0(St,L),Nt=e.compileAndRun(yt,[P,Z],K);if(u.push(Nt),Nt.shape[1]===et)return Nt;let ht=r0({backend:e,attrs:{start:0,stop:et,step:1,dtype:"float32"}}),It=m0({inputs:{x:ht},backend:e,attrs:{reps:[xt/wt]}});return u.push(ht),u.push(It),C(Nt,L,It,K,et)},N=C(_,"unsortedSegmentSum",o,v,a),A=Gt({inputs:{x:N},backend:e,attrs:{shape:d}}),B=A;if(f!=null){u.push(A);let P=H.getUndoAxesPermutation(f);B=yr({inputs:{x:B},backend:e,attrs:{perm:P}})}return u.forEach(P=>e.disposeIntermediateTensorInfo(P)),B}var kR={kernelName:da,backendName:"webgl",kernelFunc:U6};var j6=[lD,uD,CA,SA,IA,NA,EA,AA,$A,DA,OA,PA,LA,zA,BA,MA,VA,WA,GA,UA,jA,qA,HA,XA,YA,t$,r$,n$,o$,pA,l$,c$,p$,u$,h$,m$,f$,d$,g$,x$,b$,v$,w$,k$,S$,C$,I$,N$,T$,E$,A$,$$,R$,F$,P$,L$,z$,M$,V$,G$,W$,U$,j$,q$,H$,K$,X$,cA,Y$,i$,Z$,J$,Q$,fA,tD,eD,rD,sD,nD,oD,iD,aD,pD,mD,hD,dD,gD,yD,fD,bD,vD,wD,CD,kD,ED,xA,$D,DD,RD,FD,ZA,OD,zD,MD,BD,VD,hA,GD,WD,JA,SD,UD,qD,jD,_A,HD,KD,XD,YD,ZD,JD,QD,tR,eR,rR,nR,sR,oR,iR,aR,KA,TD,lR,uR,cR,pR,fR,hR,dR,gR,xR,ND,vA,yR,_R,bR,vR,wA,wR,CR,kR,PD];for(let r of j6)ph(r);function q6(r){let t;return r?(t=r.toIterable)?t.call(r):r:[]}var IR=Symbol.for("#init"),NR=Symbol(),TR=Symbol(),ER=Symbol(),Sf,H6,AR;hv();var g0=class extends Kf{render(){var t,e,n,s,o,a;return t=this,t.open$(),e=n=1,t[NR]===1||(e=n=0,t[NR]=1),(!e||n&2)&&t.flagSelf$("cz-c"),o=a=1,(s=t[TR])||(o=a=0,t[TR]=s=Mg(x0,t,"cz-d cz_b",null)),o||!s.setup||s.setup(a),s.end$(a),o||s.insertInto$(t),t.close$(n),t}};Bg("main-gen-cz",g0,{ns:"cz_b"});var x0=class extends Kf{[IR](t=null){var e;super[IR](arguments[0]),this.clicked=t&&(e=t.clicked)!==void 0?e:!1,this.model=t?t.model:void 0,this.predicted_number=t?t.predicted_number:void 0,this.prob=t?t.prob:void 0}async mount(){var t=this;this.p=new SR.PaperScope,this.p.setup(this.$paperCanvas);let e=new this.p.Tool;return e.onMouseDown=function(n){return t.clicked=!0,t.path=new t.p.Path,t.path.strokeColor="white",t.path.strokeWidth=25,t.path.strokeCap="round",t.path.strokeJoin="round",t.path.sendToBack(),t.$predict.disabled=!1},e.onMouseDrag=function(n){return t.path.add(n.point)},e.onMouseUp=function(){return t.path.smooth(),t.path.simplify(10)},this.model=await gy("./models/model.json")}preprocessCanvas(t){return this.tensor=wh.fromPixels(t).resizeNearestNeighbor([28,28]).mean(2).expandDims(2).expandDims().toFloat(),this.tensor.div(255)}async getResult(t){var e;if(this.$output.innerHTML="",this.p.project.isEmpty()){this.write("Please draw something...",this.$output);return}return this.tensor=this.preprocessCanvas(t),this.predictions=await this.model.predict(this.tensor),this.predicted_number=this.predictions.argMax(1).dataSync()[0],this.prob=this.predictions.arraySync()[0][this.predicted_number],.85<(e=this.prob)&&e<.95?(this.$output.style.color="green",this.write("Hmm this looks like number "+this.predicted_number+".",this.$output)):this.prob>=.95?(this.$output.style.color="green",this.write("I'm quite sure that it's number "+this.predicted_number+"!",this.$output)):(this.$output.style.color="purple",this.write("Your handwriting's unpredictable! Try again please...",this.$output))}sleep(t){return new Promise(function(e){return setTimeout(e,t)})}async write(t,e){var n;n=[];for(let s=0,o=q6(t),a=o.length;s<a;s++){let l=o[s];l=="!"?(e.innerHTML+=l,e.innerHTML+="<br>"):e.innerHTML+=l,n.push(await this.sleep(10))}return n}render(){var t=this,e,n,s,o,a,l,u,p,f;return e=this,e.open$(),n=s=1,e[ER]===1||(n=s=0,e[ER]=1),(!n||s&2)&&e.flagSelf$("cz-f"),n||(o=Ha("div",e,"cz-g cz_e",null)),n||(a=this.$paperCanvas=Ha("canvas",o,"cz-h shadow cz_e paperCanvas ref--paperCanvas",null)),n||(a.width=400),n||(a.height=400),n||(l=Ha("div",o,"cz-i cz_e",null)),n||(u=this.$predict=Ha("button",l,"cz-j primary cz_e predict ref--predict","Predict")),n||u.on$("click",{$_:[function(m,d){return t.clicked?t.getResult(t.$paperCanvas):t.$output.innerHTML="Please draw a number first!",t.$predict.disabled=!0}]},this),n||(p=this.$clear=Ha("button",l,"cz-k danger cz_e clear ref--clear","Clear")),n||p.on$("click",{$_:[function(m,d){return t.p.project.clear(),t.p.view.draw(),t.$predict.disabled=!1}]},this),n||(f=this.$output=Ha("p",o,"cz-l cz_e output ref--output","Write a number.")),e.close$(s),e}};Bg("digit-gen-cz",x0,{ns:"cz_e"});cv((Sf=Mg(g0,null,"cz-m",null),H6||!Sf.setup||Sf.setup(AR),Sf.end$(AR),Sf));
/*!
 * Paper.js v0.12.11 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2020, Jrg Lehni & Jonathan Puckey
 * http://juerglehni.com/ & https://puckey.studio/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Fri Jun 19 19:14:33 2020 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2020 Jrg Lehni
 * http://juerglehni.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * https://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */
/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */
/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
/** @license See the LICENSE file. */
//# sourceMappingURL=index.RLBOILYW.js.map
